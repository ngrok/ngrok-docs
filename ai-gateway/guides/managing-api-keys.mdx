---
title: Managing Provider API Keys
description: Securely manage provider API keys for AI providers
---

This guide covers how to store, rotate, and manage provider API keys for your AI Gateway.

## Key Storage Options

### Inline Keys (Development Only)

Store keys directly in your traffic policy:

```yaml
providers:
  - id: "openai"
    api_keys:
      - value: "sk-proj-abc123..."
```

<Warning>
Inline keys are visible in traffic policy configurations. Use only for local development and testing. See [ngrok Secrets](#ngrok-secrets-recommended) for the recommended approach.
</Warning>

### ngrok Secrets (Recommended)

Store and reference keys securely with [ngrok secrets](/traffic-policy/secrets):

```yaml
providers:
  - id: "openai"
    api_keys:
      - value: ${secrets.get('openai', 'key-one')}
      - value: ${secrets.get('openai', 'key-two')}
```

## Creating Secrets

### Using the CLI

```bash
ngrok api secrets create \
  --name openai \
  --secret-data '{"key-one": "sk-proj-abc123...", "key-two": "sk-proj-def456..."}'
```

### Using the Dashboard

1. Navigate to [**Vaults & Secrets**](https://dashboard.ngrok.com/vaults) in the ngrok Dashboard
2. Create a new secret (for example, `openai`)
3. Add your provider API keys as key-value pairs

## Multiple Keys for Failover

Configure multiple provider API keys for automatic failover when keys hit rate limits or fail:

```yaml
providers:
  - id: "openai"
    api_keys:
      - value: ${secrets.get('openai', 'primary')}
      - value: ${secrets.get('openai', 'backup')}
      - value: ${secrets.get('openai', 'emergency')}
```

**Failover behavior**:
1. Gateway tries the first key
2. If it fails (rate limit, quota exceeded, error), tries the next key
3. Continues until a key succeeds or all keys are exhausted

**Key ordering matters**: Keys are tried in the order listed. Place your highest-capacity keys first.

## Key Rotation

To rotate provider API keys without downtime:

### Step 1: Add the new key

```yaml
api_keys:
  - value: ${secrets.get('openai', 'old-key')}
  - value: ${secrets.get('openai', 'new-key')}  # Added
```

### Step 2: Deploy and monitor

Deploy the updated traffic policy. Monitor traffic to ensure the new key works correctly.

### Step 3: Remove the old key

Once confirmed, remove the old key:

```yaml
api_keys:
  - value: ${secrets.get('openai', 'new-key')}
```

### Step 4: Revoke the old key

Revoke the old key with your provider (OpenAI, Anthropic, etc.) to complete the rotation.

## Multi-Provider Example

```yaml
on_http_request:
  - type: ai-gateway
    config:
      providers:
        - id: "openai"
          api_keys:
            - value: ${secrets.get('openai', 'team-a-key')}
            - value: ${secrets.get('openai', 'team-b-key')}
            - value: ${secrets.get('openai', 'shared-backup')}
        
        - id: "anthropic"
          api_keys:
            - value: ${secrets.get('anthropic', 'primary')}
            - value: ${secrets.get('anthropic', 'secondary')}
        
        - id: "google"
          api_keys:
            - value: ${secrets.get('google', 'key')}
```

This configuration provides:
- 3 failover keys for OpenAI
- 2 failover keys for Anthropic
- 1 key for Google
- Automatic key rotation on failures

## Intelligent Key Selection

For advanced control over which API key is used, configure `api_key_selection` with CEL expressions. This enables intelligent key rotation based on runtime metrics like quota usage and error rates.

### Basic Configuration

```yaml
on_http_request:
  - type: ai-gateway
    config:
      providers:
        - id: openai
          api_keys:
            - value: ${secrets.get('openai', 'key-one')}
            - value: ${secrets.get('openai', 'key-two')}
            - value: ${secrets.get('openai', 'key-three')}
      
      api_key_selection:
        strategy:
          - "ai.keys.filter(k, k.quota.remaining_requests > 100)"
          - "ai.keys"
```

### How It Works

Strategies execute **in order** until one returns at least one key:

1. First strategy filters keys with >100 remaining requests
2. If no keys match, falls back to all keys
3. Selected keys are then tried in order for failover

### Quota-Based Selection

Prioritize keys with remaining capacity:

```yaml
api_key_selection:
  strategy:
    # High capacity keys first
    - "ai.keys.filter(k, k.quota.remaining_requests > 500)"
    # Medium capacity keys
    - "ai.keys.filter(k, k.quota.remaining_requests > 100)"
    # Any key with quota
    - "ai.keys.filter(k, k.quota.remaining_requests > 0)"
    # Fall back to all keys
    - "ai.keys"
```

### Error Rate-Based Selection

Avoid keys experiencing issues:

```yaml
api_key_selection:
  strategy:
    # Keys with very low rate limit errors
    - "ai.keys.filter(k, k.error_rate.rate_limit < 0.05)"
    # Keys with acceptable error rates
    - "ai.keys.filter(k, k.error_rate.total < 0.2)"
    # Fall back to all keys
    - "ai.keys"
```

### Load Distribution

Randomize key selection to distribute load:

```yaml
api_key_selection:
  strategy:
    # Randomly select from keys with good quota
    - "ai.keys.filter(k, k.quota.remaining_requests > 100).randomize()"
    # Fall back to any key
    - "ai.keys.randomize()"
```

### Available Key Variables

| Variable | Description |
|----------|-------------|
| `k.quota.remaining_requests` | Requests remaining before rate limit |
| `k.quota.remaining_tokens` | Tokens remaining before rate limit |
| `k.error_rate.total` | Fraction of all errors (0.0 to 1.0) |
| `k.error_rate.rate_limit` | Fraction of rate limit (429) errors |
| `k.error_rate.timeout` | Fraction of timeout errors |

See [CEL Functions Reference](/ai-gateway/reference/cel-functions#api-key-selection) for the complete list.

## Security Best Practices

- **Add authorization** to your gateway when using server-side keysâ€”see [Securing Your Gateway](/ai-gateway/guides/securing-endpoints)
- **Never commit provider API keys** to version control
- **Use ngrok secrets** for all production keys
- **Rotate keys regularly** to minimize exposure risk
- **Monitor key usage** to detect anomalies
- **Use different keys** for different environments (dev, staging, prod)
- **Set up alerts** for rate limit errors to proactively add capacity

## Passthrough Mode

If you don't configure any keys for a provider, the gateway forwards whatever key your SDK sends:

```yaml
providers:
  - id: "openai"
    # No api_keys - SDK key is forwarded
```

This is useful for:
- Development environments where each developer uses their own key
- Applications that already manage their own keys
- Quick testing without configuration changes

## Next Steps

- [Securing Your Gateway](/ai-gateway/guides/securing-endpoints) - Add authorization when using server-side keys
- [Provider API Keys Concept](/ai-gateway/concepts/api-keys) - Understanding key precedence
- [Multi-Key Failover](/ai-gateway/examples/multi-key-failover) - Example configurations with intelligent selection
- [Configuring Providers](/ai-gateway/guides/configuring-providers) - Full provider setup
- [CEL Functions Reference](/ai-gateway/reference/cel-functions#api-key-selection) - Complete API key selection reference
