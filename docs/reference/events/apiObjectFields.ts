
// Code generated by protoc-gen-gongrok. DO NOT EDIT.

export type ApiObjectField = {
  name: string
  desc: string
  type: string
};

export type ApiObjectName = 
  | 'APIKey'
  | 'APIKeyCreate'
  | 'APIKeyList'
  | 'APIKeyUpdate'
  | 'AWSAuth'
  | 'AWSCredentials'
  | 'AWSRole'
  | 'AbuseReport'
  | 'AbuseReportCreate'
  | 'AbuseReportHostname'
  | 'AgentIngress'
  | 'AgentIngressCreate'
  | 'AgentIngressList'
  | 'AgentIngressUpdate'
  | 'ApplicationSession'
  | 'ApplicationSessionList'
  | 'ApplicationUser'
  | 'ApplicationUserList'
  | 'BrowserSession'
  | 'CertificateAuthority'
  | 'CertificateAuthorityCreate'
  | 'CertificateAuthorityList'
  | 'CertificateAuthorityUpdate'
  | 'Credential'
  | 'CredentialCreate'
  | 'CredentialList'
  | 'CredentialUpdate'
  | 'EdgeBackendReplace'
  | 'EdgeIPRestrictionReplace'
  | 'EdgeMutualTLSReplace'
  | 'EdgeRouteBackendReplace'
  | 'EdgeRouteCircuitBreakerReplace'
  | 'EdgeRouteCompressionReplace'
  | 'EdgeRouteIPRestrictionReplace'
  | 'EdgeRouteItem'
  | 'EdgeRouteOAuthReplace'
  | 'EdgeRouteOIDCReplace'
  | 'EdgeRouteRequestHeadersReplace'
  | 'EdgeRouteResponseHeadersReplace'
  | 'EdgeRouteSAMLReplace'
  | 'EdgeRouteWebhookVerificationReplace'
  | 'EdgeRouteWebsocketTCPConverterReplace'
  | 'EdgeTLSTerminationAtEdgeReplace'
  | 'EdgeTLSTerminationReplace'
  | 'Endpoint'
  | 'EndpointBackend'
  | 'EndpointBackendMutate'
  | 'EndpointBackendReplace'
  | 'EndpointBasicAuth'
  | 'EndpointBasicAuthReplace'
  | 'EndpointCircuitBreaker'
  | 'EndpointCircuitBreakerReplace'
  | 'EndpointCompression'
  | 'EndpointCompressionReplace'
  | 'EndpointConfiguration'
  | 'EndpointConfigurationCreate'
  | 'EndpointConfigurationList'
  | 'EndpointConfigurationUpdate'
  | 'EndpointIPPolicy'
  | 'EndpointIPPolicyMutate'
  | 'EndpointIPPolicyReplace'
  | 'EndpointList'
  | 'EndpointMutualTLS'
  | 'EndpointMutualTLSMutate'
  | 'EndpointMutualTLSReplace'
  | 'EndpointOAuth'
  | 'EndpointOAuthFacebook'
  | 'EndpointOAuthGitHub'
  | 'EndpointOAuthGoogle'
  | 'EndpointOAuthLinkedIn'
  | 'EndpointOAuthMicrosoft'
  | 'EndpointOAuthProvider'
  | 'EndpointOAuthReplace'
  | 'EndpointOIDC'
  | 'EndpointOIDCReplace'
  | 'EndpointRequestHeaders'
  | 'EndpointRequestHeadersReplace'
  | 'EndpointResponseHeaders'
  | 'EndpointResponseHeadersReplace'
  | 'EndpointSAML'
  | 'EndpointSAMLMutate'
  | 'EndpointSAMLReplace'
  | 'EndpointTLSTermination'
  | 'EndpointTLSTerminationAtEdge'
  | 'EndpointTLSTerminationReplace'
  | 'EndpointWebhookValidation'
  | 'EndpointWebhookValidationReplace'
  | 'EndpointWebsocketTCPConverter'
  | 'Error'
  | 'EventDestination'
  | 'EventDestinationCreate'
  | 'EventDestinationList'
  | 'EventDestinationUpdate'
  | 'EventSource'
  | 'EventSourceCreate'
  | 'EventSourceItem'
  | 'EventSourceList'
  | 'EventSourcePaging'
  | 'EventSourceReplace'
  | 'EventSourceUpdate'
  | 'EventSubscription'
  | 'EventSubscriptionCreate'
  | 'EventSubscriptionList'
  | 'EventSubscriptionUpdate'
  | 'EventTarget'
  | 'EventTargetCloudwatchLogs'
  | 'EventTargetDebug'
  | 'EventTargetFirehose'
  | 'EventTargetKinesis'
  | 'EventTargetS3'
  | 'FailoverBackend'
  | 'FailoverBackendCreate'
  | 'FailoverBackendList'
  | 'FailoverBackendUpdate'
  | 'HTTPResponseBackend'
  | 'HTTPResponseBackendCreate'
  | 'HTTPResponseBackendList'
  | 'HTTPResponseBackendUpdate'
  | 'HTTPSEdge'
  | 'HTTPSEdgeCreate'
  | 'HTTPSEdgeList'
  | 'HTTPSEdgeRoute'
  | 'HTTPSEdgeRouteCreate'
  | 'HTTPSEdgeRouteUpdate'
  | 'HTTPSEdgeUpdate'
  | 'IPPolicy'
  | 'IPPolicyCreate'
  | 'IPPolicyList'
  | 'IPPolicyRule'
  | 'IPPolicyRuleCreate'
  | 'IPPolicyRuleList'
  | 'IPPolicyRuleUpdate'
  | 'IPPolicyUpdate'
  | 'IPRestriction'
  | 'IPRestrictionCreate'
  | 'IPRestrictionList'
  | 'IPRestrictionUpdate'
  | 'IdentityProvider'
  | 'Item'
  | 'Location'
  | 'Paging'
  | 'Ref'
  | 'ReservedAddr'
  | 'ReservedAddrCreate'
  | 'ReservedAddrList'
  | 'ReservedAddrUpdate'
  | 'ReservedDomain'
  | 'ReservedDomainCertJob'
  | 'ReservedDomainCertPolicy'
  | 'ReservedDomainCertStatus'
  | 'ReservedDomainCreate'
  | 'ReservedDomainList'
  | 'ReservedDomainUpdate'
  | 'RootResponse'
  | 'SSHCertificateAuthority'
  | 'SSHCertificateAuthorityCreate'
  | 'SSHCertificateAuthorityList'
  | 'SSHCertificateAuthorityUpdate'
  | 'SSHCredential'
  | 'SSHCredentialCreate'
  | 'SSHCredentialList'
  | 'SSHCredentialUpdate'
  | 'SSHHostCertificate'
  | 'SSHHostCertificateCreate'
  | 'SSHHostCertificateList'
  | 'SSHHostCertificateUpdate'
  | 'SSHUserCertificate'
  | 'SSHUserCertificateCreate'
  | 'SSHUserCertificateList'
  | 'SSHUserCertificateUpdate'
  | 'SentEvent'
  | 'StaticBackend'
  | 'StaticBackendCreate'
  | 'StaticBackendList'
  | 'StaticBackendTLS'
  | 'StaticBackendUpdate'
  | 'TCPEdge'
  | 'TCPEdgeCreate'
  | 'TCPEdgeList'
  | 'TCPEdgeUpdate'
  | 'TLSCertificate'
  | 'TLSCertificateCreate'
  | 'TLSCertificateList'
  | 'TLSCertificateSANs'
  | 'TLSCertificateUpdate'
  | 'TLSEdge'
  | 'TLSEdgeCreate'
  | 'TLSEdgeList'
  | 'TLSEdgeUpdate'
  | 'Tunnel'
  | 'TunnelGroupBackend'
  | 'TunnelGroupBackendCreate'
  | 'TunnelGroupBackendList'
  | 'TunnelGroupBackendUpdate'
  | 'TunnelList'
  | 'TunnelSession'
  | 'TunnelSessionList'
  | 'TunnelSessionsUpdate'
  | 'UserAgent'
  | 'WeightedBackend'
  | 'WeightedBackendCreate'
  | 'WeightedBackendList'
  | 'WeightedBackendUpdate';

export const apiObjectFields: Record<ApiObjectName, ApiObjectField[]> = {
  APIKey: [
    {
      name: 'id',
      desc: "unique API key resource identifier",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI to the API resource of this API key",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of what uses the API key to authenticate. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined data of this API key. optional, max 4096 bytes",
      type: 'string',
    },
    {
      name: 'created_at',
      desc: "timestamp when the api key was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'token',
      desc: "the bearer token that can be placed into the Authorization header to authenticate request to the ngrok API. **This value is only available one time, on the API response from key creation. Otherwise it is null.**",
      type: 'string',
    },
    ],
  APIKeyCreate: [
    {
      name: 'description',
      desc: "human-readable description of what uses the API key to authenticate. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined data of this API key. optional, max 4096 bytes",
      type: 'string',
    },
    ],
  APIKeyList: [
    {
      name: 'keys.id',
      desc: "unique API key resource identifier",
      type: 'string',
    },
    {
      name: 'keys.uri',
      desc: "URI to the API resource of this API key",
      type: 'string',
    },
    {
      name: 'keys.description',
      desc: "human-readable description of what uses the API key to authenticate. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'keys.metadata',
      desc: "arbitrary user-defined data of this API key. optional, max 4096 bytes",
      type: 'string',
    },
    {
      name: 'keys.created_at',
      desc: "timestamp when the api key was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'keys.token',
      desc: "the bearer token that can be placed into the Authorization header to authenticate request to the ngrok API. **This value is only available one time, on the API response from key creation. Otherwise it is null.**",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the API keys list API resource",
      type: 'string',
    },
    {
      name: 'next_page_uri',
      desc: "URI of the next page, or null if there is no next page",
      type: 'string',
    },
    ],
  APIKeyUpdate: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of what uses the API key to authenticate. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined data of this API key. optional, max 4096 bytes",
      type: 'string',
    },
    ],
  AWSAuth: [
    {
      name: 'role.role_arn',
      desc: "An ARN that specifies the role that ngrok should use to deliver to the configured target.",
      type: 'string',
    },
    {
      name: 'creds.aws_access_key_id',
      desc: "The ID portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'creds.aws_secret_access_key',
      desc: "The secret portion of an AWS access key.",
      type: 'string',
    },
    ],
  AWSCredentials: [
    {
      name: 'aws_access_key_id',
      desc: "The ID portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'aws_secret_access_key',
      desc: "The secret portion of an AWS access key.",
      type: 'string',
    },
    ],
  AWSRole: [
    {
      name: 'role_arn',
      desc: "An ARN that specifies the role that ngrok should use to deliver to the configured target.",
      type: 'string',
    },
    ],
  AbuseReport: [
    {
      name: 'id',
      desc: "ID of the abuse report",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the abuse report API resource",
      type: 'string',
    },
    {
      name: 'created_at',
      desc: "timestamp that the abuse report record was created in RFC 3339 format",
      type: 'string',
    },
    {
      name: 'urls',
      desc: "a list of URLs containing suspected abusive content",
      type: 'List<string>',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined data about this abuse report. Optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'status',
      desc: "Indicates whether ngrok has processed the abuse report. one of `PENDING`, `PROCESSED`, or `PARTIALLY_PROCESSED`",
      type: 'string',
    },
    {
      name: 'hostnames.hostname',
      desc: "the hostname ngrok has parsed out of one of the reported URLs in this abuse report",
      type: 'string',
    },
    {
      name: 'hostnames.status',
      desc: "indicates what action ngrok has taken against the hostname. one of `PENDING`, `BANNED`, `UNBANNED`, or `IGNORE`",
      type: 'string',
    },
    ],
  AbuseReportCreate: [
    {
      name: 'urls',
      desc: "a list of URLs containing suspected abusive content",
      type: 'List<string>',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined data about this abuse report. Optional, max 4096 bytes.",
      type: 'string',
    },
    ],
  AbuseReportHostname: [
    {
      name: 'hostname',
      desc: "the hostname ngrok has parsed out of one of the reported URLs in this abuse report",
      type: 'string',
    },
    {
      name: 'status',
      desc: "indicates what action ngrok has taken against the hostname. one of `PENDING`, `BANNED`, `UNBANNED`, or `IGNORE`",
      type: 'string',
    },
    ],
  AgentIngress: [
    {
      name: 'id',
      desc: "unique Agent Ingress resource identifier",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI to the API resource of this Agent ingress",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of the use of this Agent Ingress. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this Agent Ingress. optional, max 4096 bytes",
      type: 'string',
    },
    {
      name: 'domain',
      desc: "the domain that you own to be used as the base domain name to generate regional agent ingress domains.",
      type: 'string',
    },
    {
      name: 'ns_targets',
      desc: "a list of target values to use as the values of NS records for the domain property these values will delegate control over the domain to ngrok",
      type: 'List<string>',
    },
    {
      name: 'region_domains',
      desc: "a list of regional agent ingress domains that are subdomains of the value of domain this value may increase over time as ngrok adds more regions",
      type: 'List<string>',
    },
    {
      name: 'created_at',
      desc: "timestamp when the Agent Ingress was created, RFC 3339 format",
      type: 'string',
    },
    ],
  AgentIngressCreate: [
    {
      name: 'description',
      desc: "human-readable description of the use of this Agent Ingress. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this Agent Ingress. optional, max 4096 bytes",
      type: 'string',
    },
    {
      name: 'domain',
      desc: "the domain that you own to be used as the base domain name to generate regional agent ingress domains.",
      type: 'string',
    },
    ],
  AgentIngressList: [
    {
      name: 'ingresses.id',
      desc: "unique Agent Ingress resource identifier",
      type: 'string',
    },
    {
      name: 'ingresses.uri',
      desc: "URI to the API resource of this Agent ingress",
      type: 'string',
    },
    {
      name: 'ingresses.description',
      desc: "human-readable description of the use of this Agent Ingress. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'ingresses.metadata',
      desc: "arbitrary user-defined machine-readable data of this Agent Ingress. optional, max 4096 bytes",
      type: 'string',
    },
    {
      name: 'ingresses.domain',
      desc: "the domain that you own to be used as the base domain name to generate regional agent ingress domains.",
      type: 'string',
    },
    {
      name: 'ingresses.ns_targets',
      desc: "a list of target values to use as the values of NS records for the domain property these values will delegate control over the domain to ngrok",
      type: 'List<string>',
    },
    {
      name: 'ingresses.region_domains',
      desc: "a list of regional agent ingress domains that are subdomains of the value of domain this value may increase over time as ngrok adds more regions",
      type: 'List<string>',
    },
    {
      name: 'ingresses.created_at',
      desc: "timestamp when the Agent Ingress was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the Agent Ingress list API resource",
      type: 'string',
    },
    {
      name: 'next_page_uri',
      desc: "URI of the next page, or null if there is no next page",
      type: 'string',
    },
    ],
  AgentIngressUpdate: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of the use of this Agent Ingress. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this Agent Ingress. optional, max 4096 bytes",
      type: 'string',
    },
    ],
  ApplicationSession: [
    {
      name: 'id',
      desc: "unique application session resource identifier",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the application session API resource",
      type: 'string',
    },
    {
      name: 'public_url',
      desc: "URL of the hostport served by this endpoint",
      type: 'string',
    },
    {
      name: 'browser_session.user_agent.raw',
      desc: "raw User-Agent request header",
      type: 'string',
    },
    {
      name: 'browser_session.user_agent.browser_name',
      desc: "browser name (e.g. Chrome)",
      type: 'string',
    },
    {
      name: 'browser_session.user_agent.browser_version',
      desc: "browser version (e.g. 102)",
      type: 'string',
    },
    {
      name: 'browser_session.user_agent.device_type',
      desc: "type of device (e.g. Desktop)",
      type: 'string',
    },
    {
      name: 'browser_session.user_agent.os_name',
      desc: "operating system name (e.g. MacOS)",
      type: 'string',
    },
    {
      name: 'browser_session.user_agent.os_version',
      desc: "operating system version (e.g. 10.15.7)",
      type: 'string',
    },
    {
      name: 'browser_session.ip_address',
      desc: "IP address",
      type: 'string',
    },
    {
      name: 'browser_session.location.country_code',
      desc: "ISO country code",
      type: 'string',
    },
    {
      name: 'browser_session.location.latitude',
      desc: "geographical latitude",
      type: 'float64',
    },
    {
      name: 'browser_session.location.longitude',
      desc: "geographical longitude",
      type: 'float64',
    },
    {
      name: 'browser_session.location.lat_long_radius_km',
      desc: "accuracy radius of the geographical coordinates",
      type: 'uint64',
    },
    {
      name: 'application_user.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'application_user.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'created_at',
      desc: "timestamp when the user was created in RFC 3339 format",
      type: 'string',
    },
    {
      name: 'last_active',
      desc: "timestamp when the user was last active in RFC 3339 format",
      type: 'string',
    },
    {
      name: 'expires_at',
      desc: "timestamp when session expires in RFC 3339 format",
      type: 'string',
    },
    {
      name: 'endpoint.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'endpoint.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'edge.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'edge.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'route.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'route.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    ],
  ApplicationSessionList: [
    {
      name: 'application_sessions.id',
      desc: "unique application session resource identifier",
      type: 'string',
    },
    {
      name: 'application_sessions.uri',
      desc: "URI of the application session API resource",
      type: 'string',
    },
    {
      name: 'application_sessions.public_url',
      desc: "URL of the hostport served by this endpoint",
      type: 'string',
    },
    {
      name: 'application_sessions.browser_session.user_agent.raw',
      desc: "raw User-Agent request header",
      type: 'string',
    },
    {
      name: 'application_sessions.browser_session.user_agent.browser_name',
      desc: "browser name (e.g. Chrome)",
      type: 'string',
    },
    {
      name: 'application_sessions.browser_session.user_agent.browser_version',
      desc: "browser version (e.g. 102)",
      type: 'string',
    },
    {
      name: 'application_sessions.browser_session.user_agent.device_type',
      desc: "type of device (e.g. Desktop)",
      type: 'string',
    },
    {
      name: 'application_sessions.browser_session.user_agent.os_name',
      desc: "operating system name (e.g. MacOS)",
      type: 'string',
    },
    {
      name: 'application_sessions.browser_session.user_agent.os_version',
      desc: "operating system version (e.g. 10.15.7)",
      type: 'string',
    },
    {
      name: 'application_sessions.browser_session.ip_address',
      desc: "IP address",
      type: 'string',
    },
    {
      name: 'application_sessions.browser_session.location.country_code',
      desc: "ISO country code",
      type: 'string',
    },
    {
      name: 'application_sessions.browser_session.location.latitude',
      desc: "geographical latitude",
      type: 'float64',
    },
    {
      name: 'application_sessions.browser_session.location.longitude',
      desc: "geographical longitude",
      type: 'float64',
    },
    {
      name: 'application_sessions.browser_session.location.lat_long_radius_km',
      desc: "accuracy radius of the geographical coordinates",
      type: 'uint64',
    },
    {
      name: 'application_sessions.application_user.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'application_sessions.application_user.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'application_sessions.created_at',
      desc: "timestamp when the user was created in RFC 3339 format",
      type: 'string',
    },
    {
      name: 'application_sessions.last_active',
      desc: "timestamp when the user was last active in RFC 3339 format",
      type: 'string',
    },
    {
      name: 'application_sessions.expires_at',
      desc: "timestamp when session expires in RFC 3339 format",
      type: 'string',
    },
    {
      name: 'application_sessions.endpoint.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'application_sessions.endpoint.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'application_sessions.edge.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'application_sessions.edge.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'application_sessions.route.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'application_sessions.route.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the application session list API resource",
      type: 'string',
    },
    {
      name: 'next_page_uri',
      desc: "URI of the next page, or null if there is no next page",
      type: 'string',
    },
    ],
  ApplicationUser: [
    {
      name: 'id',
      desc: "unique application user resource identifier",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the application user API resource",
      type: 'string',
    },
    {
      name: 'identity_provider.name',
      desc: "name of the identity provider (e.g. Google)",
      type: 'string',
    },
    {
      name: 'identity_provider.url',
      desc: "URL of the identity provider (e.g. https://accounts.google.com)",
      type: 'string',
    },
    {
      name: 'provider_user_id',
      desc: "unique user identifier",
      type: 'string',
    },
    {
      name: 'username',
      desc: "user username",
      type: 'string',
    },
    {
      name: 'email',
      desc: "user email",
      type: 'string',
    },
    {
      name: 'name',
      desc: "user common name",
      type: 'string',
    },
    {
      name: 'created_at',
      desc: "timestamp when the user was created in RFC 3339 format",
      type: 'string',
    },
    {
      name: 'last_active',
      desc: "timestamp when the user was last active in RFC 3339 format",
      type: 'string',
    },
    {
      name: 'last_login',
      desc: "timestamp when the user last signed-in in RFC 3339 format",
      type: 'string',
    },
    ],
  ApplicationUserList: [
    {
      name: 'application_users.id',
      desc: "unique application user resource identifier",
      type: 'string',
    },
    {
      name: 'application_users.uri',
      desc: "URI of the application user API resource",
      type: 'string',
    },
    {
      name: 'application_users.identity_provider.name',
      desc: "name of the identity provider (e.g. Google)",
      type: 'string',
    },
    {
      name: 'application_users.identity_provider.url',
      desc: "URL of the identity provider (e.g. https://accounts.google.com)",
      type: 'string',
    },
    {
      name: 'application_users.provider_user_id',
      desc: "unique user identifier",
      type: 'string',
    },
    {
      name: 'application_users.username',
      desc: "user username",
      type: 'string',
    },
    {
      name: 'application_users.email',
      desc: "user email",
      type: 'string',
    },
    {
      name: 'application_users.name',
      desc: "user common name",
      type: 'string',
    },
    {
      name: 'application_users.created_at',
      desc: "timestamp when the user was created in RFC 3339 format",
      type: 'string',
    },
    {
      name: 'application_users.last_active',
      desc: "timestamp when the user was last active in RFC 3339 format",
      type: 'string',
    },
    {
      name: 'application_users.last_login',
      desc: "timestamp when the user last signed-in in RFC 3339 format",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the application user list API resource",
      type: 'string',
    },
    {
      name: 'next_page_uri',
      desc: "URI of the next page, or null if there is no next page",
      type: 'string',
    },
    ],
  BrowserSession: [
    {
      name: 'user_agent.raw',
      desc: "raw User-Agent request header",
      type: 'string',
    },
    {
      name: 'user_agent.browser_name',
      desc: "browser name (e.g. Chrome)",
      type: 'string',
    },
    {
      name: 'user_agent.browser_version',
      desc: "browser version (e.g. 102)",
      type: 'string',
    },
    {
      name: 'user_agent.device_type',
      desc: "type of device (e.g. Desktop)",
      type: 'string',
    },
    {
      name: 'user_agent.os_name',
      desc: "operating system name (e.g. MacOS)",
      type: 'string',
    },
    {
      name: 'user_agent.os_version',
      desc: "operating system version (e.g. 10.15.7)",
      type: 'string',
    },
    {
      name: 'ip_address',
      desc: "IP address",
      type: 'string',
    },
    {
      name: 'location.country_code',
      desc: "ISO country code",
      type: 'string',
    },
    {
      name: 'location.latitude',
      desc: "geographical latitude",
      type: 'float64',
    },
    {
      name: 'location.longitude',
      desc: "geographical longitude",
      type: 'float64',
    },
    {
      name: 'location.lat_long_radius_km',
      desc: "accuracy radius of the geographical coordinates",
      type: 'uint64',
    },
    ],
  CertificateAuthority: [
    {
      name: 'id',
      desc: "unique identifier for this Certificate Authority",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the Certificate Authority API resource",
      type: 'string',
    },
    {
      name: 'created_at',
      desc: "timestamp when the Certificate Authority was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of this Certificate Authority. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this Certificate Authority. optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'ca_pem',
      desc: "raw PEM of the Certificate Authority",
      type: 'string',
    },
    {
      name: 'subject_common_name',
      desc: "subject common name of the Certificate Authority",
      type: 'string',
    },
    {
      name: 'not_before',
      desc: "timestamp when this Certificate Authority becomes valid, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'not_after',
      desc: "timestamp when this Certificate Authority becomes invalid, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'key_usages',
      desc: "set of actions the private key of this Certificate Authority can be used for",
      type: 'List<string>',
    },
    {
      name: 'extended_key_usages',
      desc: "extended set of actions the private key of this Certificate Authority can be used for",
      type: 'List<string>',
    },
    ],
  CertificateAuthorityCreate: [
    {
      name: 'description',
      desc: "human-readable description of this Certificate Authority. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this Certificate Authority. optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'ca_pem',
      desc: "raw PEM of the Certificate Authority",
      type: 'string',
    },
    ],
  CertificateAuthorityList: [
    {
      name: 'certificate_authorities.id',
      desc: "unique identifier for this Certificate Authority",
      type: 'string',
    },
    {
      name: 'certificate_authorities.uri',
      desc: "URI of the Certificate Authority API resource",
      type: 'string',
    },
    {
      name: 'certificate_authorities.created_at',
      desc: "timestamp when the Certificate Authority was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'certificate_authorities.description',
      desc: "human-readable description of this Certificate Authority. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'certificate_authorities.metadata',
      desc: "arbitrary user-defined machine-readable data of this Certificate Authority. optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'certificate_authorities.ca_pem',
      desc: "raw PEM of the Certificate Authority",
      type: 'string',
    },
    {
      name: 'certificate_authorities.subject_common_name',
      desc: "subject common name of the Certificate Authority",
      type: 'string',
    },
    {
      name: 'certificate_authorities.not_before',
      desc: "timestamp when this Certificate Authority becomes valid, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'certificate_authorities.not_after',
      desc: "timestamp when this Certificate Authority becomes invalid, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'certificate_authorities.key_usages',
      desc: "set of actions the private key of this Certificate Authority can be used for",
      type: 'List<string>',
    },
    {
      name: 'certificate_authorities.extended_key_usages',
      desc: "extended set of actions the private key of this Certificate Authority can be used for",
      type: 'List<string>',
    },
    {
      name: 'uri',
      desc: "URI of the certificates authorities list API resource",
      type: 'string',
    },
    {
      name: 'next_page_uri',
      desc: "URI of the next page, or null if there is no next page",
      type: 'string',
    },
    ],
  CertificateAuthorityUpdate: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of this Certificate Authority. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this Certificate Authority. optional, max 4096 bytes.",
      type: 'string',
    },
    ],
  Credential: [
    {
      name: 'id',
      desc: "unique tunnel credential resource identifier",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the tunnel credential API resource",
      type: 'string',
    },
    {
      name: 'created_at',
      desc: "timestamp when the tunnel credential was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of who or what will use the credential to authenticate. Optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this credential. Optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'token',
      desc: "the credential's authtoken that can be used to authenticate an ngrok agent. **This value is only available one time, on the API response from credential creation, otherwise it is null.**",
      type: 'string',
    },
    {
      name: 'acl',
      desc: "optional list of ACL rules. If unspecified, the credential will have no restrictions. The only allowed ACL rule at this time is the `bind` rule. The `bind` rule allows the caller to restrict what domains, addresses, and labels the token is allowed to bind. For example, to allow the token to open a tunnel on example.ngrok.io your ACL would include the rule `bind:example.ngrok.io`. Bind rules for domains may specify a leading wildcard to match multiple domains with a common suffix. For example, you may specify a rule of `bind:*.example.com` which will allow `x.example.com`, `y.example.com`, `*.example.com`, etc. Bind rules for labels may specify a wildcard key and/or value to match multiple labels. For example, you may specify a rule of `bind:*=example` which will allow `x=example`, `y=example`, etc. A rule of `'*'` is equivalent to no acl at all and will explicitly permit all actions.",
      type: 'List<string>',
    },
    ],
  CredentialCreate: [
    {
      name: 'description',
      desc: "human-readable description of who or what will use the credential to authenticate. Optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this credential. Optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'acl',
      desc: "optional list of ACL rules. If unspecified, the credential will have no restrictions. The only allowed ACL rule at this time is the `bind` rule. The `bind` rule allows the caller to restrict what domains, addresses, and labels the token is allowed to bind. For example, to allow the token to open a tunnel on example.ngrok.io your ACL would include the rule `bind:example.ngrok.io`. Bind rules for domains may specify a leading wildcard to match multiple domains with a common suffix. For example, you may specify a rule of `bind:*.example.com` which will allow `x.example.com`, `y.example.com`, `*.example.com`, etc. Bind rules for labels may specify a wildcard key and/or value to match multiple labels. For example, you may specify a rule of `bind:*=example` which will allow `x=example`, `y=example`, etc. A rule of `'*'` is equivalent to no acl at all and will explicitly permit all actions.",
      type: 'List<string>',
    },
    ],
  CredentialList: [
    {
      name: 'credentials.id',
      desc: "unique tunnel credential resource identifier",
      type: 'string',
    },
    {
      name: 'credentials.uri',
      desc: "URI of the tunnel credential API resource",
      type: 'string',
    },
    {
      name: 'credentials.created_at',
      desc: "timestamp when the tunnel credential was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'credentials.description',
      desc: "human-readable description of who or what will use the credential to authenticate. Optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'credentials.metadata',
      desc: "arbitrary user-defined machine-readable data of this credential. Optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'credentials.token',
      desc: "the credential's authtoken that can be used to authenticate an ngrok agent. **This value is only available one time, on the API response from credential creation, otherwise it is null.**",
      type: 'string',
    },
    {
      name: 'credentials.acl',
      desc: "optional list of ACL rules. If unspecified, the credential will have no restrictions. The only allowed ACL rule at this time is the `bind` rule. The `bind` rule allows the caller to restrict what domains, addresses, and labels the token is allowed to bind. For example, to allow the token to open a tunnel on example.ngrok.io your ACL would include the rule `bind:example.ngrok.io`. Bind rules for domains may specify a leading wildcard to match multiple domains with a common suffix. For example, you may specify a rule of `bind:*.example.com` which will allow `x.example.com`, `y.example.com`, `*.example.com`, etc. Bind rules for labels may specify a wildcard key and/or value to match multiple labels. For example, you may specify a rule of `bind:*=example` which will allow `x=example`, `y=example`, etc. A rule of `'*'` is equivalent to no acl at all and will explicitly permit all actions.",
      type: 'List<string>',
    },
    {
      name: 'uri',
      desc: "URI of the tunnel credential list API resource",
      type: 'string',
    },
    {
      name: 'next_page_uri',
      desc: "URI of the next page, or null if there is no next page",
      type: 'string',
    },
    ],
  CredentialUpdate: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of who or what will use the credential to authenticate. Optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this credential. Optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'acl',
      desc: "optional list of ACL rules. If unspecified, the credential will have no restrictions. The only allowed ACL rule at this time is the `bind` rule. The `bind` rule allows the caller to restrict what domains, addresses, and labels the token is allowed to bind. For example, to allow the token to open a tunnel on example.ngrok.io your ACL would include the rule `bind:example.ngrok.io`. Bind rules for domains may specify a leading wildcard to match multiple domains with a common suffix. For example, you may specify a rule of `bind:*.example.com` which will allow `x.example.com`, `y.example.com`, `*.example.com`, etc. Bind rules for labels may specify a wildcard key and/or value to match multiple labels. For example, you may specify a rule of `bind:*=example` which will allow `x=example`, `y=example`, etc. A rule of `'*'` is equivalent to no acl at all and will explicitly permit all actions.",
      type: 'List<string>',
    },
    ],
  EdgeBackendReplace: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'module.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'module.backend_id',
      desc: "backend to be used to back this endpoint",
      type: 'string',
    },
    ],
  EdgeIPRestrictionReplace: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'module.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'module.ip_policy_ids',
      desc: "list of all IP policies that will be used to check if a source IP is allowed access to the endpoint",
      type: 'List<string>',
    },
    ],
  EdgeMutualTLSReplace: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'module.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'module.certificate_authority_ids',
      desc: "list of certificate authorities that will be used to validate the TLS client certificate presented by the initiator of the TLS connection",
      type: 'List<string>',
    },
    ],
  EdgeRouteBackendReplace: [
    {
      name: 'edge_id',
      desc: "",
      type: 'string',
    },
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'module.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'module.backend_id',
      desc: "backend to be used to back this endpoint",
      type: 'string',
    },
    ],
  EdgeRouteCircuitBreakerReplace: [
    {
      name: 'edge_id',
      desc: "",
      type: 'string',
    },
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'module.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'module.tripped_duration',
      desc: "Integer number of seconds after which the circuit is tripped to wait before re-evaluating upstream health",
      type: 'uint32',
    },
    {
      name: 'module.rolling_window',
      desc: "Integer number of seconds in the statistical rolling window that metrics are retained for.",
      type: 'uint32',
    },
    {
      name: 'module.num_buckets',
      desc: "Integer number of buckets into which metrics are retained. Max 128.",
      type: 'uint32',
    },
    {
      name: 'module.volume_threshold',
      desc: "Integer number of requests in a rolling window that will trip the circuit. Helpful if traffic volume is low.",
      type: 'uint32',
    },
    {
      name: 'module.error_threshold_percentage',
      desc: "Error threshold percentage should be between 0 - 1.0, not 0-100.0",
      type: 'float64',
    },
    ],
  EdgeRouteCompressionReplace: [
    {
      name: 'edge_id',
      desc: "",
      type: 'string',
    },
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'module.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    ],
  EdgeRouteIPRestrictionReplace: [
    {
      name: 'edge_id',
      desc: "",
      type: 'string',
    },
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'module.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'module.ip_policy_ids',
      desc: "list of all IP policies that will be used to check if a source IP is allowed access to the endpoint",
      type: 'List<string>',
    },
    ],
  EdgeRouteItem: [
    {
      name: 'edge_id',
      desc: "unique identifier of this edge",
      type: 'string',
    },
    {
      name: 'id',
      desc: "unique identifier of this edge route",
      type: 'string',
    },
    ],
  EdgeRouteOAuthReplace: [
    {
      name: 'edge_id',
      desc: "",
      type: 'string',
    },
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'module.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'module.provider.github.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'module.provider.github.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'module.provider.github.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'module.provider.github.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'module.provider.github.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'module.provider.github.teams',
      desc: "a list of github teams identifiers. users will be allowed access to the endpoint if they are a member of any of these teams. identifiers should be in the 'slug' format qualified with the org name, e.g. `org-name/team-name`",
      type: 'List<string>',
    },
    {
      name: 'module.provider.github.organizations',
      desc: "a list of github org identifiers. users who are members of any of the listed organizations will be allowed access. identifiers should be the organization's 'slug'",
      type: 'List<string>',
    },
    {
      name: 'module.provider.facebook.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'module.provider.facebook.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'module.provider.facebook.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'module.provider.facebook.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'module.provider.facebook.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'module.provider.microsoft.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'module.provider.microsoft.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'module.provider.microsoft.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'module.provider.microsoft.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'module.provider.microsoft.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'module.provider.google.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'module.provider.google.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'module.provider.google.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'module.provider.google.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'module.provider.google.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'module.provider.linkedin.client_id',
      desc: "",
      type: 'string',
    },
    {
      name: 'module.provider.linkedin.client_secret',
      desc: "",
      type: 'string',
    },
    {
      name: 'module.provider.linkedin.scopes',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'module.provider.linkedin.email_addresses',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'module.provider.linkedin.email_domains',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'module.options_passthrough',
      desc: "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.",
      type: 'boolean',
    },
    {
      name: 'module.cookie_prefix',
      desc: "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'",
      type: 'string',
    },
    {
      name: 'module.inactivity_timeout',
      desc: "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'module.maximum_duration',
      desc: "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'module.auth_check_interval',
      desc: "Integer number of seconds after which ngrok guarantees it will refresh user state from the identity provider and recheck whether the user is still authorized to access the endpoint. This is the preferred tunable to use to enforce a minimum amount of time after which a revoked user will no longer be able to access the resource.",
      type: 'uint32',
    },
    ],
  EdgeRouteOIDCReplace: [
    {
      name: 'edge_id',
      desc: "",
      type: 'string',
    },
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'module.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'module.options_passthrough',
      desc: "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.",
      type: 'boolean',
    },
    {
      name: 'module.cookie_prefix',
      desc: "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'",
      type: 'string',
    },
    {
      name: 'module.inactivity_timeout',
      desc: "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'module.maximum_duration',
      desc: "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'module.issuer',
      desc: "URL of the OIDC \"OpenID provider\". This is the base URL used for discovery.",
      type: 'string',
    },
    {
      name: 'module.client_id',
      desc: "The OIDC app's client ID and OIDC audience.",
      type: 'string',
    },
    {
      name: 'module.client_secret',
      desc: "The OIDC app's client secret.",
      type: 'string',
    },
    {
      name: 'module.scopes',
      desc: "The set of scopes to request from the OIDC identity provider.",
      type: 'List<string>',
    },
    ],
  EdgeRouteRequestHeadersReplace: [
    {
      name: 'edge_id',
      desc: "",
      type: 'string',
    },
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'module.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'module.add',
      desc: "a map of header key to header value that will be injected into the HTTP Request before being sent to the upstream application server",
      type: 'Map<string, string>',
    },
    {
      name: 'module.remove',
      desc: "a list of header names that will be removed from the HTTP Request before being sent to the upstream application server",
      type: 'List<string>',
    },
    ],
  EdgeRouteResponseHeadersReplace: [
    {
      name: 'edge_id',
      desc: "",
      type: 'string',
    },
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'module.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'module.add',
      desc: "a map of header key to header value that will be injected into the HTTP Response returned to the HTTP client",
      type: 'Map<string, string>',
    },
    {
      name: 'module.remove',
      desc: "a list of header names that will be removed from the HTTP Response returned to the HTTP client",
      type: 'List<string>',
    },
    ],
  EdgeRouteSAMLReplace: [
    {
      name: 'edge_id',
      desc: "",
      type: 'string',
    },
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'module.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'module.options_passthrough',
      desc: "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.",
      type: 'boolean',
    },
    {
      name: 'module.cookie_prefix',
      desc: "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'",
      type: 'string',
    },
    {
      name: 'module.inactivity_timeout',
      desc: "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'module.maximum_duration',
      desc: "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'module.idp_metadata',
      desc: "The full XML IdP EntityDescriptor. Your IdP may provide this to you as a a file to download or as a URL.",
      type: 'string',
    },
    {
      name: 'module.force_authn',
      desc: "If true, indicates that whenever we redirect a user to the IdP for authentication that the IdP must prompt the user for authentication credentials even if the user already has a valid session with the IdP.",
      type: 'boolean',
    },
    {
      name: 'module.allow_idp_initiated',
      desc: "If true, the IdP may initiate a login directly (e.g. the user does not need to visit the endpoint first and then be redirected). The IdP should set the `RelayState` parameter to the target URL of the resource they want the user to be redirected to after the SAML login assertion has been processed.",
      type: 'boolean',
    },
    {
      name: 'module.authorized_groups',
      desc: "If present, only users who are a member of one of the listed groups may access the target endpoint.",
      type: 'List<string>',
    },
    {
      name: 'module.nameid_format',
      desc: "Defines the name identifier format the SP expects the IdP to use in its assertions to identify subjects. If unspecified, a default value of `urn:oasis:names:tc:SAML:2.0:nameid-format:persistent` will be used. A subset of the allowed values enumerated by the SAML specification are supported.",
      type: 'string',
    },
    ],
  EdgeRouteWebhookVerificationReplace: [
    {
      name: 'edge_id',
      desc: "",
      type: 'string',
    },
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'module.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'module.provider',
      desc: "a string indicating which webhook provider will be sending webhooks to this endpoint. Value must be one of the supported providers defined at https://ngrok.com/docs/cloud-edge#webhook-verification",
      type: 'string',
    },
    {
      name: 'module.secret',
      desc: "a string secret used to validate requests from the given provider. All providers except AWS SNS require a secret",
      type: 'string',
    },
    ],
  EdgeRouteWebsocketTCPConverterReplace: [
    {
      name: 'edge_id',
      desc: "",
      type: 'string',
    },
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'module.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    ],
  EdgeTLSTerminationAtEdgeReplace: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'module.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'module.min_version',
      desc: "The minimum TLS version used for termination and advertised to the client during the TLS handshake. if unspecified, ngrok will choose an industry-safe default. This value must be null if `terminate_at` is set to `upstream`.",
      type: 'string',
    },
    ],
  EdgeTLSTerminationReplace: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'module.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'module.terminate_at',
      desc: "`edge` if the ngrok edge should terminate TLS traffic, `upstream` if TLS traffic should be passed through to the upstream ngrok agent / application server for termination. if `upstream` is chosen, most other modules will be disallowed because they rely on the ngrok edge being able to access the underlying traffic.",
      type: 'string',
    },
    {
      name: 'module.min_version',
      desc: "The minimum TLS version used for termination and advertised to the client during the TLS handshake. if unspecified, ngrok will choose an industry-safe default. This value must be null if `terminate_at` is set to `upstream`.",
      type: 'string',
    },
    ],
  Endpoint: [
    {
      name: 'id',
      desc: "unique endpoint resource identifier",
      type: 'string',
    },
    {
      name: 'region',
      desc: "identifier of the region this endpoint belongs to",
      type: 'string',
    },
    {
      name: 'created_at',
      desc: "timestamp when the endpoint was created in RFC 3339 format",
      type: 'string',
    },
    {
      name: 'updated_at',
      desc: "timestamp when the endpoint was updated in RFC 3339 format",
      type: 'string',
    },
    {
      name: 'public_url',
      desc: "URL of the hostport served by this endpoint",
      type: 'string',
    },
    {
      name: 'proto',
      desc: "protocol served by this endpoint. one of `http`, `https`, `tcp`, or `tls`",
      type: 'string',
    },
    {
      name: 'hostport',
      desc: "hostport served by this endpoint (hostname:port)",
      type: 'string',
    },
    {
      name: 'type',
      desc: "whether the endpoint is `ephemeral` (served directly by an agent-initiated tunnel) or `edge` (served by an edge)",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "user-supplied metadata of the associated tunnel or edge object",
      type: 'string',
    },
    {
      name: 'domain.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'domain.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'tcp_addr.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'tcp_addr.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'tunnel.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'tunnel.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'edge.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'edge.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    ],
  EndpointBackend: [
    {
      name: 'enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'backend.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'backend.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    ],
  EndpointBackendMutate: [
    {
      name: 'enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'backend_id',
      desc: "backend to be used to back this endpoint",
      type: 'string',
    },
    ],
  EndpointBackendReplace: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'module.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'module.backend_id',
      desc: "backend to be used to back this endpoint",
      type: 'string',
    },
    ],
  EndpointBasicAuth: [
    {
      name: 'enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'auth_provider_id',
      desc: "determines how the basic auth credentials are validated. Currently only the value `agent` is supported which means that credentials will be validated against the username and password specified by the ngrok agent's `--basic-auth` flag, if any.",
      type: 'string',
    },
    {
      name: 'realm',
      desc: "an arbitrary string to be specified in as the 'realm' value in the `WWW-Authenticate` header. default is `ngrok`",
      type: 'string',
    },
    {
      name: 'allow_options',
      desc: "true or false indicating whether to allow OPTIONS requests through without authentication which is necessary for CORS. default is `false`",
      type: 'boolean',
    },
    ],
  EndpointBasicAuthReplace: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'module.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'module.auth_provider_id',
      desc: "determines how the basic auth credentials are validated. Currently only the value `agent` is supported which means that credentials will be validated against the username and password specified by the ngrok agent's `--basic-auth` flag, if any.",
      type: 'string',
    },
    {
      name: 'module.realm',
      desc: "an arbitrary string to be specified in as the 'realm' value in the `WWW-Authenticate` header. default is `ngrok`",
      type: 'string',
    },
    {
      name: 'module.allow_options',
      desc: "true or false indicating whether to allow OPTIONS requests through without authentication which is necessary for CORS. default is `false`",
      type: 'boolean',
    },
    ],
  EndpointCircuitBreaker: [
    {
      name: 'enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'tripped_duration',
      desc: "Integer number of seconds after which the circuit is tripped to wait before re-evaluating upstream health",
      type: 'uint32',
    },
    {
      name: 'rolling_window',
      desc: "Integer number of seconds in the statistical rolling window that metrics are retained for.",
      type: 'uint32',
    },
    {
      name: 'num_buckets',
      desc: "Integer number of buckets into which metrics are retained. Max 128.",
      type: 'uint32',
    },
    {
      name: 'volume_threshold',
      desc: "Integer number of requests in a rolling window that will trip the circuit. Helpful if traffic volume is low.",
      type: 'uint32',
    },
    {
      name: 'error_threshold_percentage',
      desc: "Error threshold percentage should be between 0 - 1.0, not 0-100.0",
      type: 'float64',
    },
    ],
  EndpointCircuitBreakerReplace: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'module.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'module.tripped_duration',
      desc: "Integer number of seconds after which the circuit is tripped to wait before re-evaluating upstream health",
      type: 'uint32',
    },
    {
      name: 'module.rolling_window',
      desc: "Integer number of seconds in the statistical rolling window that metrics are retained for.",
      type: 'uint32',
    },
    {
      name: 'module.num_buckets',
      desc: "Integer number of buckets into which metrics are retained. Max 128.",
      type: 'uint32',
    },
    {
      name: 'module.volume_threshold',
      desc: "Integer number of requests in a rolling window that will trip the circuit. Helpful if traffic volume is low.",
      type: 'uint32',
    },
    {
      name: 'module.error_threshold_percentage',
      desc: "Error threshold percentage should be between 0 - 1.0, not 0-100.0",
      type: 'float64',
    },
    ],
  EndpointCompression: [
    {
      name: 'enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    ],
  EndpointCompressionReplace: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'module.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    ],
  EndpointConfiguration: [
    {
      name: 'id',
      desc: "unique identifier of this endpoint configuration",
      type: 'string',
    },
    {
      name: 'type',
      desc: "they type of traffic this endpoint configuration can be applied to. one of: `http`, `https`, `tcp`",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of what this endpoint configuration will be do when applied or what traffic it will be applied to. Optional, max 255 bytes",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this endpoint configuration. Optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'created_at',
      desc: "timestamp when the endpoint configuration was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the endpoint configuration API resource",
      type: 'string',
    },
    {
      name: 'circuit_breaker.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'circuit_breaker.tripped_duration',
      desc: "Integer number of seconds after which the circuit is tripped to wait before re-evaluating upstream health",
      type: 'uint32',
    },
    {
      name: 'circuit_breaker.rolling_window',
      desc: "Integer number of seconds in the statistical rolling window that metrics are retained for.",
      type: 'uint32',
    },
    {
      name: 'circuit_breaker.num_buckets',
      desc: "Integer number of buckets into which metrics are retained. Max 128.",
      type: 'uint32',
    },
    {
      name: 'circuit_breaker.volume_threshold',
      desc: "Integer number of requests in a rolling window that will trip the circuit. Helpful if traffic volume is low.",
      type: 'uint32',
    },
    {
      name: 'circuit_breaker.error_threshold_percentage',
      desc: "Error threshold percentage should be between 0 - 1.0, not 0-100.0",
      type: 'float64',
    },
    {
      name: 'compression.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'request_headers.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'request_headers.add',
      desc: "a map of header key to header value that will be injected into the HTTP Request before being sent to the upstream application server",
      type: 'Map<string, string>',
    },
    {
      name: 'request_headers.remove',
      desc: "a list of header names that will be removed from the HTTP Request before being sent to the upstream application server",
      type: 'List<string>',
    },
    {
      name: 'response_headers.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'response_headers.add',
      desc: "a map of header key to header value that will be injected into the HTTP Response returned to the HTTP client",
      type: 'Map<string, string>',
    },
    {
      name: 'response_headers.remove',
      desc: "a list of header names that will be removed from the HTTP Response returned to the HTTP client",
      type: 'List<string>',
    },
    {
      name: 'ip_policy.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'ip_policy.ip_policies.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'ip_policy.ip_policies.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'mutual_tls.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'mutual_tls.certificate_authorities.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'mutual_tls.certificate_authorities.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'tls_termination.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'tls_termination.terminate_at',
      desc: "`edge` if the ngrok edge should terminate TLS traffic, `upstream` if TLS traffic should be passed through to the upstream ngrok agent / application server for termination. if `upstream` is chosen, most other modules will be disallowed because they rely on the ngrok edge being able to access the underlying traffic.",
      type: 'string',
    },
    {
      name: 'tls_termination.min_version',
      desc: "The minimum TLS version used for termination and advertised to the client during the TLS handshake. if unspecified, ngrok will choose an industry-safe default. This value must be null if `terminate_at` is set to `upstream`.",
      type: 'string',
    },
    {
      name: 'webhook_validation.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'webhook_validation.provider',
      desc: "a string indicating which webhook provider will be sending webhooks to this endpoint. Value must be one of the supported providers defined at https://ngrok.com/docs/cloud-edge#webhook-verification",
      type: 'string',
    },
    {
      name: 'webhook_validation.secret',
      desc: "a string secret used to validate requests from the given provider. All providers except AWS SNS require a secret",
      type: 'string',
    },
    {
      name: 'oauth.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'oauth.provider.github.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'oauth.provider.github.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'oauth.provider.github.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.github.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.github.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.github.teams',
      desc: "a list of github teams identifiers. users will be allowed access to the endpoint if they are a member of any of these teams. identifiers should be in the 'slug' format qualified with the org name, e.g. `org-name/team-name`",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.github.organizations',
      desc: "a list of github org identifiers. users who are members of any of the listed organizations will be allowed access. identifiers should be the organization's 'slug'",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.facebook.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'oauth.provider.facebook.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'oauth.provider.facebook.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.facebook.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.facebook.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.microsoft.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'oauth.provider.microsoft.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'oauth.provider.microsoft.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.microsoft.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.microsoft.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.google.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'oauth.provider.google.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'oauth.provider.google.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.google.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.google.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.linkedin.client_id',
      desc: "",
      type: 'string',
    },
    {
      name: 'oauth.provider.linkedin.client_secret',
      desc: "",
      type: 'string',
    },
    {
      name: 'oauth.provider.linkedin.scopes',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.linkedin.email_addresses',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.linkedin.email_domains',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'oauth.options_passthrough',
      desc: "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.",
      type: 'boolean',
    },
    {
      name: 'oauth.cookie_prefix',
      desc: "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'",
      type: 'string',
    },
    {
      name: 'oauth.inactivity_timeout',
      desc: "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'oauth.maximum_duration',
      desc: "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'oauth.auth_check_interval',
      desc: "Integer number of seconds after which ngrok guarantees it will refresh user state from the identity provider and recheck whether the user is still authorized to access the endpoint. This is the preferred tunable to use to enforce a minimum amount of time after which a revoked user will no longer be able to access the resource.",
      type: 'uint32',
    },
    {
      name: 'saml.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'saml.options_passthrough',
      desc: "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.",
      type: 'boolean',
    },
    {
      name: 'saml.cookie_prefix',
      desc: "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'",
      type: 'string',
    },
    {
      name: 'saml.inactivity_timeout',
      desc: "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'saml.maximum_duration',
      desc: "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'saml.idp_metadata',
      desc: "The full XML IdP EntityDescriptor. Your IdP may provide this to you as a a file to download or as a URL.",
      type: 'string',
    },
    {
      name: 'saml.force_authn',
      desc: "If true, indicates that whenever we redirect a user to the IdP for authentication that the IdP must prompt the user for authentication credentials even if the user already has a valid session with the IdP.",
      type: 'boolean',
    },
    {
      name: 'saml.allow_idp_initiated',
      desc: "If true, the IdP may initiate a login directly (e.g. the user does not need to visit the endpoint first and then be redirected). The IdP should set the `RelayState` parameter to the target URL of the resource they want the user to be redirected to after the SAML login assertion has been processed.",
      type: 'boolean',
    },
    {
      name: 'saml.authorized_groups',
      desc: "If present, only users who are a member of one of the listed groups may access the target endpoint.",
      type: 'List<string>',
    },
    {
      name: 'saml.entity_id',
      desc: "The SP Entity's unique ID. This always takes the form of a URL. In ngrok's implementation, this URL is the same as the metadata URL. This will need to be specified to the IdP as configuration.",
      type: 'string',
    },
    {
      name: 'saml.assertion_consumer_service_url',
      desc: "The public URL of the SP's Assertion Consumer Service. This is where the IdP will redirect to during an authentication flow. This will need to be specified to the IdP as configuration.",
      type: 'string',
    },
    {
      name: 'saml.single_logout_url',
      desc: "The public URL of the SP's Single Logout Service. This is where the IdP will redirect to during a single logout flow. This will optionally need to be specified to the IdP as configuration.",
      type: 'string',
    },
    {
      name: 'saml.request_signing_certificate_pem',
      desc: "PEM-encoded x.509 certificate of the key pair that is used to sign all SAML requests that the ngrok SP makes to the IdP. Many IdPs do not support request signing verification, but we highly recommend specifying this in the IdP's configuration if it is supported.",
      type: 'string',
    },
    {
      name: 'saml.metadata_url',
      desc: "A public URL where the SP's metadata is hosted. If an IdP supports dynamic configuration, this is the URL it can use to retrieve the SP metadata.",
      type: 'string',
    },
    {
      name: 'saml.nameid_format',
      desc: "Defines the name identifier format the SP expects the IdP to use in its assertions to identify subjects. If unspecified, a default value of `urn:oasis:names:tc:SAML:2.0:nameid-format:persistent` will be used. A subset of the allowed values enumerated by the SAML specification are supported.",
      type: 'string',
    },
    {
      name: 'oidc.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'oidc.options_passthrough',
      desc: "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.",
      type: 'boolean',
    },
    {
      name: 'oidc.cookie_prefix',
      desc: "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'",
      type: 'string',
    },
    {
      name: 'oidc.inactivity_timeout',
      desc: "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'oidc.maximum_duration',
      desc: "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'oidc.issuer',
      desc: "URL of the OIDC \"OpenID provider\". This is the base URL used for discovery.",
      type: 'string',
    },
    {
      name: 'oidc.client_id',
      desc: "The OIDC app's client ID and OIDC audience.",
      type: 'string',
    },
    {
      name: 'oidc.client_secret',
      desc: "The OIDC app's client secret.",
      type: 'string',
    },
    {
      name: 'oidc.scopes',
      desc: "The set of scopes to request from the OIDC identity provider.",
      type: 'List<string>',
    },
    ],
  EndpointConfigurationCreate: [
    {
      name: 'type',
      desc: "they type of traffic this endpoint configuration can be applied to. one of: `http`, `https`, `tcp`",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of what this endpoint configuration will be do when applied or what traffic it will be applied to. Optional, max 255 bytes",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this endpoint configuration. Optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'circuit_breaker.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'circuit_breaker.tripped_duration',
      desc: "Integer number of seconds after which the circuit is tripped to wait before re-evaluating upstream health",
      type: 'uint32',
    },
    {
      name: 'circuit_breaker.rolling_window',
      desc: "Integer number of seconds in the statistical rolling window that metrics are retained for.",
      type: 'uint32',
    },
    {
      name: 'circuit_breaker.num_buckets',
      desc: "Integer number of buckets into which metrics are retained. Max 128.",
      type: 'uint32',
    },
    {
      name: 'circuit_breaker.volume_threshold',
      desc: "Integer number of requests in a rolling window that will trip the circuit. Helpful if traffic volume is low.",
      type: 'uint32',
    },
    {
      name: 'circuit_breaker.error_threshold_percentage',
      desc: "Error threshold percentage should be between 0 - 1.0, not 0-100.0",
      type: 'float64',
    },
    {
      name: 'compression.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'request_headers.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'request_headers.add',
      desc: "a map of header key to header value that will be injected into the HTTP Request before being sent to the upstream application server",
      type: 'Map<string, string>',
    },
    {
      name: 'request_headers.remove',
      desc: "a list of header names that will be removed from the HTTP Request before being sent to the upstream application server",
      type: 'List<string>',
    },
    {
      name: 'response_headers.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'response_headers.add',
      desc: "a map of header key to header value that will be injected into the HTTP Response returned to the HTTP client",
      type: 'Map<string, string>',
    },
    {
      name: 'response_headers.remove',
      desc: "a list of header names that will be removed from the HTTP Response returned to the HTTP client",
      type: 'List<string>',
    },
    {
      name: 'ip_policy.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'ip_policy.ip_policy_ids',
      desc: "list of all IP policies that will be used to check if a source IP is allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'mutual_tls.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'mutual_tls.certificate_authority_ids',
      desc: "list of certificate authorities that will be used to validate the TLS client certificate presented by the initiator of the TLS connection",
      type: 'List<string>',
    },
    {
      name: 'tls_termination.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'tls_termination.terminate_at',
      desc: "`edge` if the ngrok edge should terminate TLS traffic, `upstream` if TLS traffic should be passed through to the upstream ngrok agent / application server for termination. if `upstream` is chosen, most other modules will be disallowed because they rely on the ngrok edge being able to access the underlying traffic.",
      type: 'string',
    },
    {
      name: 'tls_termination.min_version',
      desc: "The minimum TLS version used for termination and advertised to the client during the TLS handshake. if unspecified, ngrok will choose an industry-safe default. This value must be null if `terminate_at` is set to `upstream`.",
      type: 'string',
    },
    {
      name: 'webhook_validation.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'webhook_validation.provider',
      desc: "a string indicating which webhook provider will be sending webhooks to this endpoint. Value must be one of the supported providers defined at https://ngrok.com/docs/cloud-edge#webhook-verification",
      type: 'string',
    },
    {
      name: 'webhook_validation.secret',
      desc: "a string secret used to validate requests from the given provider. All providers except AWS SNS require a secret",
      type: 'string',
    },
    {
      name: 'oauth.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'oauth.provider.github.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'oauth.provider.github.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'oauth.provider.github.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.github.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.github.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.github.teams',
      desc: "a list of github teams identifiers. users will be allowed access to the endpoint if they are a member of any of these teams. identifiers should be in the 'slug' format qualified with the org name, e.g. `org-name/team-name`",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.github.organizations',
      desc: "a list of github org identifiers. users who are members of any of the listed organizations will be allowed access. identifiers should be the organization's 'slug'",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.facebook.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'oauth.provider.facebook.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'oauth.provider.facebook.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.facebook.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.facebook.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.microsoft.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'oauth.provider.microsoft.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'oauth.provider.microsoft.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.microsoft.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.microsoft.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.google.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'oauth.provider.google.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'oauth.provider.google.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.google.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.google.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.linkedin.client_id',
      desc: "",
      type: 'string',
    },
    {
      name: 'oauth.provider.linkedin.client_secret',
      desc: "",
      type: 'string',
    },
    {
      name: 'oauth.provider.linkedin.scopes',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.linkedin.email_addresses',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.linkedin.email_domains',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'oauth.options_passthrough',
      desc: "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.",
      type: 'boolean',
    },
    {
      name: 'oauth.cookie_prefix',
      desc: "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'",
      type: 'string',
    },
    {
      name: 'oauth.inactivity_timeout',
      desc: "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'oauth.maximum_duration',
      desc: "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'oauth.auth_check_interval',
      desc: "Integer number of seconds after which ngrok guarantees it will refresh user state from the identity provider and recheck whether the user is still authorized to access the endpoint. This is the preferred tunable to use to enforce a minimum amount of time after which a revoked user will no longer be able to access the resource.",
      type: 'uint32',
    },
    {
      name: 'saml.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'saml.options_passthrough',
      desc: "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.",
      type: 'boolean',
    },
    {
      name: 'saml.cookie_prefix',
      desc: "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'",
      type: 'string',
    },
    {
      name: 'saml.inactivity_timeout',
      desc: "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'saml.maximum_duration',
      desc: "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'saml.idp_metadata',
      desc: "The full XML IdP EntityDescriptor. Your IdP may provide this to you as a a file to download or as a URL.",
      type: 'string',
    },
    {
      name: 'saml.force_authn',
      desc: "If true, indicates that whenever we redirect a user to the IdP for authentication that the IdP must prompt the user for authentication credentials even if the user already has a valid session with the IdP.",
      type: 'boolean',
    },
    {
      name: 'saml.allow_idp_initiated',
      desc: "If true, the IdP may initiate a login directly (e.g. the user does not need to visit the endpoint first and then be redirected). The IdP should set the `RelayState` parameter to the target URL of the resource they want the user to be redirected to after the SAML login assertion has been processed.",
      type: 'boolean',
    },
    {
      name: 'saml.authorized_groups',
      desc: "If present, only users who are a member of one of the listed groups may access the target endpoint.",
      type: 'List<string>',
    },
    {
      name: 'saml.nameid_format',
      desc: "Defines the name identifier format the SP expects the IdP to use in its assertions to identify subjects. If unspecified, a default value of `urn:oasis:names:tc:SAML:2.0:nameid-format:persistent` will be used. A subset of the allowed values enumerated by the SAML specification are supported.",
      type: 'string',
    },
    {
      name: 'oidc.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'oidc.options_passthrough',
      desc: "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.",
      type: 'boolean',
    },
    {
      name: 'oidc.cookie_prefix',
      desc: "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'",
      type: 'string',
    },
    {
      name: 'oidc.inactivity_timeout',
      desc: "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'oidc.maximum_duration',
      desc: "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'oidc.issuer',
      desc: "URL of the OIDC \"OpenID provider\". This is the base URL used for discovery.",
      type: 'string',
    },
    {
      name: 'oidc.client_id',
      desc: "The OIDC app's client ID and OIDC audience.",
      type: 'string',
    },
    {
      name: 'oidc.client_secret',
      desc: "The OIDC app's client secret.",
      type: 'string',
    },
    {
      name: 'oidc.scopes',
      desc: "The set of scopes to request from the OIDC identity provider.",
      type: 'List<string>',
    },
    {
      name: 'backend.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'backend.backend_id',
      desc: "backend to be used to back this endpoint",
      type: 'string',
    },
    ],
  EndpointConfigurationList: [
    {
      name: 'endpoint_configurations.id',
      desc: "unique identifier of this endpoint configuration",
      type: 'string',
    },
    {
      name: 'endpoint_configurations.type',
      desc: "they type of traffic this endpoint configuration can be applied to. one of: `http`, `https`, `tcp`",
      type: 'string',
    },
    {
      name: 'endpoint_configurations.description',
      desc: "human-readable description of what this endpoint configuration will be do when applied or what traffic it will be applied to. Optional, max 255 bytes",
      type: 'string',
    },
    {
      name: 'endpoint_configurations.metadata',
      desc: "arbitrary user-defined machine-readable data of this endpoint configuration. Optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'endpoint_configurations.created_at',
      desc: "timestamp when the endpoint configuration was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'endpoint_configurations.uri',
      desc: "URI of the endpoint configuration API resource",
      type: 'string',
    },
    {
      name: 'endpoint_configurations.circuit_breaker.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'endpoint_configurations.circuit_breaker.tripped_duration',
      desc: "Integer number of seconds after which the circuit is tripped to wait before re-evaluating upstream health",
      type: 'uint32',
    },
    {
      name: 'endpoint_configurations.circuit_breaker.rolling_window',
      desc: "Integer number of seconds in the statistical rolling window that metrics are retained for.",
      type: 'uint32',
    },
    {
      name: 'endpoint_configurations.circuit_breaker.num_buckets',
      desc: "Integer number of buckets into which metrics are retained. Max 128.",
      type: 'uint32',
    },
    {
      name: 'endpoint_configurations.circuit_breaker.volume_threshold',
      desc: "Integer number of requests in a rolling window that will trip the circuit. Helpful if traffic volume is low.",
      type: 'uint32',
    },
    {
      name: 'endpoint_configurations.circuit_breaker.error_threshold_percentage',
      desc: "Error threshold percentage should be between 0 - 1.0, not 0-100.0",
      type: 'float64',
    },
    {
      name: 'endpoint_configurations.compression.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'endpoint_configurations.request_headers.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'endpoint_configurations.request_headers.add',
      desc: "a map of header key to header value that will be injected into the HTTP Request before being sent to the upstream application server",
      type: 'Map<string, string>',
    },
    {
      name: 'endpoint_configurations.request_headers.remove',
      desc: "a list of header names that will be removed from the HTTP Request before being sent to the upstream application server",
      type: 'List<string>',
    },
    {
      name: 'endpoint_configurations.response_headers.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'endpoint_configurations.response_headers.add',
      desc: "a map of header key to header value that will be injected into the HTTP Response returned to the HTTP client",
      type: 'Map<string, string>',
    },
    {
      name: 'endpoint_configurations.response_headers.remove',
      desc: "a list of header names that will be removed from the HTTP Response returned to the HTTP client",
      type: 'List<string>',
    },
    {
      name: 'endpoint_configurations.ip_policy.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'endpoint_configurations.ip_policy.ip_policies.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'endpoint_configurations.ip_policy.ip_policies.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'endpoint_configurations.mutual_tls.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'endpoint_configurations.mutual_tls.certificate_authorities.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'endpoint_configurations.mutual_tls.certificate_authorities.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'endpoint_configurations.tls_termination.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'endpoint_configurations.tls_termination.terminate_at',
      desc: "`edge` if the ngrok edge should terminate TLS traffic, `upstream` if TLS traffic should be passed through to the upstream ngrok agent / application server for termination. if `upstream` is chosen, most other modules will be disallowed because they rely on the ngrok edge being able to access the underlying traffic.",
      type: 'string',
    },
    {
      name: 'endpoint_configurations.tls_termination.min_version',
      desc: "The minimum TLS version used for termination and advertised to the client during the TLS handshake. if unspecified, ngrok will choose an industry-safe default. This value must be null if `terminate_at` is set to `upstream`.",
      type: 'string',
    },
    {
      name: 'endpoint_configurations.webhook_validation.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'endpoint_configurations.webhook_validation.provider',
      desc: "a string indicating which webhook provider will be sending webhooks to this endpoint. Value must be one of the supported providers defined at https://ngrok.com/docs/cloud-edge#webhook-verification",
      type: 'string',
    },
    {
      name: 'endpoint_configurations.webhook_validation.secret',
      desc: "a string secret used to validate requests from the given provider. All providers except AWS SNS require a secret",
      type: 'string',
    },
    {
      name: 'endpoint_configurations.oauth.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'endpoint_configurations.oauth.provider.github.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'endpoint_configurations.oauth.provider.github.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'endpoint_configurations.oauth.provider.github.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'endpoint_configurations.oauth.provider.github.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'endpoint_configurations.oauth.provider.github.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'endpoint_configurations.oauth.provider.github.teams',
      desc: "a list of github teams identifiers. users will be allowed access to the endpoint if they are a member of any of these teams. identifiers should be in the 'slug' format qualified with the org name, e.g. `org-name/team-name`",
      type: 'List<string>',
    },
    {
      name: 'endpoint_configurations.oauth.provider.github.organizations',
      desc: "a list of github org identifiers. users who are members of any of the listed organizations will be allowed access. identifiers should be the organization's 'slug'",
      type: 'List<string>',
    },
    {
      name: 'endpoint_configurations.oauth.provider.facebook.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'endpoint_configurations.oauth.provider.facebook.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'endpoint_configurations.oauth.provider.facebook.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'endpoint_configurations.oauth.provider.facebook.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'endpoint_configurations.oauth.provider.facebook.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'endpoint_configurations.oauth.provider.microsoft.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'endpoint_configurations.oauth.provider.microsoft.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'endpoint_configurations.oauth.provider.microsoft.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'endpoint_configurations.oauth.provider.microsoft.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'endpoint_configurations.oauth.provider.microsoft.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'endpoint_configurations.oauth.provider.google.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'endpoint_configurations.oauth.provider.google.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'endpoint_configurations.oauth.provider.google.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'endpoint_configurations.oauth.provider.google.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'endpoint_configurations.oauth.provider.google.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'endpoint_configurations.oauth.provider.linkedin.client_id',
      desc: "",
      type: 'string',
    },
    {
      name: 'endpoint_configurations.oauth.provider.linkedin.client_secret',
      desc: "",
      type: 'string',
    },
    {
      name: 'endpoint_configurations.oauth.provider.linkedin.scopes',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'endpoint_configurations.oauth.provider.linkedin.email_addresses',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'endpoint_configurations.oauth.provider.linkedin.email_domains',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'endpoint_configurations.oauth.options_passthrough',
      desc: "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.",
      type: 'boolean',
    },
    {
      name: 'endpoint_configurations.oauth.cookie_prefix',
      desc: "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'",
      type: 'string',
    },
    {
      name: 'endpoint_configurations.oauth.inactivity_timeout',
      desc: "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'endpoint_configurations.oauth.maximum_duration',
      desc: "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'endpoint_configurations.oauth.auth_check_interval',
      desc: "Integer number of seconds after which ngrok guarantees it will refresh user state from the identity provider and recheck whether the user is still authorized to access the endpoint. This is the preferred tunable to use to enforce a minimum amount of time after which a revoked user will no longer be able to access the resource.",
      type: 'uint32',
    },
    {
      name: 'endpoint_configurations.saml.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'endpoint_configurations.saml.options_passthrough',
      desc: "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.",
      type: 'boolean',
    },
    {
      name: 'endpoint_configurations.saml.cookie_prefix',
      desc: "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'",
      type: 'string',
    },
    {
      name: 'endpoint_configurations.saml.inactivity_timeout',
      desc: "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'endpoint_configurations.saml.maximum_duration',
      desc: "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'endpoint_configurations.saml.idp_metadata',
      desc: "The full XML IdP EntityDescriptor. Your IdP may provide this to you as a a file to download or as a URL.",
      type: 'string',
    },
    {
      name: 'endpoint_configurations.saml.force_authn',
      desc: "If true, indicates that whenever we redirect a user to the IdP for authentication that the IdP must prompt the user for authentication credentials even if the user already has a valid session with the IdP.",
      type: 'boolean',
    },
    {
      name: 'endpoint_configurations.saml.allow_idp_initiated',
      desc: "If true, the IdP may initiate a login directly (e.g. the user does not need to visit the endpoint first and then be redirected). The IdP should set the `RelayState` parameter to the target URL of the resource they want the user to be redirected to after the SAML login assertion has been processed.",
      type: 'boolean',
    },
    {
      name: 'endpoint_configurations.saml.authorized_groups',
      desc: "If present, only users who are a member of one of the listed groups may access the target endpoint.",
      type: 'List<string>',
    },
    {
      name: 'endpoint_configurations.saml.entity_id',
      desc: "The SP Entity's unique ID. This always takes the form of a URL. In ngrok's implementation, this URL is the same as the metadata URL. This will need to be specified to the IdP as configuration.",
      type: 'string',
    },
    {
      name: 'endpoint_configurations.saml.assertion_consumer_service_url',
      desc: "The public URL of the SP's Assertion Consumer Service. This is where the IdP will redirect to during an authentication flow. This will need to be specified to the IdP as configuration.",
      type: 'string',
    },
    {
      name: 'endpoint_configurations.saml.single_logout_url',
      desc: "The public URL of the SP's Single Logout Service. This is where the IdP will redirect to during a single logout flow. This will optionally need to be specified to the IdP as configuration.",
      type: 'string',
    },
    {
      name: 'endpoint_configurations.saml.request_signing_certificate_pem',
      desc: "PEM-encoded x.509 certificate of the key pair that is used to sign all SAML requests that the ngrok SP makes to the IdP. Many IdPs do not support request signing verification, but we highly recommend specifying this in the IdP's configuration if it is supported.",
      type: 'string',
    },
    {
      name: 'endpoint_configurations.saml.metadata_url',
      desc: "A public URL where the SP's metadata is hosted. If an IdP supports dynamic configuration, this is the URL it can use to retrieve the SP metadata.",
      type: 'string',
    },
    {
      name: 'endpoint_configurations.saml.nameid_format',
      desc: "Defines the name identifier format the SP expects the IdP to use in its assertions to identify subjects. If unspecified, a default value of `urn:oasis:names:tc:SAML:2.0:nameid-format:persistent` will be used. A subset of the allowed values enumerated by the SAML specification are supported.",
      type: 'string',
    },
    {
      name: 'endpoint_configurations.oidc.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'endpoint_configurations.oidc.options_passthrough',
      desc: "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.",
      type: 'boolean',
    },
    {
      name: 'endpoint_configurations.oidc.cookie_prefix',
      desc: "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'",
      type: 'string',
    },
    {
      name: 'endpoint_configurations.oidc.inactivity_timeout',
      desc: "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'endpoint_configurations.oidc.maximum_duration',
      desc: "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'endpoint_configurations.oidc.issuer',
      desc: "URL of the OIDC \"OpenID provider\". This is the base URL used for discovery.",
      type: 'string',
    },
    {
      name: 'endpoint_configurations.oidc.client_id',
      desc: "The OIDC app's client ID and OIDC audience.",
      type: 'string',
    },
    {
      name: 'endpoint_configurations.oidc.client_secret',
      desc: "The OIDC app's client secret.",
      type: 'string',
    },
    {
      name: 'endpoint_configurations.oidc.scopes',
      desc: "The set of scopes to request from the OIDC identity provider.",
      type: 'List<string>',
    },
    {
      name: 'uri',
      desc: "URI of the endpoint configurations list API resource",
      type: 'string',
    },
    {
      name: 'next_page_uri',
      desc: "URI of the next page, or null if there is no next page",
      type: 'string',
    },
    ],
  EndpointConfigurationUpdate: [
    {
      name: 'id',
      desc: "unique identifier of this endpoint configuration",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of what this endpoint configuration will be do when applied or what traffic it will be applied to. Optional, max 255 bytes",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this endpoint configuration. Optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'circuit_breaker.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'circuit_breaker.tripped_duration',
      desc: "Integer number of seconds after which the circuit is tripped to wait before re-evaluating upstream health",
      type: 'uint32',
    },
    {
      name: 'circuit_breaker.rolling_window',
      desc: "Integer number of seconds in the statistical rolling window that metrics are retained for.",
      type: 'uint32',
    },
    {
      name: 'circuit_breaker.num_buckets',
      desc: "Integer number of buckets into which metrics are retained. Max 128.",
      type: 'uint32',
    },
    {
      name: 'circuit_breaker.volume_threshold',
      desc: "Integer number of requests in a rolling window that will trip the circuit. Helpful if traffic volume is low.",
      type: 'uint32',
    },
    {
      name: 'circuit_breaker.error_threshold_percentage',
      desc: "Error threshold percentage should be between 0 - 1.0, not 0-100.0",
      type: 'float64',
    },
    {
      name: 'compression.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'request_headers.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'request_headers.add',
      desc: "a map of header key to header value that will be injected into the HTTP Request before being sent to the upstream application server",
      type: 'Map<string, string>',
    },
    {
      name: 'request_headers.remove',
      desc: "a list of header names that will be removed from the HTTP Request before being sent to the upstream application server",
      type: 'List<string>',
    },
    {
      name: 'response_headers.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'response_headers.add',
      desc: "a map of header key to header value that will be injected into the HTTP Response returned to the HTTP client",
      type: 'Map<string, string>',
    },
    {
      name: 'response_headers.remove',
      desc: "a list of header names that will be removed from the HTTP Response returned to the HTTP client",
      type: 'List<string>',
    },
    {
      name: 'ip_policy.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'ip_policy.ip_policy_ids',
      desc: "list of all IP policies that will be used to check if a source IP is allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'mutual_tls.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'mutual_tls.certificate_authority_ids',
      desc: "list of certificate authorities that will be used to validate the TLS client certificate presented by the initiator of the TLS connection",
      type: 'List<string>',
    },
    {
      name: 'tls_termination.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'tls_termination.terminate_at',
      desc: "`edge` if the ngrok edge should terminate TLS traffic, `upstream` if TLS traffic should be passed through to the upstream ngrok agent / application server for termination. if `upstream` is chosen, most other modules will be disallowed because they rely on the ngrok edge being able to access the underlying traffic.",
      type: 'string',
    },
    {
      name: 'tls_termination.min_version',
      desc: "The minimum TLS version used for termination and advertised to the client during the TLS handshake. if unspecified, ngrok will choose an industry-safe default. This value must be null if `terminate_at` is set to `upstream`.",
      type: 'string',
    },
    {
      name: 'webhook_validation.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'webhook_validation.provider',
      desc: "a string indicating which webhook provider will be sending webhooks to this endpoint. Value must be one of the supported providers defined at https://ngrok.com/docs/cloud-edge#webhook-verification",
      type: 'string',
    },
    {
      name: 'webhook_validation.secret',
      desc: "a string secret used to validate requests from the given provider. All providers except AWS SNS require a secret",
      type: 'string',
    },
    {
      name: 'oauth.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'oauth.provider.github.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'oauth.provider.github.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'oauth.provider.github.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.github.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.github.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.github.teams',
      desc: "a list of github teams identifiers. users will be allowed access to the endpoint if they are a member of any of these teams. identifiers should be in the 'slug' format qualified with the org name, e.g. `org-name/team-name`",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.github.organizations',
      desc: "a list of github org identifiers. users who are members of any of the listed organizations will be allowed access. identifiers should be the organization's 'slug'",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.facebook.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'oauth.provider.facebook.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'oauth.provider.facebook.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.facebook.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.facebook.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.microsoft.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'oauth.provider.microsoft.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'oauth.provider.microsoft.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.microsoft.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.microsoft.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.google.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'oauth.provider.google.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'oauth.provider.google.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.google.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.google.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.linkedin.client_id',
      desc: "",
      type: 'string',
    },
    {
      name: 'oauth.provider.linkedin.client_secret',
      desc: "",
      type: 'string',
    },
    {
      name: 'oauth.provider.linkedin.scopes',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.linkedin.email_addresses',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.linkedin.email_domains',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'oauth.options_passthrough',
      desc: "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.",
      type: 'boolean',
    },
    {
      name: 'oauth.cookie_prefix',
      desc: "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'",
      type: 'string',
    },
    {
      name: 'oauth.inactivity_timeout',
      desc: "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'oauth.maximum_duration',
      desc: "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'oauth.auth_check_interval',
      desc: "Integer number of seconds after which ngrok guarantees it will refresh user state from the identity provider and recheck whether the user is still authorized to access the endpoint. This is the preferred tunable to use to enforce a minimum amount of time after which a revoked user will no longer be able to access the resource.",
      type: 'uint32',
    },
    {
      name: 'saml.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'saml.options_passthrough',
      desc: "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.",
      type: 'boolean',
    },
    {
      name: 'saml.cookie_prefix',
      desc: "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'",
      type: 'string',
    },
    {
      name: 'saml.inactivity_timeout',
      desc: "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'saml.maximum_duration',
      desc: "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'saml.idp_metadata',
      desc: "The full XML IdP EntityDescriptor. Your IdP may provide this to you as a a file to download or as a URL.",
      type: 'string',
    },
    {
      name: 'saml.force_authn',
      desc: "If true, indicates that whenever we redirect a user to the IdP for authentication that the IdP must prompt the user for authentication credentials even if the user already has a valid session with the IdP.",
      type: 'boolean',
    },
    {
      name: 'saml.allow_idp_initiated',
      desc: "If true, the IdP may initiate a login directly (e.g. the user does not need to visit the endpoint first and then be redirected). The IdP should set the `RelayState` parameter to the target URL of the resource they want the user to be redirected to after the SAML login assertion has been processed.",
      type: 'boolean',
    },
    {
      name: 'saml.authorized_groups',
      desc: "If present, only users who are a member of one of the listed groups may access the target endpoint.",
      type: 'List<string>',
    },
    {
      name: 'saml.nameid_format',
      desc: "Defines the name identifier format the SP expects the IdP to use in its assertions to identify subjects. If unspecified, a default value of `urn:oasis:names:tc:SAML:2.0:nameid-format:persistent` will be used. A subset of the allowed values enumerated by the SAML specification are supported.",
      type: 'string',
    },
    {
      name: 'oidc.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'oidc.options_passthrough',
      desc: "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.",
      type: 'boolean',
    },
    {
      name: 'oidc.cookie_prefix',
      desc: "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'",
      type: 'string',
    },
    {
      name: 'oidc.inactivity_timeout',
      desc: "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'oidc.maximum_duration',
      desc: "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'oidc.issuer',
      desc: "URL of the OIDC \"OpenID provider\". This is the base URL used for discovery.",
      type: 'string',
    },
    {
      name: 'oidc.client_id',
      desc: "The OIDC app's client ID and OIDC audience.",
      type: 'string',
    },
    {
      name: 'oidc.client_secret',
      desc: "The OIDC app's client secret.",
      type: 'string',
    },
    {
      name: 'oidc.scopes',
      desc: "The set of scopes to request from the OIDC identity provider.",
      type: 'List<string>',
    },
    {
      name: 'backend.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'backend.backend_id',
      desc: "backend to be used to back this endpoint",
      type: 'string',
    },
    ],
  EndpointIPPolicy: [
    {
      name: 'enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'ip_policies.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'ip_policies.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    ],
  EndpointIPPolicyMutate: [
    {
      name: 'enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'ip_policy_ids',
      desc: "list of all IP policies that will be used to check if a source IP is allowed access to the endpoint",
      type: 'List<string>',
    },
    ],
  EndpointIPPolicyReplace: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'module.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'module.ip_policy_ids',
      desc: "list of all IP policies that will be used to check if a source IP is allowed access to the endpoint",
      type: 'List<string>',
    },
    ],
  EndpointList: [
    {
      name: 'endpoints.id',
      desc: "unique endpoint resource identifier",
      type: 'string',
    },
    {
      name: 'endpoints.region',
      desc: "identifier of the region this endpoint belongs to",
      type: 'string',
    },
    {
      name: 'endpoints.created_at',
      desc: "timestamp when the endpoint was created in RFC 3339 format",
      type: 'string',
    },
    {
      name: 'endpoints.updated_at',
      desc: "timestamp when the endpoint was updated in RFC 3339 format",
      type: 'string',
    },
    {
      name: 'endpoints.public_url',
      desc: "URL of the hostport served by this endpoint",
      type: 'string',
    },
    {
      name: 'endpoints.proto',
      desc: "protocol served by this endpoint. one of `http`, `https`, `tcp`, or `tls`",
      type: 'string',
    },
    {
      name: 'endpoints.hostport',
      desc: "hostport served by this endpoint (hostname:port)",
      type: 'string',
    },
    {
      name: 'endpoints.type',
      desc: "whether the endpoint is `ephemeral` (served directly by an agent-initiated tunnel) or `edge` (served by an edge)",
      type: 'string',
    },
    {
      name: 'endpoints.metadata',
      desc: "user-supplied metadata of the associated tunnel or edge object",
      type: 'string',
    },
    {
      name: 'endpoints.domain.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'endpoints.domain.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'endpoints.tcp_addr.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'endpoints.tcp_addr.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'endpoints.tunnel.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'endpoints.tunnel.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'endpoints.edge.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'endpoints.edge.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the endpoints list API resource",
      type: 'string',
    },
    {
      name: 'next_page_uri',
      desc: "URI of the next page, or null if there is no next page",
      type: 'string',
    },
    ],
  EndpointMutualTLS: [
    {
      name: 'enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'certificate_authorities.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'certificate_authorities.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    ],
  EndpointMutualTLSMutate: [
    {
      name: 'enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'certificate_authority_ids',
      desc: "list of certificate authorities that will be used to validate the TLS client certificate presented by the initiator of the TLS connection",
      type: 'List<string>',
    },
    ],
  EndpointMutualTLSReplace: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'module.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'module.certificate_authority_ids',
      desc: "list of certificate authorities that will be used to validate the TLS client certificate presented by the initiator of the TLS connection",
      type: 'List<string>',
    },
    ],
  EndpointOAuth: [
    {
      name: 'enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'provider.github.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'provider.github.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'provider.github.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'provider.github.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'provider.github.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'provider.github.teams',
      desc: "a list of github teams identifiers. users will be allowed access to the endpoint if they are a member of any of these teams. identifiers should be in the 'slug' format qualified with the org name, e.g. `org-name/team-name`",
      type: 'List<string>',
    },
    {
      name: 'provider.github.organizations',
      desc: "a list of github org identifiers. users who are members of any of the listed organizations will be allowed access. identifiers should be the organization's 'slug'",
      type: 'List<string>',
    },
    {
      name: 'provider.facebook.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'provider.facebook.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'provider.facebook.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'provider.facebook.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'provider.facebook.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'provider.microsoft.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'provider.microsoft.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'provider.microsoft.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'provider.microsoft.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'provider.microsoft.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'provider.google.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'provider.google.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'provider.google.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'provider.google.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'provider.google.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'provider.linkedin.client_id',
      desc: "",
      type: 'string',
    },
    {
      name: 'provider.linkedin.client_secret',
      desc: "",
      type: 'string',
    },
    {
      name: 'provider.linkedin.scopes',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'provider.linkedin.email_addresses',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'provider.linkedin.email_domains',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'options_passthrough',
      desc: "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.",
      type: 'boolean',
    },
    {
      name: 'cookie_prefix',
      desc: "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'",
      type: 'string',
    },
    {
      name: 'inactivity_timeout',
      desc: "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'maximum_duration',
      desc: "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'auth_check_interval',
      desc: "Integer number of seconds after which ngrok guarantees it will refresh user state from the identity provider and recheck whether the user is still authorized to access the endpoint. This is the preferred tunable to use to enforce a minimum amount of time after which a revoked user will no longer be able to access the resource.",
      type: 'uint32',
    },
    ],
  EndpointOAuthFacebook: [
    {
      name: 'client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    ],
  EndpointOAuthGitHub: [
    {
      name: 'client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'teams',
      desc: "a list of github teams identifiers. users will be allowed access to the endpoint if they are a member of any of these teams. identifiers should be in the 'slug' format qualified with the org name, e.g. `org-name/team-name`",
      type: 'List<string>',
    },
    {
      name: 'organizations',
      desc: "a list of github org identifiers. users who are members of any of the listed organizations will be allowed access. identifiers should be the organization's 'slug'",
      type: 'List<string>',
    },
    ],
  EndpointOAuthGoogle: [
    {
      name: 'client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    ],
  EndpointOAuthLinkedIn: [
    {
      name: 'client_id',
      desc: "",
      type: 'string',
    },
    {
      name: 'client_secret',
      desc: "",
      type: 'string',
    },
    {
      name: 'scopes',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'email_addresses',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'email_domains',
      desc: "",
      type: 'List<string>',
    },
    ],
  EndpointOAuthMicrosoft: [
    {
      name: 'client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    ],
  EndpointOAuthProvider: [
    {
      name: 'github.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'github.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'github.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'github.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'github.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'github.teams',
      desc: "a list of github teams identifiers. users will be allowed access to the endpoint if they are a member of any of these teams. identifiers should be in the 'slug' format qualified with the org name, e.g. `org-name/team-name`",
      type: 'List<string>',
    },
    {
      name: 'github.organizations',
      desc: "a list of github org identifiers. users who are members of any of the listed organizations will be allowed access. identifiers should be the organization's 'slug'",
      type: 'List<string>',
    },
    {
      name: 'facebook.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'facebook.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'facebook.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'facebook.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'facebook.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'microsoft.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'microsoft.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'microsoft.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'microsoft.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'microsoft.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'google.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'google.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'google.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'google.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'google.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'linkedin.client_id',
      desc: "",
      type: 'string',
    },
    {
      name: 'linkedin.client_secret',
      desc: "",
      type: 'string',
    },
    {
      name: 'linkedin.scopes',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'linkedin.email_addresses',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'linkedin.email_domains',
      desc: "",
      type: 'List<string>',
    },
    ],
  EndpointOAuthReplace: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'module.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'module.provider.github.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'module.provider.github.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'module.provider.github.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'module.provider.github.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'module.provider.github.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'module.provider.github.teams',
      desc: "a list of github teams identifiers. users will be allowed access to the endpoint if they are a member of any of these teams. identifiers should be in the 'slug' format qualified with the org name, e.g. `org-name/team-name`",
      type: 'List<string>',
    },
    {
      name: 'module.provider.github.organizations',
      desc: "a list of github org identifiers. users who are members of any of the listed organizations will be allowed access. identifiers should be the organization's 'slug'",
      type: 'List<string>',
    },
    {
      name: 'module.provider.facebook.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'module.provider.facebook.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'module.provider.facebook.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'module.provider.facebook.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'module.provider.facebook.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'module.provider.microsoft.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'module.provider.microsoft.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'module.provider.microsoft.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'module.provider.microsoft.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'module.provider.microsoft.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'module.provider.google.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'module.provider.google.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'module.provider.google.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'module.provider.google.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'module.provider.google.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'module.provider.linkedin.client_id',
      desc: "",
      type: 'string',
    },
    {
      name: 'module.provider.linkedin.client_secret',
      desc: "",
      type: 'string',
    },
    {
      name: 'module.provider.linkedin.scopes',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'module.provider.linkedin.email_addresses',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'module.provider.linkedin.email_domains',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'module.options_passthrough',
      desc: "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.",
      type: 'boolean',
    },
    {
      name: 'module.cookie_prefix',
      desc: "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'",
      type: 'string',
    },
    {
      name: 'module.inactivity_timeout',
      desc: "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'module.maximum_duration',
      desc: "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'module.auth_check_interval',
      desc: "Integer number of seconds after which ngrok guarantees it will refresh user state from the identity provider and recheck whether the user is still authorized to access the endpoint. This is the preferred tunable to use to enforce a minimum amount of time after which a revoked user will no longer be able to access the resource.",
      type: 'uint32',
    },
    ],
  EndpointOIDC: [
    {
      name: 'enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'options_passthrough',
      desc: "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.",
      type: 'boolean',
    },
    {
      name: 'cookie_prefix',
      desc: "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'",
      type: 'string',
    },
    {
      name: 'inactivity_timeout',
      desc: "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'maximum_duration',
      desc: "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'issuer',
      desc: "URL of the OIDC \"OpenID provider\". This is the base URL used for discovery.",
      type: 'string',
    },
    {
      name: 'client_id',
      desc: "The OIDC app's client ID and OIDC audience.",
      type: 'string',
    },
    {
      name: 'client_secret',
      desc: "The OIDC app's client secret.",
      type: 'string',
    },
    {
      name: 'scopes',
      desc: "The set of scopes to request from the OIDC identity provider.",
      type: 'List<string>',
    },
    ],
  EndpointOIDCReplace: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'module.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'module.options_passthrough',
      desc: "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.",
      type: 'boolean',
    },
    {
      name: 'module.cookie_prefix',
      desc: "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'",
      type: 'string',
    },
    {
      name: 'module.inactivity_timeout',
      desc: "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'module.maximum_duration',
      desc: "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'module.issuer',
      desc: "URL of the OIDC \"OpenID provider\". This is the base URL used for discovery.",
      type: 'string',
    },
    {
      name: 'module.client_id',
      desc: "The OIDC app's client ID and OIDC audience.",
      type: 'string',
    },
    {
      name: 'module.client_secret',
      desc: "The OIDC app's client secret.",
      type: 'string',
    },
    {
      name: 'module.scopes',
      desc: "The set of scopes to request from the OIDC identity provider.",
      type: 'List<string>',
    },
    ],
  EndpointRequestHeaders: [
    {
      name: 'enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'add',
      desc: "a map of header key to header value that will be injected into the HTTP Request before being sent to the upstream application server",
      type: 'Map<string, string>',
    },
    {
      name: 'remove',
      desc: "a list of header names that will be removed from the HTTP Request before being sent to the upstream application server",
      type: 'List<string>',
    },
    ],
  EndpointRequestHeadersReplace: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'module.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'module.add',
      desc: "a map of header key to header value that will be injected into the HTTP Request before being sent to the upstream application server",
      type: 'Map<string, string>',
    },
    {
      name: 'module.remove',
      desc: "a list of header names that will be removed from the HTTP Request before being sent to the upstream application server",
      type: 'List<string>',
    },
    ],
  EndpointResponseHeaders: [
    {
      name: 'enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'add',
      desc: "a map of header key to header value that will be injected into the HTTP Response returned to the HTTP client",
      type: 'Map<string, string>',
    },
    {
      name: 'remove',
      desc: "a list of header names that will be removed from the HTTP Response returned to the HTTP client",
      type: 'List<string>',
    },
    ],
  EndpointResponseHeadersReplace: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'module.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'module.add',
      desc: "a map of header key to header value that will be injected into the HTTP Response returned to the HTTP client",
      type: 'Map<string, string>',
    },
    {
      name: 'module.remove',
      desc: "a list of header names that will be removed from the HTTP Response returned to the HTTP client",
      type: 'List<string>',
    },
    ],
  EndpointSAML: [
    {
      name: 'enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'options_passthrough',
      desc: "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.",
      type: 'boolean',
    },
    {
      name: 'cookie_prefix',
      desc: "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'",
      type: 'string',
    },
    {
      name: 'inactivity_timeout',
      desc: "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'maximum_duration',
      desc: "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'idp_metadata',
      desc: "The full XML IdP EntityDescriptor. Your IdP may provide this to you as a a file to download or as a URL.",
      type: 'string',
    },
    {
      name: 'force_authn',
      desc: "If true, indicates that whenever we redirect a user to the IdP for authentication that the IdP must prompt the user for authentication credentials even if the user already has a valid session with the IdP.",
      type: 'boolean',
    },
    {
      name: 'allow_idp_initiated',
      desc: "If true, the IdP may initiate a login directly (e.g. the user does not need to visit the endpoint first and then be redirected). The IdP should set the `RelayState` parameter to the target URL of the resource they want the user to be redirected to after the SAML login assertion has been processed.",
      type: 'boolean',
    },
    {
      name: 'authorized_groups',
      desc: "If present, only users who are a member of one of the listed groups may access the target endpoint.",
      type: 'List<string>',
    },
    {
      name: 'entity_id',
      desc: "The SP Entity's unique ID. This always takes the form of a URL. In ngrok's implementation, this URL is the same as the metadata URL. This will need to be specified to the IdP as configuration.",
      type: 'string',
    },
    {
      name: 'assertion_consumer_service_url',
      desc: "The public URL of the SP's Assertion Consumer Service. This is where the IdP will redirect to during an authentication flow. This will need to be specified to the IdP as configuration.",
      type: 'string',
    },
    {
      name: 'single_logout_url',
      desc: "The public URL of the SP's Single Logout Service. This is where the IdP will redirect to during a single logout flow. This will optionally need to be specified to the IdP as configuration.",
      type: 'string',
    },
    {
      name: 'request_signing_certificate_pem',
      desc: "PEM-encoded x.509 certificate of the key pair that is used to sign all SAML requests that the ngrok SP makes to the IdP. Many IdPs do not support request signing verification, but we highly recommend specifying this in the IdP's configuration if it is supported.",
      type: 'string',
    },
    {
      name: 'metadata_url',
      desc: "A public URL where the SP's metadata is hosted. If an IdP supports dynamic configuration, this is the URL it can use to retrieve the SP metadata.",
      type: 'string',
    },
    {
      name: 'nameid_format',
      desc: "Defines the name identifier format the SP expects the IdP to use in its assertions to identify subjects. If unspecified, a default value of `urn:oasis:names:tc:SAML:2.0:nameid-format:persistent` will be used. A subset of the allowed values enumerated by the SAML specification are supported.",
      type: 'string',
    },
    ],
  EndpointSAMLMutate: [
    {
      name: 'enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'options_passthrough',
      desc: "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.",
      type: 'boolean',
    },
    {
      name: 'cookie_prefix',
      desc: "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'",
      type: 'string',
    },
    {
      name: 'inactivity_timeout',
      desc: "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'maximum_duration',
      desc: "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'idp_metadata',
      desc: "The full XML IdP EntityDescriptor. Your IdP may provide this to you as a a file to download or as a URL.",
      type: 'string',
    },
    {
      name: 'force_authn',
      desc: "If true, indicates that whenever we redirect a user to the IdP for authentication that the IdP must prompt the user for authentication credentials even if the user already has a valid session with the IdP.",
      type: 'boolean',
    },
    {
      name: 'allow_idp_initiated',
      desc: "If true, the IdP may initiate a login directly (e.g. the user does not need to visit the endpoint first and then be redirected). The IdP should set the `RelayState` parameter to the target URL of the resource they want the user to be redirected to after the SAML login assertion has been processed.",
      type: 'boolean',
    },
    {
      name: 'authorized_groups',
      desc: "If present, only users who are a member of one of the listed groups may access the target endpoint.",
      type: 'List<string>',
    },
    {
      name: 'nameid_format',
      desc: "Defines the name identifier format the SP expects the IdP to use in its assertions to identify subjects. If unspecified, a default value of `urn:oasis:names:tc:SAML:2.0:nameid-format:persistent` will be used. A subset of the allowed values enumerated by the SAML specification are supported.",
      type: 'string',
    },
    ],
  EndpointSAMLReplace: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'module.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'module.options_passthrough',
      desc: "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.",
      type: 'boolean',
    },
    {
      name: 'module.cookie_prefix',
      desc: "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'",
      type: 'string',
    },
    {
      name: 'module.inactivity_timeout',
      desc: "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'module.maximum_duration',
      desc: "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'module.idp_metadata',
      desc: "The full XML IdP EntityDescriptor. Your IdP may provide this to you as a a file to download or as a URL.",
      type: 'string',
    },
    {
      name: 'module.force_authn',
      desc: "If true, indicates that whenever we redirect a user to the IdP for authentication that the IdP must prompt the user for authentication credentials even if the user already has a valid session with the IdP.",
      type: 'boolean',
    },
    {
      name: 'module.allow_idp_initiated',
      desc: "If true, the IdP may initiate a login directly (e.g. the user does not need to visit the endpoint first and then be redirected). The IdP should set the `RelayState` parameter to the target URL of the resource they want the user to be redirected to after the SAML login assertion has been processed.",
      type: 'boolean',
    },
    {
      name: 'module.authorized_groups',
      desc: "If present, only users who are a member of one of the listed groups may access the target endpoint.",
      type: 'List<string>',
    },
    {
      name: 'module.nameid_format',
      desc: "Defines the name identifier format the SP expects the IdP to use in its assertions to identify subjects. If unspecified, a default value of `urn:oasis:names:tc:SAML:2.0:nameid-format:persistent` will be used. A subset of the allowed values enumerated by the SAML specification are supported.",
      type: 'string',
    },
    ],
  EndpointTLSTermination: [
    {
      name: 'enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'terminate_at',
      desc: "`edge` if the ngrok edge should terminate TLS traffic, `upstream` if TLS traffic should be passed through to the upstream ngrok agent / application server for termination. if `upstream` is chosen, most other modules will be disallowed because they rely on the ngrok edge being able to access the underlying traffic.",
      type: 'string',
    },
    {
      name: 'min_version',
      desc: "The minimum TLS version used for termination and advertised to the client during the TLS handshake. if unspecified, ngrok will choose an industry-safe default. This value must be null if `terminate_at` is set to `upstream`.",
      type: 'string',
    },
    ],
  EndpointTLSTerminationAtEdge: [
    {
      name: 'enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'min_version',
      desc: "The minimum TLS version used for termination and advertised to the client during the TLS handshake. if unspecified, ngrok will choose an industry-safe default. This value must be null if `terminate_at` is set to `upstream`.",
      type: 'string',
    },
    ],
  EndpointTLSTerminationReplace: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'module.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'module.terminate_at',
      desc: "`edge` if the ngrok edge should terminate TLS traffic, `upstream` if TLS traffic should be passed through to the upstream ngrok agent / application server for termination. if `upstream` is chosen, most other modules will be disallowed because they rely on the ngrok edge being able to access the underlying traffic.",
      type: 'string',
    },
    {
      name: 'module.min_version',
      desc: "The minimum TLS version used for termination and advertised to the client during the TLS handshake. if unspecified, ngrok will choose an industry-safe default. This value must be null if `terminate_at` is set to `upstream`.",
      type: 'string',
    },
    ],
  EndpointWebhookValidation: [
    {
      name: 'enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'provider',
      desc: "a string indicating which webhook provider will be sending webhooks to this endpoint. Value must be one of the supported providers defined at https://ngrok.com/docs/cloud-edge#webhook-verification",
      type: 'string',
    },
    {
      name: 'secret',
      desc: "a string secret used to validate requests from the given provider. All providers except AWS SNS require a secret",
      type: 'string',
    },
    ],
  EndpointWebhookValidationReplace: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'module.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'module.provider',
      desc: "a string indicating which webhook provider will be sending webhooks to this endpoint. Value must be one of the supported providers defined at https://ngrok.com/docs/cloud-edge#webhook-verification",
      type: 'string',
    },
    {
      name: 'module.secret',
      desc: "a string secret used to validate requests from the given provider. All providers except AWS SNS require a secret",
      type: 'string',
    },
    ],
  EndpointWebsocketTCPConverter: [
    {
      name: 'enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    ],
  Error: [
    {
      name: 'error_code',
      desc: "",
      type: 'string',
    },
    {
      name: 'status_code',
      desc: "",
      type: 'int32',
    },
    {
      name: 'msg',
      desc: "",
      type: 'string',
    },
    {
      name: 'details',
      desc: "",
      type: 'Map<string, string>',
    },
    ],
  EventDestination: [
    {
      name: 'id',
      desc: "Unique identifier for this Event Destination.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "Arbitrary user-defined machine-readable data of this Event Destination. Optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'created_at',
      desc: "Timestamp when the Event Destination was created, RFC 3339 format.",
      type: 'string',
    },
    {
      name: 'description',
      desc: "Human-readable description of the Event Destination. Optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'format',
      desc: "The output format you would like to serialize events into when sending to their target. Currently the only accepted value is `JSON`.",
      type: 'string',
    },
    {
      name: 'target.firehose.auth.role.role_arn',
      desc: "An ARN that specifies the role that ngrok should use to deliver to the configured target.",
      type: 'string',
    },
    {
      name: 'target.firehose.auth.creds.aws_access_key_id',
      desc: "The ID portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'target.firehose.auth.creds.aws_secret_access_key',
      desc: "The secret portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'target.firehose.delivery_stream_arn',
      desc: "An Amazon Resource Name specifying the Firehose delivery stream to deposit events into.",
      type: 'string',
    },
    {
      name: 'target.kinesis.auth.role.role_arn',
      desc: "An ARN that specifies the role that ngrok should use to deliver to the configured target.",
      type: 'string',
    },
    {
      name: 'target.kinesis.auth.creds.aws_access_key_id',
      desc: "The ID portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'target.kinesis.auth.creds.aws_secret_access_key',
      desc: "The secret portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'target.kinesis.stream_arn',
      desc: "An Amazon Resource Name specifying the Kinesis stream to deposit events into.",
      type: 'string',
    },
    {
      name: 'target.cloudwatch_logs.auth.role.role_arn',
      desc: "An ARN that specifies the role that ngrok should use to deliver to the configured target.",
      type: 'string',
    },
    {
      name: 'target.cloudwatch_logs.auth.creds.aws_access_key_id',
      desc: "The ID portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'target.cloudwatch_logs.auth.creds.aws_secret_access_key',
      desc: "The secret portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'target.cloudwatch_logs.log_group_arn',
      desc: "An Amazon Resource Name specifying the CloudWatch Logs group to deposit events into.",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the Event Destination API resource.",
      type: 'string',
    },
    ],
  EventDestinationCreate: [
    {
      name: 'metadata',
      desc: "Arbitrary user-defined machine-readable data of this Event Destination. Optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'description',
      desc: "Human-readable description of the Event Destination. Optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'format',
      desc: "The output format you would like to serialize events into when sending to their target. Currently the only accepted value is `JSON`.",
      type: 'string',
    },
    {
      name: 'target.firehose.auth.role.role_arn',
      desc: "An ARN that specifies the role that ngrok should use to deliver to the configured target.",
      type: 'string',
    },
    {
      name: 'target.firehose.auth.creds.aws_access_key_id',
      desc: "The ID portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'target.firehose.auth.creds.aws_secret_access_key',
      desc: "The secret portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'target.firehose.delivery_stream_arn',
      desc: "An Amazon Resource Name specifying the Firehose delivery stream to deposit events into.",
      type: 'string',
    },
    {
      name: 'target.kinesis.auth.role.role_arn',
      desc: "An ARN that specifies the role that ngrok should use to deliver to the configured target.",
      type: 'string',
    },
    {
      name: 'target.kinesis.auth.creds.aws_access_key_id',
      desc: "The ID portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'target.kinesis.auth.creds.aws_secret_access_key',
      desc: "The secret portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'target.kinesis.stream_arn',
      desc: "An Amazon Resource Name specifying the Kinesis stream to deposit events into.",
      type: 'string',
    },
    {
      name: 'target.cloudwatch_logs.auth.role.role_arn',
      desc: "An ARN that specifies the role that ngrok should use to deliver to the configured target.",
      type: 'string',
    },
    {
      name: 'target.cloudwatch_logs.auth.creds.aws_access_key_id',
      desc: "The ID portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'target.cloudwatch_logs.auth.creds.aws_secret_access_key',
      desc: "The secret portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'target.cloudwatch_logs.log_group_arn',
      desc: "An Amazon Resource Name specifying the CloudWatch Logs group to deposit events into.",
      type: 'string',
    },
    ],
  EventDestinationList: [
    {
      name: 'event_destinations.id',
      desc: "Unique identifier for this Event Destination.",
      type: 'string',
    },
    {
      name: 'event_destinations.metadata',
      desc: "Arbitrary user-defined machine-readable data of this Event Destination. Optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'event_destinations.created_at',
      desc: "Timestamp when the Event Destination was created, RFC 3339 format.",
      type: 'string',
    },
    {
      name: 'event_destinations.description',
      desc: "Human-readable description of the Event Destination. Optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'event_destinations.format',
      desc: "The output format you would like to serialize events into when sending to their target. Currently the only accepted value is `JSON`.",
      type: 'string',
    },
    {
      name: 'event_destinations.target.firehose.auth.role.role_arn',
      desc: "An ARN that specifies the role that ngrok should use to deliver to the configured target.",
      type: 'string',
    },
    {
      name: 'event_destinations.target.firehose.auth.creds.aws_access_key_id',
      desc: "The ID portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'event_destinations.target.firehose.auth.creds.aws_secret_access_key',
      desc: "The secret portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'event_destinations.target.firehose.delivery_stream_arn',
      desc: "An Amazon Resource Name specifying the Firehose delivery stream to deposit events into.",
      type: 'string',
    },
    {
      name: 'event_destinations.target.kinesis.auth.role.role_arn',
      desc: "An ARN that specifies the role that ngrok should use to deliver to the configured target.",
      type: 'string',
    },
    {
      name: 'event_destinations.target.kinesis.auth.creds.aws_access_key_id',
      desc: "The ID portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'event_destinations.target.kinesis.auth.creds.aws_secret_access_key',
      desc: "The secret portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'event_destinations.target.kinesis.stream_arn',
      desc: "An Amazon Resource Name specifying the Kinesis stream to deposit events into.",
      type: 'string',
    },
    {
      name: 'event_destinations.target.cloudwatch_logs.auth.role.role_arn',
      desc: "An ARN that specifies the role that ngrok should use to deliver to the configured target.",
      type: 'string',
    },
    {
      name: 'event_destinations.target.cloudwatch_logs.auth.creds.aws_access_key_id',
      desc: "The ID portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'event_destinations.target.cloudwatch_logs.auth.creds.aws_secret_access_key',
      desc: "The secret portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'event_destinations.target.cloudwatch_logs.log_group_arn',
      desc: "An Amazon Resource Name specifying the CloudWatch Logs group to deposit events into.",
      type: 'string',
    },
    {
      name: 'event_destinations.uri',
      desc: "URI of the Event Destination API resource.",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the Event Destinations list API resource.",
      type: 'string',
    },
    {
      name: 'next_page_uri',
      desc: "URI of the next page, or null if there is no next page.",
      type: 'string',
    },
    ],
  EventDestinationUpdate: [
    {
      name: 'id',
      desc: "Unique identifier for this Event Destination.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "Arbitrary user-defined machine-readable data of this Event Destination. Optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'description',
      desc: "Human-readable description of the Event Destination. Optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'format',
      desc: "The output format you would like to serialize events into when sending to their target. Currently the only accepted value is `JSON`.",
      type: 'string',
    },
    {
      name: 'target.firehose.auth.role.role_arn',
      desc: "An ARN that specifies the role that ngrok should use to deliver to the configured target.",
      type: 'string',
    },
    {
      name: 'target.firehose.auth.creds.aws_access_key_id',
      desc: "The ID portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'target.firehose.auth.creds.aws_secret_access_key',
      desc: "The secret portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'target.firehose.delivery_stream_arn',
      desc: "An Amazon Resource Name specifying the Firehose delivery stream to deposit events into.",
      type: 'string',
    },
    {
      name: 'target.kinesis.auth.role.role_arn',
      desc: "An ARN that specifies the role that ngrok should use to deliver to the configured target.",
      type: 'string',
    },
    {
      name: 'target.kinesis.auth.creds.aws_access_key_id',
      desc: "The ID portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'target.kinesis.auth.creds.aws_secret_access_key',
      desc: "The secret portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'target.kinesis.stream_arn',
      desc: "An Amazon Resource Name specifying the Kinesis stream to deposit events into.",
      type: 'string',
    },
    {
      name: 'target.cloudwatch_logs.auth.role.role_arn',
      desc: "An ARN that specifies the role that ngrok should use to deliver to the configured target.",
      type: 'string',
    },
    {
      name: 'target.cloudwatch_logs.auth.creds.aws_access_key_id',
      desc: "The ID portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'target.cloudwatch_logs.auth.creds.aws_secret_access_key',
      desc: "The secret portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'target.cloudwatch_logs.log_group_arn',
      desc: "An Amazon Resource Name specifying the CloudWatch Logs group to deposit events into.",
      type: 'string',
    },
    ],
  EventSource: [
    {
      name: 'type',
      desc: "Type of event for which an event subscription will trigger",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the Event Source API resource.",
      type: 'string',
    },
    ],
  EventSourceCreate: [
    {
      name: 'subscription_id',
      desc: "The unique identifier for the Event Subscription that this Event Source is attached to.",
      type: 'string',
    },
    {
      name: 'type',
      desc: "Type of event for which an event subscription will trigger",
      type: 'string',
    },
    ],
  EventSourceItem: [
    {
      name: 'subscription_id',
      desc: "The unique identifier for the Event Subscription that this Event Source is attached to.",
      type: 'string',
    },
    {
      name: 'type',
      desc: "Type of event for which an event subscription will trigger",
      type: 'string',
    },
    ],
  EventSourceList: [
    {
      name: 'sources.type',
      desc: "Type of event for which an event subscription will trigger",
      type: 'string',
    },
    {
      name: 'sources.uri',
      desc: "URI of the Event Source API resource.",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the next page, or null if there is no next page.",
      type: 'string',
    },
    ],
  EventSourcePaging: [
    {
      name: 'subscription_id',
      desc: "The unique identifier for the Event Subscription that this Event Source is attached to.",
      type: 'string',
    },
    ],
  EventSourceReplace: [
    {
      name: 'type',
      desc: "Type of event for which an event subscription will trigger",
      type: 'string',
    },
    ],
  EventSourceUpdate: [
    {
      name: 'subscription_id',
      desc: "The unique identifier for the Event Subscription that this Event Source is attached to.",
      type: 'string',
    },
    {
      name: 'type',
      desc: "Type of event for which an event subscription will trigger",
      type: 'string',
    },
    ],
  EventSubscription: [
    {
      name: 'id',
      desc: "Unique identifier for this Event Subscription.",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the Event Subscription API resource.",
      type: 'string',
    },
    {
      name: 'created_at',
      desc: "When the Event Subscription was created (RFC 3339 format).",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "Arbitrary customer supplied information intended to be machine readable. Optional, max 4096 chars.",
      type: 'string',
    },
    {
      name: 'description',
      desc: "Arbitrary customer supplied information intended to be human readable. Optional, max 255 chars.",
      type: 'string',
    },
    {
      name: 'sources.type',
      desc: "Type of event for which an event subscription will trigger",
      type: 'string',
    },
    {
      name: 'sources.uri',
      desc: "URI of the Event Source API resource.",
      type: 'string',
    },
    {
      name: 'destinations.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'destinations.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    ],
  EventSubscriptionCreate: [
    {
      name: 'metadata',
      desc: "Arbitrary customer supplied information intended to be machine readable. Optional, max 4096 chars.",
      type: 'string',
    },
    {
      name: 'description',
      desc: "Arbitrary customer supplied information intended to be human readable. Optional, max 255 chars.",
      type: 'string',
    },
    {
      name: 'sources.type',
      desc: "Type of event for which an event subscription will trigger",
      type: 'string',
    },
    {
      name: 'destination_ids',
      desc: "A list of Event Destination IDs which should be used for this Event Subscription.",
      type: 'List<string>',
    },
    ],
  EventSubscriptionList: [
    {
      name: 'event_subscriptions.id',
      desc: "Unique identifier for this Event Subscription.",
      type: 'string',
    },
    {
      name: 'event_subscriptions.uri',
      desc: "URI of the Event Subscription API resource.",
      type: 'string',
    },
    {
      name: 'event_subscriptions.created_at',
      desc: "When the Event Subscription was created (RFC 3339 format).",
      type: 'string',
    },
    {
      name: 'event_subscriptions.metadata',
      desc: "Arbitrary customer supplied information intended to be machine readable. Optional, max 4096 chars.",
      type: 'string',
    },
    {
      name: 'event_subscriptions.description',
      desc: "Arbitrary customer supplied information intended to be human readable. Optional, max 255 chars.",
      type: 'string',
    },
    {
      name: 'event_subscriptions.sources.type',
      desc: "Type of event for which an event subscription will trigger",
      type: 'string',
    },
    {
      name: 'event_subscriptions.sources.uri',
      desc: "URI of the Event Source API resource.",
      type: 'string',
    },
    {
      name: 'event_subscriptions.destinations.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'event_subscriptions.destinations.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the Event Subscriptions list API resource.",
      type: 'string',
    },
    {
      name: 'next_page_uri',
      desc: "URI of next page, or null if there is no next page.",
      type: 'string',
    },
    ],
  EventSubscriptionUpdate: [
    {
      name: 'id',
      desc: "Unique identifier for this Event Subscription.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "Arbitrary customer supplied information intended to be machine readable. Optional, max 4096 chars.",
      type: 'string',
    },
    {
      name: 'description',
      desc: "Arbitrary customer supplied information intended to be human readable. Optional, max 255 chars.",
      type: 'string',
    },
    {
      name: 'sources.type',
      desc: "Type of event for which an event subscription will trigger",
      type: 'string',
    },
    {
      name: 'destination_ids',
      desc: "A list of Event Destination IDs which should be used for this Event Subscription.",
      type: 'List<string>',
    },
    ],
  EventTarget: [
    {
      name: 'firehose.auth.role.role_arn',
      desc: "An ARN that specifies the role that ngrok should use to deliver to the configured target.",
      type: 'string',
    },
    {
      name: 'firehose.auth.creds.aws_access_key_id',
      desc: "The ID portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'firehose.auth.creds.aws_secret_access_key',
      desc: "The secret portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'firehose.delivery_stream_arn',
      desc: "An Amazon Resource Name specifying the Firehose delivery stream to deposit events into.",
      type: 'string',
    },
    {
      name: 'kinesis.auth.role.role_arn',
      desc: "An ARN that specifies the role that ngrok should use to deliver to the configured target.",
      type: 'string',
    },
    {
      name: 'kinesis.auth.creds.aws_access_key_id',
      desc: "The ID portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'kinesis.auth.creds.aws_secret_access_key',
      desc: "The secret portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'kinesis.stream_arn',
      desc: "An Amazon Resource Name specifying the Kinesis stream to deposit events into.",
      type: 'string',
    },
    {
      name: 'cloudwatch_logs.auth.role.role_arn',
      desc: "An ARN that specifies the role that ngrok should use to deliver to the configured target.",
      type: 'string',
    },
    {
      name: 'cloudwatch_logs.auth.creds.aws_access_key_id',
      desc: "The ID portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'cloudwatch_logs.auth.creds.aws_secret_access_key',
      desc: "The secret portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'cloudwatch_logs.log_group_arn',
      desc: "An Amazon Resource Name specifying the CloudWatch Logs group to deposit events into.",
      type: 'string',
    },
    ],
  EventTargetCloudwatchLogs: [
    {
      name: 'auth.role.role_arn',
      desc: "An ARN that specifies the role that ngrok should use to deliver to the configured target.",
      type: 'string',
    },
    {
      name: 'auth.creds.aws_access_key_id',
      desc: "The ID portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'auth.creds.aws_secret_access_key',
      desc: "The secret portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'log_group_arn',
      desc: "An Amazon Resource Name specifying the CloudWatch Logs group to deposit events into.",
      type: 'string',
    },
    ],
  EventTargetDebug: [
    {
      name: 'log',
      desc: "Whether or not to output to publisher service logs.",
      type: 'boolean',
    },
    {
      name: 'callback_url',
      desc: "URL to send events to.",
      type: 'string',
    },
    ],
  EventTargetFirehose: [
    {
      name: 'auth.role.role_arn',
      desc: "An ARN that specifies the role that ngrok should use to deliver to the configured target.",
      type: 'string',
    },
    {
      name: 'auth.creds.aws_access_key_id',
      desc: "The ID portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'auth.creds.aws_secret_access_key',
      desc: "The secret portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'delivery_stream_arn',
      desc: "An Amazon Resource Name specifying the Firehose delivery stream to deposit events into.",
      type: 'string',
    },
    ],
  EventTargetKinesis: [
    {
      name: 'auth.role.role_arn',
      desc: "An ARN that specifies the role that ngrok should use to deliver to the configured target.",
      type: 'string',
    },
    {
      name: 'auth.creds.aws_access_key_id',
      desc: "The ID portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'auth.creds.aws_secret_access_key',
      desc: "The secret portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'stream_arn',
      desc: "An Amazon Resource Name specifying the Kinesis stream to deposit events into.",
      type: 'string',
    },
    ],
  EventTargetS3: [
    {
      name: 'auth.role.role_arn',
      desc: "An ARN that specifies the role that ngrok should use to deliver to the configured target.",
      type: 'string',
    },
    {
      name: 'auth.creds.aws_access_key_id',
      desc: "The ID portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'auth.creds.aws_secret_access_key',
      desc: "The secret portion of an AWS access key.",
      type: 'string',
    },
    {
      name: 'bucket_arn',
      desc: "An Amazon Resource Name specifying the S3 bucket to deposit events into.",
      type: 'string',
    },
    {
      name: 'object_prefix',
      desc: "An optional prefix to prepend to S3 object keys.",
      type: 'string',
    },
    {
      name: 'compression',
      desc: "Whether or not to compress files with gzip.",
      type: 'boolean',
    },
    {
      name: 'max_file_size',
      desc: "How many bytes we should accumulate into a single file before sending to S3.",
      type: 'int64',
    },
    {
      name: 'max_file_age',
      desc: "How many seconds we should batch up events before sending them to S3.",
      type: 'int64',
    },
    ],
  FailoverBackend: [
    {
      name: 'id',
      desc: "unique identifier for this Failover backend",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the FailoverBackend API resource",
      type: 'string',
    },
    {
      name: 'created_at',
      desc: "timestamp when the backend was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of this backend. Optional",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this backend. Optional",
      type: 'string',
    },
    {
      name: 'backends',
      desc: "the ids of the child backends in order",
      type: 'List<string>',
    },
    ],
  FailoverBackendCreate: [
    {
      name: 'description',
      desc: "human-readable description of this backend. Optional",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this backend. Optional",
      type: 'string',
    },
    {
      name: 'backends',
      desc: "the ids of the child backends in order",
      type: 'List<string>',
    },
    ],
  FailoverBackendList: [
    {
      name: 'backends.id',
      desc: "unique identifier for this Failover backend",
      type: 'string',
    },
    {
      name: 'backends.uri',
      desc: "URI of the FailoverBackend API resource",
      type: 'string',
    },
    {
      name: 'backends.created_at',
      desc: "timestamp when the backend was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'backends.description',
      desc: "human-readable description of this backend. Optional",
      type: 'string',
    },
    {
      name: 'backends.metadata',
      desc: "arbitrary user-defined machine-readable data of this backend. Optional",
      type: 'string',
    },
    {
      name: 'backends.backends',
      desc: "the ids of the child backends in order",
      type: 'List<string>',
    },
    {
      name: 'uri',
      desc: "URI of the Failover backends list API resource",
      type: 'string',
    },
    {
      name: 'next_page_uri',
      desc: "URI of the next page, or null if there is no next page",
      type: 'string',
    },
    ],
  FailoverBackendUpdate: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of this backend. Optional",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this backend. Optional",
      type: 'string',
    },
    {
      name: 'backends',
      desc: "the ids of the child backends in order",
      type: 'List<string>',
    },
    ],
  HTTPResponseBackend: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the HTTPResponseBackend API resource",
      type: 'string',
    },
    {
      name: 'created_at',
      desc: "timestamp when the backend was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of this backend. Optional",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this backend. Optional",
      type: 'string',
    },
    {
      name: 'body',
      desc: "body to return as fixed content",
      type: 'string',
    },
    {
      name: 'headers',
      desc: "headers to return",
      type: 'Map<string, string>',
    },
    {
      name: 'status_code',
      desc: "status code to return",
      type: 'int32',
    },
    ],
  HTTPResponseBackendCreate: [
    {
      name: 'description',
      desc: "human-readable description of this backend. Optional",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this backend. Optional",
      type: 'string',
    },
    {
      name: 'body',
      desc: "body to return as fixed content",
      type: 'string',
    },
    {
      name: 'headers',
      desc: "headers to return",
      type: 'Map<string, string>',
    },
    {
      name: 'status_code',
      desc: "status code to return",
      type: 'int32',
    },
    ],
  HTTPResponseBackendList: [
    {
      name: 'backends.id',
      desc: "",
      type: 'string',
    },
    {
      name: 'backends.uri',
      desc: "URI of the HTTPResponseBackend API resource",
      type: 'string',
    },
    {
      name: 'backends.created_at',
      desc: "timestamp when the backend was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'backends.description',
      desc: "human-readable description of this backend. Optional",
      type: 'string',
    },
    {
      name: 'backends.metadata',
      desc: "arbitrary user-defined machine-readable data of this backend. Optional",
      type: 'string',
    },
    {
      name: 'backends.body',
      desc: "body to return as fixed content",
      type: 'string',
    },
    {
      name: 'backends.headers',
      desc: "headers to return",
      type: 'Map<string, string>',
    },
    {
      name: 'backends.status_code',
      desc: "status code to return",
      type: 'int32',
    },
    {
      name: 'uri',
      desc: "",
      type: 'string',
    },
    {
      name: 'next_page_uri',
      desc: "",
      type: 'string',
    },
    ],
  HTTPResponseBackendUpdate: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of this backend. Optional",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this backend. Optional",
      type: 'string',
    },
    {
      name: 'body',
      desc: "body to return as fixed content",
      type: 'string',
    },
    {
      name: 'headers',
      desc: "headers to return",
      type: 'Map<string, string>',
    },
    {
      name: 'status_code',
      desc: "status code to return",
      type: 'int32',
    },
    ],
  HTTPSEdge: [
    {
      name: 'id',
      desc: "unique identifier of this edge",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of what this edge will be used for; optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this edge; optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'created_at',
      desc: "timestamp when the edge configuration was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the edge API resource",
      type: 'string',
    },
    {
      name: 'hostports',
      desc: "hostports served by this edge",
      type: 'List<string>',
    },
    {
      name: 'mutual_tls.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'mutual_tls.certificate_authorities.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'mutual_tls.certificate_authorities.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'tls_termination.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'tls_termination.terminate_at',
      desc: "`edge` if the ngrok edge should terminate TLS traffic, `upstream` if TLS traffic should be passed through to the upstream ngrok agent / application server for termination. if `upstream` is chosen, most other modules will be disallowed because they rely on the ngrok edge being able to access the underlying traffic.",
      type: 'string',
    },
    {
      name: 'tls_termination.min_version',
      desc: "The minimum TLS version used for termination and advertised to the client during the TLS handshake. if unspecified, ngrok will choose an industry-safe default. This value must be null if `terminate_at` is set to `upstream`.",
      type: 'string',
    },
    {
      name: 'routes.edge_id',
      desc: "unique identifier of this edge",
      type: 'string',
    },
    {
      name: 'routes.id',
      desc: "unique identifier of this edge route",
      type: 'string',
    },
    {
      name: 'routes.created_at',
      desc: "timestamp when the edge configuration was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'routes.match_type',
      desc: "Type of match to use for this route. Valid values are \"exact_path\" and \"path_prefix\".",
      type: 'string',
    },
    {
      name: 'routes.match',
      desc: "Route selector: \"/blog\" or \"example.com\" or \"example.com/blog\"",
      type: 'string',
    },
    {
      name: 'routes.uri',
      desc: "URI of the edge API resource",
      type: 'string',
    },
    {
      name: 'routes.description',
      desc: "human-readable description of what this edge will be used for; optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'routes.metadata',
      desc: "arbitrary user-defined machine-readable data of this edge. Optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'routes.backend.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'routes.backend.backend.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'routes.backend.backend.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'routes.ip_restriction.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'routes.ip_restriction.ip_policies.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'routes.ip_restriction.ip_policies.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'routes.circuit_breaker.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'routes.circuit_breaker.tripped_duration',
      desc: "Integer number of seconds after which the circuit is tripped to wait before re-evaluating upstream health",
      type: 'uint32',
    },
    {
      name: 'routes.circuit_breaker.rolling_window',
      desc: "Integer number of seconds in the statistical rolling window that metrics are retained for.",
      type: 'uint32',
    },
    {
      name: 'routes.circuit_breaker.num_buckets',
      desc: "Integer number of buckets into which metrics are retained. Max 128.",
      type: 'uint32',
    },
    {
      name: 'routes.circuit_breaker.volume_threshold',
      desc: "Integer number of requests in a rolling window that will trip the circuit. Helpful if traffic volume is low.",
      type: 'uint32',
    },
    {
      name: 'routes.circuit_breaker.error_threshold_percentage',
      desc: "Error threshold percentage should be between 0 - 1.0, not 0-100.0",
      type: 'float64',
    },
    {
      name: 'routes.compression.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'routes.request_headers.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'routes.request_headers.add',
      desc: "a map of header key to header value that will be injected into the HTTP Request before being sent to the upstream application server",
      type: 'Map<string, string>',
    },
    {
      name: 'routes.request_headers.remove',
      desc: "a list of header names that will be removed from the HTTP Request before being sent to the upstream application server",
      type: 'List<string>',
    },
    {
      name: 'routes.response_headers.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'routes.response_headers.add',
      desc: "a map of header key to header value that will be injected into the HTTP Response returned to the HTTP client",
      type: 'Map<string, string>',
    },
    {
      name: 'routes.response_headers.remove',
      desc: "a list of header names that will be removed from the HTTP Response returned to the HTTP client",
      type: 'List<string>',
    },
    {
      name: 'routes.webhook_verification.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'routes.webhook_verification.provider',
      desc: "a string indicating which webhook provider will be sending webhooks to this endpoint. Value must be one of the supported providers defined at https://ngrok.com/docs/cloud-edge#webhook-verification",
      type: 'string',
    },
    {
      name: 'routes.webhook_verification.secret',
      desc: "a string secret used to validate requests from the given provider. All providers except AWS SNS require a secret",
      type: 'string',
    },
    {
      name: 'routes.oauth.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'routes.oauth.provider.github.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'routes.oauth.provider.github.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'routes.oauth.provider.github.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'routes.oauth.provider.github.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'routes.oauth.provider.github.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'routes.oauth.provider.github.teams',
      desc: "a list of github teams identifiers. users will be allowed access to the endpoint if they are a member of any of these teams. identifiers should be in the 'slug' format qualified with the org name, e.g. `org-name/team-name`",
      type: 'List<string>',
    },
    {
      name: 'routes.oauth.provider.github.organizations',
      desc: "a list of github org identifiers. users who are members of any of the listed organizations will be allowed access. identifiers should be the organization's 'slug'",
      type: 'List<string>',
    },
    {
      name: 'routes.oauth.provider.facebook.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'routes.oauth.provider.facebook.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'routes.oauth.provider.facebook.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'routes.oauth.provider.facebook.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'routes.oauth.provider.facebook.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'routes.oauth.provider.microsoft.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'routes.oauth.provider.microsoft.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'routes.oauth.provider.microsoft.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'routes.oauth.provider.microsoft.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'routes.oauth.provider.microsoft.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'routes.oauth.provider.google.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'routes.oauth.provider.google.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'routes.oauth.provider.google.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'routes.oauth.provider.google.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'routes.oauth.provider.google.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'routes.oauth.provider.linkedin.client_id',
      desc: "",
      type: 'string',
    },
    {
      name: 'routes.oauth.provider.linkedin.client_secret',
      desc: "",
      type: 'string',
    },
    {
      name: 'routes.oauth.provider.linkedin.scopes',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'routes.oauth.provider.linkedin.email_addresses',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'routes.oauth.provider.linkedin.email_domains',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'routes.oauth.options_passthrough',
      desc: "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.",
      type: 'boolean',
    },
    {
      name: 'routes.oauth.cookie_prefix',
      desc: "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'",
      type: 'string',
    },
    {
      name: 'routes.oauth.inactivity_timeout',
      desc: "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'routes.oauth.maximum_duration',
      desc: "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'routes.oauth.auth_check_interval',
      desc: "Integer number of seconds after which ngrok guarantees it will refresh user state from the identity provider and recheck whether the user is still authorized to access the endpoint. This is the preferred tunable to use to enforce a minimum amount of time after which a revoked user will no longer be able to access the resource.",
      type: 'uint32',
    },
    {
      name: 'routes.saml.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'routes.saml.options_passthrough',
      desc: "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.",
      type: 'boolean',
    },
    {
      name: 'routes.saml.cookie_prefix',
      desc: "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'",
      type: 'string',
    },
    {
      name: 'routes.saml.inactivity_timeout',
      desc: "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'routes.saml.maximum_duration',
      desc: "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'routes.saml.idp_metadata',
      desc: "The full XML IdP EntityDescriptor. Your IdP may provide this to you as a a file to download or as a URL.",
      type: 'string',
    },
    {
      name: 'routes.saml.force_authn',
      desc: "If true, indicates that whenever we redirect a user to the IdP for authentication that the IdP must prompt the user for authentication credentials even if the user already has a valid session with the IdP.",
      type: 'boolean',
    },
    {
      name: 'routes.saml.allow_idp_initiated',
      desc: "If true, the IdP may initiate a login directly (e.g. the user does not need to visit the endpoint first and then be redirected). The IdP should set the `RelayState` parameter to the target URL of the resource they want the user to be redirected to after the SAML login assertion has been processed.",
      type: 'boolean',
    },
    {
      name: 'routes.saml.authorized_groups',
      desc: "If present, only users who are a member of one of the listed groups may access the target endpoint.",
      type: 'List<string>',
    },
    {
      name: 'routes.saml.entity_id',
      desc: "The SP Entity's unique ID. This always takes the form of a URL. In ngrok's implementation, this URL is the same as the metadata URL. This will need to be specified to the IdP as configuration.",
      type: 'string',
    },
    {
      name: 'routes.saml.assertion_consumer_service_url',
      desc: "The public URL of the SP's Assertion Consumer Service. This is where the IdP will redirect to during an authentication flow. This will need to be specified to the IdP as configuration.",
      type: 'string',
    },
    {
      name: 'routes.saml.single_logout_url',
      desc: "The public URL of the SP's Single Logout Service. This is where the IdP will redirect to during a single logout flow. This will optionally need to be specified to the IdP as configuration.",
      type: 'string',
    },
    {
      name: 'routes.saml.request_signing_certificate_pem',
      desc: "PEM-encoded x.509 certificate of the key pair that is used to sign all SAML requests that the ngrok SP makes to the IdP. Many IdPs do not support request signing verification, but we highly recommend specifying this in the IdP's configuration if it is supported.",
      type: 'string',
    },
    {
      name: 'routes.saml.metadata_url',
      desc: "A public URL where the SP's metadata is hosted. If an IdP supports dynamic configuration, this is the URL it can use to retrieve the SP metadata.",
      type: 'string',
    },
    {
      name: 'routes.saml.nameid_format',
      desc: "Defines the name identifier format the SP expects the IdP to use in its assertions to identify subjects. If unspecified, a default value of `urn:oasis:names:tc:SAML:2.0:nameid-format:persistent` will be used. A subset of the allowed values enumerated by the SAML specification are supported.",
      type: 'string',
    },
    {
      name: 'routes.oidc.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'routes.oidc.options_passthrough',
      desc: "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.",
      type: 'boolean',
    },
    {
      name: 'routes.oidc.cookie_prefix',
      desc: "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'",
      type: 'string',
    },
    {
      name: 'routes.oidc.inactivity_timeout',
      desc: "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'routes.oidc.maximum_duration',
      desc: "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'routes.oidc.issuer',
      desc: "URL of the OIDC \"OpenID provider\". This is the base URL used for discovery.",
      type: 'string',
    },
    {
      name: 'routes.oidc.client_id',
      desc: "The OIDC app's client ID and OIDC audience.",
      type: 'string',
    },
    {
      name: 'routes.oidc.client_secret',
      desc: "The OIDC app's client secret.",
      type: 'string',
    },
    {
      name: 'routes.oidc.scopes',
      desc: "The set of scopes to request from the OIDC identity provider.",
      type: 'List<string>',
    },
    {
      name: 'routes.websocket_tcp_converter.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    ],
  HTTPSEdgeCreate: [
    {
      name: 'description',
      desc: "human-readable description of what this edge will be used for; optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this edge; optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'hostports',
      desc: "hostports served by this edge",
      type: 'List<string>',
    },
    {
      name: 'mutual_tls.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'mutual_tls.certificate_authority_ids',
      desc: "list of certificate authorities that will be used to validate the TLS client certificate presented by the initiator of the TLS connection",
      type: 'List<string>',
    },
    {
      name: 'tls_termination.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'tls_termination.min_version',
      desc: "The minimum TLS version used for termination and advertised to the client during the TLS handshake. if unspecified, ngrok will choose an industry-safe default. This value must be null if `terminate_at` is set to `upstream`.",
      type: 'string',
    },
    ],
  HTTPSEdgeList: [
    {
      name: 'https_edges.id',
      desc: "unique identifier of this edge",
      type: 'string',
    },
    {
      name: 'https_edges.description',
      desc: "human-readable description of what this edge will be used for; optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'https_edges.metadata',
      desc: "arbitrary user-defined machine-readable data of this edge; optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'https_edges.created_at',
      desc: "timestamp when the edge configuration was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'https_edges.uri',
      desc: "URI of the edge API resource",
      type: 'string',
    },
    {
      name: 'https_edges.hostports',
      desc: "hostports served by this edge",
      type: 'List<string>',
    },
    {
      name: 'https_edges.mutual_tls.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'https_edges.mutual_tls.certificate_authorities.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'https_edges.mutual_tls.certificate_authorities.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'https_edges.tls_termination.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'https_edges.tls_termination.terminate_at',
      desc: "`edge` if the ngrok edge should terminate TLS traffic, `upstream` if TLS traffic should be passed through to the upstream ngrok agent / application server for termination. if `upstream` is chosen, most other modules will be disallowed because they rely on the ngrok edge being able to access the underlying traffic.",
      type: 'string',
    },
    {
      name: 'https_edges.tls_termination.min_version',
      desc: "The minimum TLS version used for termination and advertised to the client during the TLS handshake. if unspecified, ngrok will choose an industry-safe default. This value must be null if `terminate_at` is set to `upstream`.",
      type: 'string',
    },
    {
      name: 'https_edges.routes.edge_id',
      desc: "unique identifier of this edge",
      type: 'string',
    },
    {
      name: 'https_edges.routes.id',
      desc: "unique identifier of this edge route",
      type: 'string',
    },
    {
      name: 'https_edges.routes.created_at',
      desc: "timestamp when the edge configuration was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'https_edges.routes.match_type',
      desc: "Type of match to use for this route. Valid values are \"exact_path\" and \"path_prefix\".",
      type: 'string',
    },
    {
      name: 'https_edges.routes.match',
      desc: "Route selector: \"/blog\" or \"example.com\" or \"example.com/blog\"",
      type: 'string',
    },
    {
      name: 'https_edges.routes.uri',
      desc: "URI of the edge API resource",
      type: 'string',
    },
    {
      name: 'https_edges.routes.description',
      desc: "human-readable description of what this edge will be used for; optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'https_edges.routes.metadata',
      desc: "arbitrary user-defined machine-readable data of this edge. Optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'https_edges.routes.backend.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'https_edges.routes.backend.backend.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'https_edges.routes.backend.backend.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'https_edges.routes.ip_restriction.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'https_edges.routes.ip_restriction.ip_policies.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'https_edges.routes.ip_restriction.ip_policies.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'https_edges.routes.circuit_breaker.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'https_edges.routes.circuit_breaker.tripped_duration',
      desc: "Integer number of seconds after which the circuit is tripped to wait before re-evaluating upstream health",
      type: 'uint32',
    },
    {
      name: 'https_edges.routes.circuit_breaker.rolling_window',
      desc: "Integer number of seconds in the statistical rolling window that metrics are retained for.",
      type: 'uint32',
    },
    {
      name: 'https_edges.routes.circuit_breaker.num_buckets',
      desc: "Integer number of buckets into which metrics are retained. Max 128.",
      type: 'uint32',
    },
    {
      name: 'https_edges.routes.circuit_breaker.volume_threshold',
      desc: "Integer number of requests in a rolling window that will trip the circuit. Helpful if traffic volume is low.",
      type: 'uint32',
    },
    {
      name: 'https_edges.routes.circuit_breaker.error_threshold_percentage',
      desc: "Error threshold percentage should be between 0 - 1.0, not 0-100.0",
      type: 'float64',
    },
    {
      name: 'https_edges.routes.compression.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'https_edges.routes.request_headers.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'https_edges.routes.request_headers.add',
      desc: "a map of header key to header value that will be injected into the HTTP Request before being sent to the upstream application server",
      type: 'Map<string, string>',
    },
    {
      name: 'https_edges.routes.request_headers.remove',
      desc: "a list of header names that will be removed from the HTTP Request before being sent to the upstream application server",
      type: 'List<string>',
    },
    {
      name: 'https_edges.routes.response_headers.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'https_edges.routes.response_headers.add',
      desc: "a map of header key to header value that will be injected into the HTTP Response returned to the HTTP client",
      type: 'Map<string, string>',
    },
    {
      name: 'https_edges.routes.response_headers.remove',
      desc: "a list of header names that will be removed from the HTTP Response returned to the HTTP client",
      type: 'List<string>',
    },
    {
      name: 'https_edges.routes.webhook_verification.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'https_edges.routes.webhook_verification.provider',
      desc: "a string indicating which webhook provider will be sending webhooks to this endpoint. Value must be one of the supported providers defined at https://ngrok.com/docs/cloud-edge#webhook-verification",
      type: 'string',
    },
    {
      name: 'https_edges.routes.webhook_verification.secret',
      desc: "a string secret used to validate requests from the given provider. All providers except AWS SNS require a secret",
      type: 'string',
    },
    {
      name: 'https_edges.routes.oauth.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'https_edges.routes.oauth.provider.github.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'https_edges.routes.oauth.provider.github.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'https_edges.routes.oauth.provider.github.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'https_edges.routes.oauth.provider.github.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'https_edges.routes.oauth.provider.github.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'https_edges.routes.oauth.provider.github.teams',
      desc: "a list of github teams identifiers. users will be allowed access to the endpoint if they are a member of any of these teams. identifiers should be in the 'slug' format qualified with the org name, e.g. `org-name/team-name`",
      type: 'List<string>',
    },
    {
      name: 'https_edges.routes.oauth.provider.github.organizations',
      desc: "a list of github org identifiers. users who are members of any of the listed organizations will be allowed access. identifiers should be the organization's 'slug'",
      type: 'List<string>',
    },
    {
      name: 'https_edges.routes.oauth.provider.facebook.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'https_edges.routes.oauth.provider.facebook.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'https_edges.routes.oauth.provider.facebook.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'https_edges.routes.oauth.provider.facebook.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'https_edges.routes.oauth.provider.facebook.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'https_edges.routes.oauth.provider.microsoft.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'https_edges.routes.oauth.provider.microsoft.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'https_edges.routes.oauth.provider.microsoft.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'https_edges.routes.oauth.provider.microsoft.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'https_edges.routes.oauth.provider.microsoft.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'https_edges.routes.oauth.provider.google.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'https_edges.routes.oauth.provider.google.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'https_edges.routes.oauth.provider.google.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'https_edges.routes.oauth.provider.google.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'https_edges.routes.oauth.provider.google.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'https_edges.routes.oauth.provider.linkedin.client_id',
      desc: "",
      type: 'string',
    },
    {
      name: 'https_edges.routes.oauth.provider.linkedin.client_secret',
      desc: "",
      type: 'string',
    },
    {
      name: 'https_edges.routes.oauth.provider.linkedin.scopes',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'https_edges.routes.oauth.provider.linkedin.email_addresses',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'https_edges.routes.oauth.provider.linkedin.email_domains',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'https_edges.routes.oauth.options_passthrough',
      desc: "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.",
      type: 'boolean',
    },
    {
      name: 'https_edges.routes.oauth.cookie_prefix',
      desc: "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'",
      type: 'string',
    },
    {
      name: 'https_edges.routes.oauth.inactivity_timeout',
      desc: "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'https_edges.routes.oauth.maximum_duration',
      desc: "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'https_edges.routes.oauth.auth_check_interval',
      desc: "Integer number of seconds after which ngrok guarantees it will refresh user state from the identity provider and recheck whether the user is still authorized to access the endpoint. This is the preferred tunable to use to enforce a minimum amount of time after which a revoked user will no longer be able to access the resource.",
      type: 'uint32',
    },
    {
      name: 'https_edges.routes.saml.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'https_edges.routes.saml.options_passthrough',
      desc: "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.",
      type: 'boolean',
    },
    {
      name: 'https_edges.routes.saml.cookie_prefix',
      desc: "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'",
      type: 'string',
    },
    {
      name: 'https_edges.routes.saml.inactivity_timeout',
      desc: "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'https_edges.routes.saml.maximum_duration',
      desc: "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'https_edges.routes.saml.idp_metadata',
      desc: "The full XML IdP EntityDescriptor. Your IdP may provide this to you as a a file to download or as a URL.",
      type: 'string',
    },
    {
      name: 'https_edges.routes.saml.force_authn',
      desc: "If true, indicates that whenever we redirect a user to the IdP for authentication that the IdP must prompt the user for authentication credentials even if the user already has a valid session with the IdP.",
      type: 'boolean',
    },
    {
      name: 'https_edges.routes.saml.allow_idp_initiated',
      desc: "If true, the IdP may initiate a login directly (e.g. the user does not need to visit the endpoint first and then be redirected). The IdP should set the `RelayState` parameter to the target URL of the resource they want the user to be redirected to after the SAML login assertion has been processed.",
      type: 'boolean',
    },
    {
      name: 'https_edges.routes.saml.authorized_groups',
      desc: "If present, only users who are a member of one of the listed groups may access the target endpoint.",
      type: 'List<string>',
    },
    {
      name: 'https_edges.routes.saml.entity_id',
      desc: "The SP Entity's unique ID. This always takes the form of a URL. In ngrok's implementation, this URL is the same as the metadata URL. This will need to be specified to the IdP as configuration.",
      type: 'string',
    },
    {
      name: 'https_edges.routes.saml.assertion_consumer_service_url',
      desc: "The public URL of the SP's Assertion Consumer Service. This is where the IdP will redirect to during an authentication flow. This will need to be specified to the IdP as configuration.",
      type: 'string',
    },
    {
      name: 'https_edges.routes.saml.single_logout_url',
      desc: "The public URL of the SP's Single Logout Service. This is where the IdP will redirect to during a single logout flow. This will optionally need to be specified to the IdP as configuration.",
      type: 'string',
    },
    {
      name: 'https_edges.routes.saml.request_signing_certificate_pem',
      desc: "PEM-encoded x.509 certificate of the key pair that is used to sign all SAML requests that the ngrok SP makes to the IdP. Many IdPs do not support request signing verification, but we highly recommend specifying this in the IdP's configuration if it is supported.",
      type: 'string',
    },
    {
      name: 'https_edges.routes.saml.metadata_url',
      desc: "A public URL where the SP's metadata is hosted. If an IdP supports dynamic configuration, this is the URL it can use to retrieve the SP metadata.",
      type: 'string',
    },
    {
      name: 'https_edges.routes.saml.nameid_format',
      desc: "Defines the name identifier format the SP expects the IdP to use in its assertions to identify subjects. If unspecified, a default value of `urn:oasis:names:tc:SAML:2.0:nameid-format:persistent` will be used. A subset of the allowed values enumerated by the SAML specification are supported.",
      type: 'string',
    },
    {
      name: 'https_edges.routes.oidc.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'https_edges.routes.oidc.options_passthrough',
      desc: "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.",
      type: 'boolean',
    },
    {
      name: 'https_edges.routes.oidc.cookie_prefix',
      desc: "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'",
      type: 'string',
    },
    {
      name: 'https_edges.routes.oidc.inactivity_timeout',
      desc: "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'https_edges.routes.oidc.maximum_duration',
      desc: "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'https_edges.routes.oidc.issuer',
      desc: "URL of the OIDC \"OpenID provider\". This is the base URL used for discovery.",
      type: 'string',
    },
    {
      name: 'https_edges.routes.oidc.client_id',
      desc: "The OIDC app's client ID and OIDC audience.",
      type: 'string',
    },
    {
      name: 'https_edges.routes.oidc.client_secret',
      desc: "The OIDC app's client secret.",
      type: 'string',
    },
    {
      name: 'https_edges.routes.oidc.scopes',
      desc: "The set of scopes to request from the OIDC identity provider.",
      type: 'List<string>',
    },
    {
      name: 'https_edges.routes.websocket_tcp_converter.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'uri',
      desc: "URI of the HTTPS Edge list API resource",
      type: 'string',
    },
    {
      name: 'next_page_uri',
      desc: "URI of the next page, or null if there is no next page",
      type: 'string',
    },
    ],
  HTTPSEdgeRoute: [
    {
      name: 'edge_id',
      desc: "unique identifier of this edge",
      type: 'string',
    },
    {
      name: 'id',
      desc: "unique identifier of this edge route",
      type: 'string',
    },
    {
      name: 'created_at',
      desc: "timestamp when the edge configuration was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'match_type',
      desc: "Type of match to use for this route. Valid values are \"exact_path\" and \"path_prefix\".",
      type: 'string',
    },
    {
      name: 'match',
      desc: "Route selector: \"/blog\" or \"example.com\" or \"example.com/blog\"",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the edge API resource",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of what this edge will be used for; optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this edge. Optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'backend.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'backend.backend.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'backend.backend.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'ip_restriction.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'ip_restriction.ip_policies.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'ip_restriction.ip_policies.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'circuit_breaker.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'circuit_breaker.tripped_duration',
      desc: "Integer number of seconds after which the circuit is tripped to wait before re-evaluating upstream health",
      type: 'uint32',
    },
    {
      name: 'circuit_breaker.rolling_window',
      desc: "Integer number of seconds in the statistical rolling window that metrics are retained for.",
      type: 'uint32',
    },
    {
      name: 'circuit_breaker.num_buckets',
      desc: "Integer number of buckets into which metrics are retained. Max 128.",
      type: 'uint32',
    },
    {
      name: 'circuit_breaker.volume_threshold',
      desc: "Integer number of requests in a rolling window that will trip the circuit. Helpful if traffic volume is low.",
      type: 'uint32',
    },
    {
      name: 'circuit_breaker.error_threshold_percentage',
      desc: "Error threshold percentage should be between 0 - 1.0, not 0-100.0",
      type: 'float64',
    },
    {
      name: 'compression.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'request_headers.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'request_headers.add',
      desc: "a map of header key to header value that will be injected into the HTTP Request before being sent to the upstream application server",
      type: 'Map<string, string>',
    },
    {
      name: 'request_headers.remove',
      desc: "a list of header names that will be removed from the HTTP Request before being sent to the upstream application server",
      type: 'List<string>',
    },
    {
      name: 'response_headers.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'response_headers.add',
      desc: "a map of header key to header value that will be injected into the HTTP Response returned to the HTTP client",
      type: 'Map<string, string>',
    },
    {
      name: 'response_headers.remove',
      desc: "a list of header names that will be removed from the HTTP Response returned to the HTTP client",
      type: 'List<string>',
    },
    {
      name: 'webhook_verification.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'webhook_verification.provider',
      desc: "a string indicating which webhook provider will be sending webhooks to this endpoint. Value must be one of the supported providers defined at https://ngrok.com/docs/cloud-edge#webhook-verification",
      type: 'string',
    },
    {
      name: 'webhook_verification.secret',
      desc: "a string secret used to validate requests from the given provider. All providers except AWS SNS require a secret",
      type: 'string',
    },
    {
      name: 'oauth.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'oauth.provider.github.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'oauth.provider.github.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'oauth.provider.github.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.github.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.github.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.github.teams',
      desc: "a list of github teams identifiers. users will be allowed access to the endpoint if they are a member of any of these teams. identifiers should be in the 'slug' format qualified with the org name, e.g. `org-name/team-name`",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.github.organizations',
      desc: "a list of github org identifiers. users who are members of any of the listed organizations will be allowed access. identifiers should be the organization's 'slug'",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.facebook.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'oauth.provider.facebook.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'oauth.provider.facebook.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.facebook.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.facebook.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.microsoft.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'oauth.provider.microsoft.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'oauth.provider.microsoft.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.microsoft.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.microsoft.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.google.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'oauth.provider.google.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'oauth.provider.google.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.google.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.google.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.linkedin.client_id',
      desc: "",
      type: 'string',
    },
    {
      name: 'oauth.provider.linkedin.client_secret',
      desc: "",
      type: 'string',
    },
    {
      name: 'oauth.provider.linkedin.scopes',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.linkedin.email_addresses',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.linkedin.email_domains',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'oauth.options_passthrough',
      desc: "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.",
      type: 'boolean',
    },
    {
      name: 'oauth.cookie_prefix',
      desc: "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'",
      type: 'string',
    },
    {
      name: 'oauth.inactivity_timeout',
      desc: "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'oauth.maximum_duration',
      desc: "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'oauth.auth_check_interval',
      desc: "Integer number of seconds after which ngrok guarantees it will refresh user state from the identity provider and recheck whether the user is still authorized to access the endpoint. This is the preferred tunable to use to enforce a minimum amount of time after which a revoked user will no longer be able to access the resource.",
      type: 'uint32',
    },
    {
      name: 'saml.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'saml.options_passthrough',
      desc: "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.",
      type: 'boolean',
    },
    {
      name: 'saml.cookie_prefix',
      desc: "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'",
      type: 'string',
    },
    {
      name: 'saml.inactivity_timeout',
      desc: "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'saml.maximum_duration',
      desc: "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'saml.idp_metadata',
      desc: "The full XML IdP EntityDescriptor. Your IdP may provide this to you as a a file to download or as a URL.",
      type: 'string',
    },
    {
      name: 'saml.force_authn',
      desc: "If true, indicates that whenever we redirect a user to the IdP for authentication that the IdP must prompt the user for authentication credentials even if the user already has a valid session with the IdP.",
      type: 'boolean',
    },
    {
      name: 'saml.allow_idp_initiated',
      desc: "If true, the IdP may initiate a login directly (e.g. the user does not need to visit the endpoint first and then be redirected). The IdP should set the `RelayState` parameter to the target URL of the resource they want the user to be redirected to after the SAML login assertion has been processed.",
      type: 'boolean',
    },
    {
      name: 'saml.authorized_groups',
      desc: "If present, only users who are a member of one of the listed groups may access the target endpoint.",
      type: 'List<string>',
    },
    {
      name: 'saml.entity_id',
      desc: "The SP Entity's unique ID. This always takes the form of a URL. In ngrok's implementation, this URL is the same as the metadata URL. This will need to be specified to the IdP as configuration.",
      type: 'string',
    },
    {
      name: 'saml.assertion_consumer_service_url',
      desc: "The public URL of the SP's Assertion Consumer Service. This is where the IdP will redirect to during an authentication flow. This will need to be specified to the IdP as configuration.",
      type: 'string',
    },
    {
      name: 'saml.single_logout_url',
      desc: "The public URL of the SP's Single Logout Service. This is where the IdP will redirect to during a single logout flow. This will optionally need to be specified to the IdP as configuration.",
      type: 'string',
    },
    {
      name: 'saml.request_signing_certificate_pem',
      desc: "PEM-encoded x.509 certificate of the key pair that is used to sign all SAML requests that the ngrok SP makes to the IdP. Many IdPs do not support request signing verification, but we highly recommend specifying this in the IdP's configuration if it is supported.",
      type: 'string',
    },
    {
      name: 'saml.metadata_url',
      desc: "A public URL where the SP's metadata is hosted. If an IdP supports dynamic configuration, this is the URL it can use to retrieve the SP metadata.",
      type: 'string',
    },
    {
      name: 'saml.nameid_format',
      desc: "Defines the name identifier format the SP expects the IdP to use in its assertions to identify subjects. If unspecified, a default value of `urn:oasis:names:tc:SAML:2.0:nameid-format:persistent` will be used. A subset of the allowed values enumerated by the SAML specification are supported.",
      type: 'string',
    },
    {
      name: 'oidc.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'oidc.options_passthrough',
      desc: "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.",
      type: 'boolean',
    },
    {
      name: 'oidc.cookie_prefix',
      desc: "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'",
      type: 'string',
    },
    {
      name: 'oidc.inactivity_timeout',
      desc: "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'oidc.maximum_duration',
      desc: "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'oidc.issuer',
      desc: "URL of the OIDC \"OpenID provider\". This is the base URL used for discovery.",
      type: 'string',
    },
    {
      name: 'oidc.client_id',
      desc: "The OIDC app's client ID and OIDC audience.",
      type: 'string',
    },
    {
      name: 'oidc.client_secret',
      desc: "The OIDC app's client secret.",
      type: 'string',
    },
    {
      name: 'oidc.scopes',
      desc: "The set of scopes to request from the OIDC identity provider.",
      type: 'List<string>',
    },
    {
      name: 'websocket_tcp_converter.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    ],
  HTTPSEdgeRouteCreate: [
    {
      name: 'edge_id',
      desc: "unique identifier of this edge",
      type: 'string',
    },
    {
      name: 'match_type',
      desc: "Type of match to use for this route. Valid values are \"exact_path\" and \"path_prefix\".",
      type: 'string',
    },
    {
      name: 'match',
      desc: "Route selector: \"/blog\" or \"example.com\" or \"example.com/blog\"",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of what this edge will be used for; optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this edge. Optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'backend.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'backend.backend_id',
      desc: "backend to be used to back this endpoint",
      type: 'string',
    },
    {
      name: 'ip_restriction.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'ip_restriction.ip_policy_ids',
      desc: "list of all IP policies that will be used to check if a source IP is allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'circuit_breaker.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'circuit_breaker.tripped_duration',
      desc: "Integer number of seconds after which the circuit is tripped to wait before re-evaluating upstream health",
      type: 'uint32',
    },
    {
      name: 'circuit_breaker.rolling_window',
      desc: "Integer number of seconds in the statistical rolling window that metrics are retained for.",
      type: 'uint32',
    },
    {
      name: 'circuit_breaker.num_buckets',
      desc: "Integer number of buckets into which metrics are retained. Max 128.",
      type: 'uint32',
    },
    {
      name: 'circuit_breaker.volume_threshold',
      desc: "Integer number of requests in a rolling window that will trip the circuit. Helpful if traffic volume is low.",
      type: 'uint32',
    },
    {
      name: 'circuit_breaker.error_threshold_percentage',
      desc: "Error threshold percentage should be between 0 - 1.0, not 0-100.0",
      type: 'float64',
    },
    {
      name: 'compression.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'request_headers.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'request_headers.add',
      desc: "a map of header key to header value that will be injected into the HTTP Request before being sent to the upstream application server",
      type: 'Map<string, string>',
    },
    {
      name: 'request_headers.remove',
      desc: "a list of header names that will be removed from the HTTP Request before being sent to the upstream application server",
      type: 'List<string>',
    },
    {
      name: 'response_headers.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'response_headers.add',
      desc: "a map of header key to header value that will be injected into the HTTP Response returned to the HTTP client",
      type: 'Map<string, string>',
    },
    {
      name: 'response_headers.remove',
      desc: "a list of header names that will be removed from the HTTP Response returned to the HTTP client",
      type: 'List<string>',
    },
    {
      name: 'webhook_verification.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'webhook_verification.provider',
      desc: "a string indicating which webhook provider will be sending webhooks to this endpoint. Value must be one of the supported providers defined at https://ngrok.com/docs/cloud-edge#webhook-verification",
      type: 'string',
    },
    {
      name: 'webhook_verification.secret',
      desc: "a string secret used to validate requests from the given provider. All providers except AWS SNS require a secret",
      type: 'string',
    },
    {
      name: 'oauth.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'oauth.provider.github.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'oauth.provider.github.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'oauth.provider.github.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.github.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.github.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.github.teams',
      desc: "a list of github teams identifiers. users will be allowed access to the endpoint if they are a member of any of these teams. identifiers should be in the 'slug' format qualified with the org name, e.g. `org-name/team-name`",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.github.organizations',
      desc: "a list of github org identifiers. users who are members of any of the listed organizations will be allowed access. identifiers should be the organization's 'slug'",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.facebook.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'oauth.provider.facebook.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'oauth.provider.facebook.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.facebook.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.facebook.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.microsoft.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'oauth.provider.microsoft.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'oauth.provider.microsoft.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.microsoft.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.microsoft.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.google.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'oauth.provider.google.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'oauth.provider.google.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.google.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.google.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.linkedin.client_id',
      desc: "",
      type: 'string',
    },
    {
      name: 'oauth.provider.linkedin.client_secret',
      desc: "",
      type: 'string',
    },
    {
      name: 'oauth.provider.linkedin.scopes',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.linkedin.email_addresses',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.linkedin.email_domains',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'oauth.options_passthrough',
      desc: "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.",
      type: 'boolean',
    },
    {
      name: 'oauth.cookie_prefix',
      desc: "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'",
      type: 'string',
    },
    {
      name: 'oauth.inactivity_timeout',
      desc: "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'oauth.maximum_duration',
      desc: "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'oauth.auth_check_interval',
      desc: "Integer number of seconds after which ngrok guarantees it will refresh user state from the identity provider and recheck whether the user is still authorized to access the endpoint. This is the preferred tunable to use to enforce a minimum amount of time after which a revoked user will no longer be able to access the resource.",
      type: 'uint32',
    },
    {
      name: 'saml.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'saml.options_passthrough',
      desc: "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.",
      type: 'boolean',
    },
    {
      name: 'saml.cookie_prefix',
      desc: "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'",
      type: 'string',
    },
    {
      name: 'saml.inactivity_timeout',
      desc: "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'saml.maximum_duration',
      desc: "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'saml.idp_metadata',
      desc: "The full XML IdP EntityDescriptor. Your IdP may provide this to you as a a file to download or as a URL.",
      type: 'string',
    },
    {
      name: 'saml.force_authn',
      desc: "If true, indicates that whenever we redirect a user to the IdP for authentication that the IdP must prompt the user for authentication credentials even if the user already has a valid session with the IdP.",
      type: 'boolean',
    },
    {
      name: 'saml.allow_idp_initiated',
      desc: "If true, the IdP may initiate a login directly (e.g. the user does not need to visit the endpoint first and then be redirected). The IdP should set the `RelayState` parameter to the target URL of the resource they want the user to be redirected to after the SAML login assertion has been processed.",
      type: 'boolean',
    },
    {
      name: 'saml.authorized_groups',
      desc: "If present, only users who are a member of one of the listed groups may access the target endpoint.",
      type: 'List<string>',
    },
    {
      name: 'saml.nameid_format',
      desc: "Defines the name identifier format the SP expects the IdP to use in its assertions to identify subjects. If unspecified, a default value of `urn:oasis:names:tc:SAML:2.0:nameid-format:persistent` will be used. A subset of the allowed values enumerated by the SAML specification are supported.",
      type: 'string',
    },
    {
      name: 'oidc.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'oidc.options_passthrough',
      desc: "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.",
      type: 'boolean',
    },
    {
      name: 'oidc.cookie_prefix',
      desc: "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'",
      type: 'string',
    },
    {
      name: 'oidc.inactivity_timeout',
      desc: "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'oidc.maximum_duration',
      desc: "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'oidc.issuer',
      desc: "URL of the OIDC \"OpenID provider\". This is the base URL used for discovery.",
      type: 'string',
    },
    {
      name: 'oidc.client_id',
      desc: "The OIDC app's client ID and OIDC audience.",
      type: 'string',
    },
    {
      name: 'oidc.client_secret',
      desc: "The OIDC app's client secret.",
      type: 'string',
    },
    {
      name: 'oidc.scopes',
      desc: "The set of scopes to request from the OIDC identity provider.",
      type: 'List<string>',
    },
    {
      name: 'websocket_tcp_converter.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    ],
  HTTPSEdgeRouteUpdate: [
    {
      name: 'edge_id',
      desc: "unique identifier of this edge",
      type: 'string',
    },
    {
      name: 'id',
      desc: "unique identifier of this edge route",
      type: 'string',
    },
    {
      name: 'match_type',
      desc: "Type of match to use for this route. Valid values are \"exact_path\" and \"path_prefix\".",
      type: 'string',
    },
    {
      name: 'match',
      desc: "Route selector: \"/blog\" or \"example.com\" or \"example.com/blog\"",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of what this edge will be used for; optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this edge. Optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'backend.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'backend.backend_id',
      desc: "backend to be used to back this endpoint",
      type: 'string',
    },
    {
      name: 'ip_restriction.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'ip_restriction.ip_policy_ids',
      desc: "list of all IP policies that will be used to check if a source IP is allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'circuit_breaker.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'circuit_breaker.tripped_duration',
      desc: "Integer number of seconds after which the circuit is tripped to wait before re-evaluating upstream health",
      type: 'uint32',
    },
    {
      name: 'circuit_breaker.rolling_window',
      desc: "Integer number of seconds in the statistical rolling window that metrics are retained for.",
      type: 'uint32',
    },
    {
      name: 'circuit_breaker.num_buckets',
      desc: "Integer number of buckets into which metrics are retained. Max 128.",
      type: 'uint32',
    },
    {
      name: 'circuit_breaker.volume_threshold',
      desc: "Integer number of requests in a rolling window that will trip the circuit. Helpful if traffic volume is low.",
      type: 'uint32',
    },
    {
      name: 'circuit_breaker.error_threshold_percentage',
      desc: "Error threshold percentage should be between 0 - 1.0, not 0-100.0",
      type: 'float64',
    },
    {
      name: 'compression.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'request_headers.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'request_headers.add',
      desc: "a map of header key to header value that will be injected into the HTTP Request before being sent to the upstream application server",
      type: 'Map<string, string>',
    },
    {
      name: 'request_headers.remove',
      desc: "a list of header names that will be removed from the HTTP Request before being sent to the upstream application server",
      type: 'List<string>',
    },
    {
      name: 'response_headers.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'response_headers.add',
      desc: "a map of header key to header value that will be injected into the HTTP Response returned to the HTTP client",
      type: 'Map<string, string>',
    },
    {
      name: 'response_headers.remove',
      desc: "a list of header names that will be removed from the HTTP Response returned to the HTTP client",
      type: 'List<string>',
    },
    {
      name: 'webhook_verification.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'webhook_verification.provider',
      desc: "a string indicating which webhook provider will be sending webhooks to this endpoint. Value must be one of the supported providers defined at https://ngrok.com/docs/cloud-edge#webhook-verification",
      type: 'string',
    },
    {
      name: 'webhook_verification.secret',
      desc: "a string secret used to validate requests from the given provider. All providers except AWS SNS require a secret",
      type: 'string',
    },
    {
      name: 'oauth.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'oauth.provider.github.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'oauth.provider.github.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'oauth.provider.github.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.github.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.github.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.github.teams',
      desc: "a list of github teams identifiers. users will be allowed access to the endpoint if they are a member of any of these teams. identifiers should be in the 'slug' format qualified with the org name, e.g. `org-name/team-name`",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.github.organizations',
      desc: "a list of github org identifiers. users who are members of any of the listed organizations will be allowed access. identifiers should be the organization's 'slug'",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.facebook.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'oauth.provider.facebook.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'oauth.provider.facebook.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.facebook.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.facebook.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.microsoft.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'oauth.provider.microsoft.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'oauth.provider.microsoft.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.microsoft.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.microsoft.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.google.client_id',
      desc: "the OAuth app client ID. retrieve it from the identity provider's dashboard where you created your own OAuth app. optional. if unspecified, ngrok will use its own managed oauth application which has additional restrictions. see the OAuth module docs for more details. if present, client_secret must be present as well.",
      type: 'string',
    },
    {
      name: 'oauth.provider.google.client_secret',
      desc: "the OAuth app client secret. retrieve if from the identity provider's dashboard where you created your own OAuth app. optional, see all of the caveats in the docs for `client_id`.",
      type: 'string',
    },
    {
      name: 'oauth.provider.google.scopes',
      desc: "a list of provider-specific OAuth scopes with the permissions your OAuth app would like to ask for. these may not be set if you are using the ngrok-managed oauth app (i.e. you must pass both `client_id` and `client_secret` to set scopes)",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.google.email_addresses',
      desc: "a list of email addresses of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.google.email_domains',
      desc: "a list of email domains of users authenticated by identity provider who are allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.linkedin.client_id',
      desc: "",
      type: 'string',
    },
    {
      name: 'oauth.provider.linkedin.client_secret',
      desc: "",
      type: 'string',
    },
    {
      name: 'oauth.provider.linkedin.scopes',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.linkedin.email_addresses',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'oauth.provider.linkedin.email_domains',
      desc: "",
      type: 'List<string>',
    },
    {
      name: 'oauth.options_passthrough',
      desc: "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.",
      type: 'boolean',
    },
    {
      name: 'oauth.cookie_prefix',
      desc: "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'",
      type: 'string',
    },
    {
      name: 'oauth.inactivity_timeout',
      desc: "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'oauth.maximum_duration',
      desc: "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'oauth.auth_check_interval',
      desc: "Integer number of seconds after which ngrok guarantees it will refresh user state from the identity provider and recheck whether the user is still authorized to access the endpoint. This is the preferred tunable to use to enforce a minimum amount of time after which a revoked user will no longer be able to access the resource.",
      type: 'uint32',
    },
    {
      name: 'saml.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'saml.options_passthrough',
      desc: "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.",
      type: 'boolean',
    },
    {
      name: 'saml.cookie_prefix',
      desc: "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'",
      type: 'string',
    },
    {
      name: 'saml.inactivity_timeout',
      desc: "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'saml.maximum_duration',
      desc: "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'saml.idp_metadata',
      desc: "The full XML IdP EntityDescriptor. Your IdP may provide this to you as a a file to download or as a URL.",
      type: 'string',
    },
    {
      name: 'saml.force_authn',
      desc: "If true, indicates that whenever we redirect a user to the IdP for authentication that the IdP must prompt the user for authentication credentials even if the user already has a valid session with the IdP.",
      type: 'boolean',
    },
    {
      name: 'saml.allow_idp_initiated',
      desc: "If true, the IdP may initiate a login directly (e.g. the user does not need to visit the endpoint first and then be redirected). The IdP should set the `RelayState` parameter to the target URL of the resource they want the user to be redirected to after the SAML login assertion has been processed.",
      type: 'boolean',
    },
    {
      name: 'saml.authorized_groups',
      desc: "If present, only users who are a member of one of the listed groups may access the target endpoint.",
      type: 'List<string>',
    },
    {
      name: 'saml.nameid_format',
      desc: "Defines the name identifier format the SP expects the IdP to use in its assertions to identify subjects. If unspecified, a default value of `urn:oasis:names:tc:SAML:2.0:nameid-format:persistent` will be used. A subset of the allowed values enumerated by the SAML specification are supported.",
      type: 'string',
    },
    {
      name: 'oidc.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'oidc.options_passthrough',
      desc: "Do not enforce authentication on HTTP OPTIONS requests. necessary if you are supporting CORS.",
      type: 'boolean',
    },
    {
      name: 'oidc.cookie_prefix',
      desc: "the prefix of the session cookie that ngrok sets on the http client to cache authentication. default is 'ngrok.'",
      type: 'string',
    },
    {
      name: 'oidc.inactivity_timeout',
      desc: "Integer number of seconds of inactivity after which if the user has not accessed the endpoint, their session will time out and they will be forced to reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'oidc.maximum_duration',
      desc: "Integer number of seconds of the maximum duration of an authenticated session. After this period is exceeded, a user must reauthenticate.",
      type: 'uint32',
    },
    {
      name: 'oidc.issuer',
      desc: "URL of the OIDC \"OpenID provider\". This is the base URL used for discovery.",
      type: 'string',
    },
    {
      name: 'oidc.client_id',
      desc: "The OIDC app's client ID and OIDC audience.",
      type: 'string',
    },
    {
      name: 'oidc.client_secret',
      desc: "The OIDC app's client secret.",
      type: 'string',
    },
    {
      name: 'oidc.scopes',
      desc: "The set of scopes to request from the OIDC identity provider.",
      type: 'List<string>',
    },
    {
      name: 'websocket_tcp_converter.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    ],
  HTTPSEdgeUpdate: [
    {
      name: 'id',
      desc: "unique identifier of this edge",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of what this edge will be used for; optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this edge; optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'hostports',
      desc: "hostports served by this edge",
      type: 'List<string>',
    },
    {
      name: 'mutual_tls.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'mutual_tls.certificate_authority_ids',
      desc: "list of certificate authorities that will be used to validate the TLS client certificate presented by the initiator of the TLS connection",
      type: 'List<string>',
    },
    {
      name: 'tls_termination.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'tls_termination.min_version',
      desc: "The minimum TLS version used for termination and advertised to the client during the TLS handshake. if unspecified, ngrok will choose an industry-safe default. This value must be null if `terminate_at` is set to `upstream`.",
      type: 'string',
    },
    ],
  IPPolicy: [
    {
      name: 'id',
      desc: "unique identifier for this IP policy",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the IP Policy API resource",
      type: 'string',
    },
    {
      name: 'created_at',
      desc: "timestamp when the IP policy was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of the source IPs of this IP policy. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this IP policy. optional, max 4096 bytes.",
      type: 'string',
    },
    ],
  IPPolicyCreate: [
    {
      name: 'description',
      desc: "human-readable description of the source IPs of this IP policy. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this IP policy. optional, max 4096 bytes.",
      type: 'string',
    },
    ],
  IPPolicyList: [
    {
      name: 'ip_policies.id',
      desc: "unique identifier for this IP policy",
      type: 'string',
    },
    {
      name: 'ip_policies.uri',
      desc: "URI of the IP Policy API resource",
      type: 'string',
    },
    {
      name: 'ip_policies.created_at',
      desc: "timestamp when the IP policy was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'ip_policies.description',
      desc: "human-readable description of the source IPs of this IP policy. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'ip_policies.metadata',
      desc: "arbitrary user-defined machine-readable data of this IP policy. optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the IP policy list API resource",
      type: 'string',
    },
    {
      name: 'next_page_uri',
      desc: "URI of the next page, or null if there is no next page",
      type: 'string',
    },
    ],
  IPPolicyRule: [
    {
      name: 'id',
      desc: "unique identifier for this IP policy rule",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the IP policy rule API resource",
      type: 'string',
    },
    {
      name: 'created_at',
      desc: "timestamp when the IP policy rule was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of the source IPs of this IP rule. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this IP policy rule. optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'cidr',
      desc: "an IP or IP range specified in CIDR notation. IPv4 and IPv6 are both supported.",
      type: 'string',
    },
    {
      name: 'ip_policy.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'ip_policy.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'action',
      desc: "the action to apply to the policy rule, either `allow` or `deny`",
      type: 'string',
    },
    ],
  IPPolicyRuleCreate: [
    {
      name: 'description',
      desc: "human-readable description of the source IPs of this IP rule. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this IP policy rule. optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'cidr',
      desc: "an IP or IP range specified in CIDR notation. IPv4 and IPv6 are both supported.",
      type: 'string',
    },
    {
      name: 'ip_policy_id',
      desc: "ID of the IP policy this IP policy rule will be attached to",
      type: 'string',
    },
    {
      name: 'action',
      desc: "the action to apply to the policy rule, either `allow` or `deny`",
      type: 'string',
    },
    ],
  IPPolicyRuleList: [
    {
      name: 'ip_policy_rules.id',
      desc: "unique identifier for this IP policy rule",
      type: 'string',
    },
    {
      name: 'ip_policy_rules.uri',
      desc: "URI of the IP policy rule API resource",
      type: 'string',
    },
    {
      name: 'ip_policy_rules.created_at',
      desc: "timestamp when the IP policy rule was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'ip_policy_rules.description',
      desc: "human-readable description of the source IPs of this IP rule. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'ip_policy_rules.metadata',
      desc: "arbitrary user-defined machine-readable data of this IP policy rule. optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'ip_policy_rules.cidr',
      desc: "an IP or IP range specified in CIDR notation. IPv4 and IPv6 are both supported.",
      type: 'string',
    },
    {
      name: 'ip_policy_rules.ip_policy.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'ip_policy_rules.ip_policy.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'ip_policy_rules.action',
      desc: "the action to apply to the policy rule, either `allow` or `deny`",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the IP policy rule list API resource",
      type: 'string',
    },
    {
      name: 'next_page_uri',
      desc: "URI of the next page, or null if there is no next page",
      type: 'string',
    },
    ],
  IPPolicyRuleUpdate: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of the source IPs of this IP rule. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this IP policy rule. optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'cidr',
      desc: "an IP or IP range specified in CIDR notation. IPv4 and IPv6 are both supported.",
      type: 'string',
    },
    ],
  IPPolicyUpdate: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of the source IPs of this IP policy. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this IP policy. optional, max 4096 bytes.",
      type: 'string',
    },
    ],
  IPRestriction: [
    {
      name: 'id',
      desc: "unique identifier for this IP restriction",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the IP restriction API resource",
      type: 'string',
    },
    {
      name: 'created_at',
      desc: "timestamp when the IP restriction was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of this IP restriction. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this IP restriction. optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'enforced',
      desc: "true if the IP restriction will be enforced. if false, only warnings will be issued",
      type: 'boolean',
    },
    {
      name: 'type',
      desc: "the type of IP restriction. this defines what traffic will be restricted with the attached policies. four values are currently supported: `dashboard`, `api`, `agent`, and `endpoints`",
      type: 'string',
    },
    {
      name: 'ip_policies.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'ip_policies.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    ],
  IPRestrictionCreate: [
    {
      name: 'description',
      desc: "human-readable description of this IP restriction. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this IP restriction. optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'enforced',
      desc: "true if the IP restriction will be enforced. if false, only warnings will be issued",
      type: 'boolean',
    },
    {
      name: 'type',
      desc: "the type of IP restriction. this defines what traffic will be restricted with the attached policies. four values are currently supported: `dashboard`, `api`, `agent`, and `endpoints`",
      type: 'string',
    },
    {
      name: 'ip_policy_ids',
      desc: "the set of IP policy identifiers that are used to enforce the restriction",
      type: 'List<string>',
    },
    ],
  IPRestrictionList: [
    {
      name: 'ip_restrictions.id',
      desc: "unique identifier for this IP restriction",
      type: 'string',
    },
    {
      name: 'ip_restrictions.uri',
      desc: "URI of the IP restriction API resource",
      type: 'string',
    },
    {
      name: 'ip_restrictions.created_at',
      desc: "timestamp when the IP restriction was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'ip_restrictions.description',
      desc: "human-readable description of this IP restriction. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'ip_restrictions.metadata',
      desc: "arbitrary user-defined machine-readable data of this IP restriction. optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'ip_restrictions.enforced',
      desc: "true if the IP restriction will be enforced. if false, only warnings will be issued",
      type: 'boolean',
    },
    {
      name: 'ip_restrictions.type',
      desc: "the type of IP restriction. this defines what traffic will be restricted with the attached policies. four values are currently supported: `dashboard`, `api`, `agent`, and `endpoints`",
      type: 'string',
    },
    {
      name: 'ip_restrictions.ip_policies.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'ip_restrictions.ip_policies.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the IP restrictions list API resource",
      type: 'string',
    },
    {
      name: 'next_page_uri',
      desc: "URI of the next page, or null if there is no next page",
      type: 'string',
    },
    ],
  IPRestrictionUpdate: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of this IP restriction. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this IP restriction. optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'enforced',
      desc: "true if the IP restriction will be enforced. if false, only warnings will be issued",
      type: 'boolean',
    },
    {
      name: 'ip_policy_ids',
      desc: "the set of IP policy identifiers that are used to enforce the restriction",
      type: 'List<string>',
    },
    ],
  IdentityProvider: [
    {
      name: 'name',
      desc: "name of the identity provider (e.g. Google)",
      type: 'string',
    },
    {
      name: 'url',
      desc: "URL of the identity provider (e.g. https://accounts.google.com)",
      type: 'string',
    },
    ],
  Item: [
    {
      name: 'id',
      desc: "a resource identifier",
      type: 'string',
    },
    ],
  Location: [
    {
      name: 'country_code',
      desc: "ISO country code",
      type: 'string',
    },
    {
      name: 'latitude',
      desc: "geographical latitude",
      type: 'float64',
    },
    {
      name: 'longitude',
      desc: "geographical longitude",
      type: 'float64',
    },
    {
      name: 'lat_long_radius_km',
      desc: "accuracy radius of the geographical coordinates",
      type: 'uint64',
    },
    ],
  Paging: [
    {
      name: 'before_id',
      desc: "",
      type: 'string',
    },
    {
      name: 'limit',
      desc: "",
      type: 'string',
    },
    ],
  Ref: [
    {
      name: 'id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    ],
  ReservedAddr: [
    {
      name: 'id',
      desc: "unique reserved address resource identifier",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the reserved address API resource",
      type: 'string',
    },
    {
      name: 'created_at',
      desc: "timestamp when the reserved address was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of what this reserved address will be used for",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this reserved address. Optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'addr',
      desc: "hostname:port of the reserved address that was assigned at creation time",
      type: 'string',
    },
    {
      name: 'region',
      desc: "reserve the address in this geographic ngrok datacenter. Optional, default is us. (au, eu, ap, us, jp, in, sa)",
      type: 'string',
    },
    ],
  ReservedAddrCreate: [
    {
      name: 'description',
      desc: "human-readable description of what this reserved address will be used for",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this reserved address. Optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'region',
      desc: "reserve the address in this geographic ngrok datacenter. Optional, default is us. (au, eu, ap, us, jp, in, sa)",
      type: 'string',
    },
    ],
  ReservedAddrList: [
    {
      name: 'reserved_addrs.id',
      desc: "unique reserved address resource identifier",
      type: 'string',
    },
    {
      name: 'reserved_addrs.uri',
      desc: "URI of the reserved address API resource",
      type: 'string',
    },
    {
      name: 'reserved_addrs.created_at',
      desc: "timestamp when the reserved address was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'reserved_addrs.description',
      desc: "human-readable description of what this reserved address will be used for",
      type: 'string',
    },
    {
      name: 'reserved_addrs.metadata',
      desc: "arbitrary user-defined machine-readable data of this reserved address. Optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'reserved_addrs.addr',
      desc: "hostname:port of the reserved address that was assigned at creation time",
      type: 'string',
    },
    {
      name: 'reserved_addrs.region',
      desc: "reserve the address in this geographic ngrok datacenter. Optional, default is us. (au, eu, ap, us, jp, in, sa)",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the reserved address list API resource",
      type: 'string',
    },
    {
      name: 'next_page_uri',
      desc: "URI of the next page, or null if there is no next page",
      type: 'string',
    },
    ],
  ReservedAddrUpdate: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of what this reserved address will be used for",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this reserved address. Optional, max 4096 bytes.",
      type: 'string',
    },
    ],
  ReservedDomain: [
    {
      name: 'id',
      desc: "unique reserved domain resource identifier",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the reserved domain API resource",
      type: 'string',
    },
    {
      name: 'created_at',
      desc: "timestamp when the reserved domain was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of what this reserved domain will be used for",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this reserved domain. Optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'domain',
      desc: "hostname of the reserved domain",
      type: 'string',
    },
    {
      name: 'region',
      desc: "reserve the domain in this geographic ngrok datacenter. Optional, default is us. (au, eu, ap, us, jp, in, sa)",
      type: 'string',
    },
    {
      name: 'cname_target',
      desc: "DNS CNAME target for a custom hostname, or null if the reserved domain is a subdomain of *.ngrok.io",
      type: 'string',
    },
    {
      name: 'certificate.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'certificate.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'certificate_management_policy.authority',
      desc: "certificate authority to request certificates from. The only supported value is letsencrypt.",
      type: 'string',
    },
    {
      name: 'certificate_management_policy.private_key_type',
      desc: "type of private key to use when requesting certificates. Defaults to rsa, can be either rsa or ecdsa.",
      type: 'string',
    },
    {
      name: 'certificate_management_status.renews_at',
      desc: "timestamp when the next renewal will be requested, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'certificate_management_status.provisioning_job.error_code',
      desc: "if present, an error code indicating why provisioning is failing. It may be either a temporary condition (INTERNAL_ERROR), or a permanent one the user must correct (DNS_ERROR).",
      type: 'string',
    },
    {
      name: 'certificate_management_status.provisioning_job.msg',
      desc: "a message describing the current status or error",
      type: 'string',
    },
    {
      name: 'certificate_management_status.provisioning_job.started_at',
      desc: "timestamp when the provisioning job started, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'certificate_management_status.provisioning_job.retries_at',
      desc: "timestamp when the provisioning job will be retried",
      type: 'string',
    },
    {
      name: 'acme_challenge_cname_target',
      desc: "DNS CNAME target for the host _acme-challenge.example.com, where example.com is your reserved domain name. This is required to issue certificates for wildcard, non-ngrok reserved domains. Must be null for non-wildcard domains and ngrok subdomains.",
      type: 'string',
    },
    ],
  ReservedDomainCertJob: [
    {
      name: 'error_code',
      desc: "if present, an error code indicating why provisioning is failing. It may be either a temporary condition (INTERNAL_ERROR), or a permanent one the user must correct (DNS_ERROR).",
      type: 'string',
    },
    {
      name: 'msg',
      desc: "a message describing the current status or error",
      type: 'string',
    },
    {
      name: 'started_at',
      desc: "timestamp when the provisioning job started, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'retries_at',
      desc: "timestamp when the provisioning job will be retried",
      type: 'string',
    },
    ],
  ReservedDomainCertPolicy: [
    {
      name: 'authority',
      desc: "certificate authority to request certificates from. The only supported value is letsencrypt.",
      type: 'string',
    },
    {
      name: 'private_key_type',
      desc: "type of private key to use when requesting certificates. Defaults to rsa, can be either rsa or ecdsa.",
      type: 'string',
    },
    ],
  ReservedDomainCertStatus: [
    {
      name: 'renews_at',
      desc: "timestamp when the next renewal will be requested, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'provisioning_job.error_code',
      desc: "if present, an error code indicating why provisioning is failing. It may be either a temporary condition (INTERNAL_ERROR), or a permanent one the user must correct (DNS_ERROR).",
      type: 'string',
    },
    {
      name: 'provisioning_job.msg',
      desc: "a message describing the current status or error",
      type: 'string',
    },
    {
      name: 'provisioning_job.started_at',
      desc: "timestamp when the provisioning job started, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'provisioning_job.retries_at',
      desc: "timestamp when the provisioning job will be retried",
      type: 'string',
    },
    ],
  ReservedDomainCreate: [
    {
      name: 'name',
      desc: "the domain name to reserve. It may be a full domain name like app.example.com. If the name does not contain a '.' it will reserve that subdomain on ngrok.io.",
      type: 'string',
    },
    {
      name: 'region',
      desc: "reserve the domain in this geographic ngrok datacenter. Optional, default is us. (au, eu, ap, us, jp, in, sa)",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of what this reserved domain will be used for",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this reserved domain. Optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'certificate_id',
      desc: "ID of a user-uploaded TLS certificate to use for connections to targeting this domain. Optional, mutually exclusive with `certificate_management_policy`.",
      type: 'string',
    },
    {
      name: 'certificate_management_policy.authority',
      desc: "certificate authority to request certificates from. The only supported value is letsencrypt.",
      type: 'string',
    },
    {
      name: 'certificate_management_policy.private_key_type',
      desc: "type of private key to use when requesting certificates. Defaults to rsa, can be either rsa or ecdsa.",
      type: 'string',
    },
    ],
  ReservedDomainList: [
    {
      name: 'reserved_domains.id',
      desc: "unique reserved domain resource identifier",
      type: 'string',
    },
    {
      name: 'reserved_domains.uri',
      desc: "URI of the reserved domain API resource",
      type: 'string',
    },
    {
      name: 'reserved_domains.created_at',
      desc: "timestamp when the reserved domain was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'reserved_domains.description',
      desc: "human-readable description of what this reserved domain will be used for",
      type: 'string',
    },
    {
      name: 'reserved_domains.metadata',
      desc: "arbitrary user-defined machine-readable data of this reserved domain. Optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'reserved_domains.domain',
      desc: "hostname of the reserved domain",
      type: 'string',
    },
    {
      name: 'reserved_domains.region',
      desc: "reserve the domain in this geographic ngrok datacenter. Optional, default is us. (au, eu, ap, us, jp, in, sa)",
      type: 'string',
    },
    {
      name: 'reserved_domains.cname_target',
      desc: "DNS CNAME target for a custom hostname, or null if the reserved domain is a subdomain of *.ngrok.io",
      type: 'string',
    },
    {
      name: 'reserved_domains.certificate.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'reserved_domains.certificate.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'reserved_domains.certificate_management_policy.authority',
      desc: "certificate authority to request certificates from. The only supported value is letsencrypt.",
      type: 'string',
    },
    {
      name: 'reserved_domains.certificate_management_policy.private_key_type',
      desc: "type of private key to use when requesting certificates. Defaults to rsa, can be either rsa or ecdsa.",
      type: 'string',
    },
    {
      name: 'reserved_domains.certificate_management_status.renews_at',
      desc: "timestamp when the next renewal will be requested, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'reserved_domains.certificate_management_status.provisioning_job.error_code',
      desc: "if present, an error code indicating why provisioning is failing. It may be either a temporary condition (INTERNAL_ERROR), or a permanent one the user must correct (DNS_ERROR).",
      type: 'string',
    },
    {
      name: 'reserved_domains.certificate_management_status.provisioning_job.msg',
      desc: "a message describing the current status or error",
      type: 'string',
    },
    {
      name: 'reserved_domains.certificate_management_status.provisioning_job.started_at',
      desc: "timestamp when the provisioning job started, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'reserved_domains.certificate_management_status.provisioning_job.retries_at',
      desc: "timestamp when the provisioning job will be retried",
      type: 'string',
    },
    {
      name: 'reserved_domains.acme_challenge_cname_target',
      desc: "DNS CNAME target for the host _acme-challenge.example.com, where example.com is your reserved domain name. This is required to issue certificates for wildcard, non-ngrok reserved domains. Must be null for non-wildcard domains and ngrok subdomains.",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the reserved domain list API resource",
      type: 'string',
    },
    {
      name: 'next_page_uri',
      desc: "URI of the next page, or null if there is no next page",
      type: 'string',
    },
    ],
  ReservedDomainUpdate: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of what this reserved domain will be used for",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this reserved domain. Optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'certificate_id',
      desc: "ID of a user-uploaded TLS certificate to use for connections to targeting this domain. Optional, mutually exclusive with `certificate_management_policy`.",
      type: 'string',
    },
    {
      name: 'certificate_management_policy.authority',
      desc: "certificate authority to request certificates from. The only supported value is letsencrypt.",
      type: 'string',
    },
    {
      name: 'certificate_management_policy.private_key_type',
      desc: "type of private key to use when requesting certificates. Defaults to rsa, can be either rsa or ecdsa.",
      type: 'string',
    },
    ],
  RootResponse: [
    {
      name: 'uri',
      desc: "",
      type: 'string',
    },
    {
      name: 'subresource_uris',
      desc: "",
      type: 'Map<string, string>',
    },
    ],
  SSHCertificateAuthority: [
    {
      name: 'id',
      desc: "unique identifier for this SSH Certificate Authority",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the SSH Certificate Authority API resource",
      type: 'string',
    },
    {
      name: 'created_at',
      desc: "timestamp when the SSH Certificate Authority API resource was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of this SSH Certificate Authority. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this SSH Certificate Authority. optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'public_key',
      desc: "raw public key for this SSH Certificate Authority",
      type: 'string',
    },
    {
      name: 'key_type',
      desc: "the type of private key for this SSH Certificate Authority",
      type: 'string',
    },
    ],
  SSHCertificateAuthorityCreate: [
    {
      name: 'description',
      desc: "human-readable description of this SSH Certificate Authority. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this SSH Certificate Authority. optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'private_key_type',
      desc: "the type of private key to generate. one of `rsa`, `ecdsa`, `ed25519`",
      type: 'string',
    },
    {
      name: 'elliptic_curve',
      desc: "the type of elliptic curve to use when creating an ECDSA key",
      type: 'string',
    },
    {
      name: 'key_size',
      desc: "the key size to use when creating an RSA key. one of `2048` or `4096`",
      type: 'int64',
    },
    ],
  SSHCertificateAuthorityList: [
    {
      name: 'ssh_certificate_authorities.id',
      desc: "unique identifier for this SSH Certificate Authority",
      type: 'string',
    },
    {
      name: 'ssh_certificate_authorities.uri',
      desc: "URI of the SSH Certificate Authority API resource",
      type: 'string',
    },
    {
      name: 'ssh_certificate_authorities.created_at',
      desc: "timestamp when the SSH Certificate Authority API resource was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'ssh_certificate_authorities.description',
      desc: "human-readable description of this SSH Certificate Authority. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'ssh_certificate_authorities.metadata',
      desc: "arbitrary user-defined machine-readable data of this SSH Certificate Authority. optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'ssh_certificate_authorities.public_key',
      desc: "raw public key for this SSH Certificate Authority",
      type: 'string',
    },
    {
      name: 'ssh_certificate_authorities.key_type',
      desc: "the type of private key for this SSH Certificate Authority",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the certificates authorities list API resource",
      type: 'string',
    },
    {
      name: 'next_page_uri',
      desc: "URI of the next page, or null if there is no next page",
      type: 'string',
    },
    ],
  SSHCertificateAuthorityUpdate: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of this SSH Certificate Authority. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this SSH Certificate Authority. optional, max 4096 bytes.",
      type: 'string',
    },
    ],
  SSHCredential: [
    {
      name: 'id',
      desc: "unique ssh credential resource identifier",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the ssh credential API resource",
      type: 'string',
    },
    {
      name: 'created_at',
      desc: "timestamp when the ssh credential was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of who or what will use the ssh credential to authenticate. Optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this ssh credential. Optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'public_key',
      desc: "the PEM-encoded public key of the SSH keypair that will be used to authenticate",
      type: 'string',
    },
    {
      name: 'acl',
      desc: "optional list of ACL rules. If unspecified, the credential will have no restrictions. The only allowed ACL rule at this time is the `bind` rule. The `bind` rule allows the caller to restrict what domains, addresses, and labels the token is allowed to bind. For example, to allow the token to open a tunnel on example.ngrok.io your ACL would include the rule `bind:example.ngrok.io`. Bind rules for domains may specify a leading wildcard to match multiple domains with a common suffix. For example, you may specify a rule of `bind:*.example.com` which will allow `x.example.com`, `y.example.com`, `*.example.com`, etc. Bind rules for labels may specify a wildcard key and/or value to match multiple labels. For example, you may specify a rule of `bind:*=example` which will allow `x=example`, `y=example`, etc. A rule of `'*'` is equivalent to no acl at all and will explicitly permit all actions.",
      type: 'List<string>',
    },
    ],
  SSHCredentialCreate: [
    {
      name: 'description',
      desc: "human-readable description of who or what will use the ssh credential to authenticate. Optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this ssh credential. Optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'acl',
      desc: "optional list of ACL rules. If unspecified, the credential will have no restrictions. The only allowed ACL rule at this time is the `bind` rule. The `bind` rule allows the caller to restrict what domains, addresses, and labels the token is allowed to bind. For example, to allow the token to open a tunnel on example.ngrok.io your ACL would include the rule `bind:example.ngrok.io`. Bind rules for domains may specify a leading wildcard to match multiple domains with a common suffix. For example, you may specify a rule of `bind:*.example.com` which will allow `x.example.com`, `y.example.com`, `*.example.com`, etc. Bind rules for labels may specify a wildcard key and/or value to match multiple labels. For example, you may specify a rule of `bind:*=example` which will allow `x=example`, `y=example`, etc. A rule of `'*'` is equivalent to no acl at all and will explicitly permit all actions.",
      type: 'List<string>',
    },
    {
      name: 'public_key',
      desc: "the PEM-encoded public key of the SSH keypair that will be used to authenticate",
      type: 'string',
    },
    ],
  SSHCredentialList: [
    {
      name: 'ssh_credentials.id',
      desc: "unique ssh credential resource identifier",
      type: 'string',
    },
    {
      name: 'ssh_credentials.uri',
      desc: "URI of the ssh credential API resource",
      type: 'string',
    },
    {
      name: 'ssh_credentials.created_at',
      desc: "timestamp when the ssh credential was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'ssh_credentials.description',
      desc: "human-readable description of who or what will use the ssh credential to authenticate. Optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'ssh_credentials.metadata',
      desc: "arbitrary user-defined machine-readable data of this ssh credential. Optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'ssh_credentials.public_key',
      desc: "the PEM-encoded public key of the SSH keypair that will be used to authenticate",
      type: 'string',
    },
    {
      name: 'ssh_credentials.acl',
      desc: "optional list of ACL rules. If unspecified, the credential will have no restrictions. The only allowed ACL rule at this time is the `bind` rule. The `bind` rule allows the caller to restrict what domains, addresses, and labels the token is allowed to bind. For example, to allow the token to open a tunnel on example.ngrok.io your ACL would include the rule `bind:example.ngrok.io`. Bind rules for domains may specify a leading wildcard to match multiple domains with a common suffix. For example, you may specify a rule of `bind:*.example.com` which will allow `x.example.com`, `y.example.com`, `*.example.com`, etc. Bind rules for labels may specify a wildcard key and/or value to match multiple labels. For example, you may specify a rule of `bind:*=example` which will allow `x=example`, `y=example`, etc. A rule of `'*'` is equivalent to no acl at all and will explicitly permit all actions.",
      type: 'List<string>',
    },
    {
      name: 'uri',
      desc: "URI of the ssh credential list API resource",
      type: 'string',
    },
    {
      name: 'next_page_uri',
      desc: "URI of the next page, or null if there is no next page",
      type: 'string',
    },
    ],
  SSHCredentialUpdate: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of who or what will use the ssh credential to authenticate. Optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this ssh credential. Optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'acl',
      desc: "optional list of ACL rules. If unspecified, the credential will have no restrictions. The only allowed ACL rule at this time is the `bind` rule. The `bind` rule allows the caller to restrict what domains, addresses, and labels the token is allowed to bind. For example, to allow the token to open a tunnel on example.ngrok.io your ACL would include the rule `bind:example.ngrok.io`. Bind rules for domains may specify a leading wildcard to match multiple domains with a common suffix. For example, you may specify a rule of `bind:*.example.com` which will allow `x.example.com`, `y.example.com`, `*.example.com`, etc. Bind rules for labels may specify a wildcard key and/or value to match multiple labels. For example, you may specify a rule of `bind:*=example` which will allow `x=example`, `y=example`, etc. A rule of `'*'` is equivalent to no acl at all and will explicitly permit all actions.",
      type: 'List<string>',
    },
    ],
  SSHHostCertificate: [
    {
      name: 'id',
      desc: "unique identifier for this SSH Host Certificate",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the SSH Host Certificate API resource",
      type: 'string',
    },
    {
      name: 'created_at',
      desc: "timestamp when the SSH Host Certificate API resource was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of this SSH Host Certificate. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this SSH Host Certificate. optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'public_key',
      desc: "a public key in OpenSSH Authorized Keys format that this certificate signs",
      type: 'string',
    },
    {
      name: 'key_type',
      desc: "the key type of the `public_key`, one of `rsa`, `ecdsa` or `ed25519`",
      type: 'string',
    },
    {
      name: 'ssh_certificate_authority_id',
      desc: "the ssh certificate authority that is used to sign this ssh host certificate",
      type: 'string',
    },
    {
      name: 'principals',
      desc: "the list of principals included in the ssh host certificate. This is the list of hostnames and/or IP addresses that are authorized to serve SSH traffic with this certificate. Dangerously, if no principals are specified, this certificate is considered valid for all hosts.",
      type: 'List<string>',
    },
    {
      name: 'valid_after',
      desc: "the time when the ssh host certificate becomes valid, in RFC 3339 format.",
      type: 'string',
    },
    {
      name: 'valid_until',
      desc: "the time after which the ssh host certificate becomes invalid, in RFC 3339 format. the OpenSSH certificates RFC calls this `valid_before`.",
      type: 'string',
    },
    {
      name: 'certificate',
      desc: "the signed SSH certificate in OpenSSH Authorized Keys format. this value should be placed in a `-cert.pub` certificate file on disk that should be referenced in your `sshd_config` configuration file with a `HostCertificate` directive",
      type: 'string',
    },
    ],
  SSHHostCertificateCreate: [
    {
      name: 'ssh_certificate_authority_id',
      desc: "the ssh certificate authority that is used to sign this ssh host certificate",
      type: 'string',
    },
    {
      name: 'public_key',
      desc: "a public key in OpenSSH Authorized Keys format that this certificate signs",
      type: 'string',
    },
    {
      name: 'principals',
      desc: "the list of principals included in the ssh host certificate. This is the list of hostnames and/or IP addresses that are authorized to serve SSH traffic with this certificate. Dangerously, if no principals are specified, this certificate is considered valid for all hosts.",
      type: 'List<string>',
    },
    {
      name: 'valid_after',
      desc: "The time when the host certificate becomes valid, in RFC 3339 format. Defaults to the current time if unspecified.",
      type: 'string',
    },
    {
      name: 'valid_until',
      desc: "The time when this host certificate becomes invalid, in RFC 3339 format. If unspecified, a default value of one year in the future will be used. The OpenSSH certificates RFC calls this `valid_before`.",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of this SSH Host Certificate. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this SSH Host Certificate. optional, max 4096 bytes.",
      type: 'string',
    },
    ],
  SSHHostCertificateList: [
    {
      name: 'ssh_host_certificates.id',
      desc: "unique identifier for this SSH Host Certificate",
      type: 'string',
    },
    {
      name: 'ssh_host_certificates.uri',
      desc: "URI of the SSH Host Certificate API resource",
      type: 'string',
    },
    {
      name: 'ssh_host_certificates.created_at',
      desc: "timestamp when the SSH Host Certificate API resource was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'ssh_host_certificates.description',
      desc: "human-readable description of this SSH Host Certificate. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'ssh_host_certificates.metadata',
      desc: "arbitrary user-defined machine-readable data of this SSH Host Certificate. optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'ssh_host_certificates.public_key',
      desc: "a public key in OpenSSH Authorized Keys format that this certificate signs",
      type: 'string',
    },
    {
      name: 'ssh_host_certificates.key_type',
      desc: "the key type of the `public_key`, one of `rsa`, `ecdsa` or `ed25519`",
      type: 'string',
    },
    {
      name: 'ssh_host_certificates.ssh_certificate_authority_id',
      desc: "the ssh certificate authority that is used to sign this ssh host certificate",
      type: 'string',
    },
    {
      name: 'ssh_host_certificates.principals',
      desc: "the list of principals included in the ssh host certificate. This is the list of hostnames and/or IP addresses that are authorized to serve SSH traffic with this certificate. Dangerously, if no principals are specified, this certificate is considered valid for all hosts.",
      type: 'List<string>',
    },
    {
      name: 'ssh_host_certificates.valid_after',
      desc: "the time when the ssh host certificate becomes valid, in RFC 3339 format.",
      type: 'string',
    },
    {
      name: 'ssh_host_certificates.valid_until',
      desc: "the time after which the ssh host certificate becomes invalid, in RFC 3339 format. the OpenSSH certificates RFC calls this `valid_before`.",
      type: 'string',
    },
    {
      name: 'ssh_host_certificates.certificate',
      desc: "the signed SSH certificate in OpenSSH Authorized Keys format. this value should be placed in a `-cert.pub` certificate file on disk that should be referenced in your `sshd_config` configuration file with a `HostCertificate` directive",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the ssh host certificates list API resource",
      type: 'string',
    },
    {
      name: 'next_page_uri',
      desc: "URI of the next page, or null if there is no next page",
      type: 'string',
    },
    ],
  SSHHostCertificateUpdate: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of this SSH Host Certificate. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this SSH Host Certificate. optional, max 4096 bytes.",
      type: 'string',
    },
    ],
  SSHUserCertificate: [
    {
      name: 'id',
      desc: "unique identifier for this SSH User Certificate",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the SSH User Certificate API resource",
      type: 'string',
    },
    {
      name: 'created_at',
      desc: "timestamp when the SSH User Certificate API resource was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of this SSH User Certificate. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this SSH User Certificate. optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'public_key',
      desc: "a public key in OpenSSH Authorized Keys format that this certificate signs",
      type: 'string',
    },
    {
      name: 'key_type',
      desc: "the key type of the `public_key`, one of `rsa`, `ecdsa` or `ed25519`",
      type: 'string',
    },
    {
      name: 'ssh_certificate_authority_id',
      desc: "the ssh certificate authority that is used to sign this ssh user certificate",
      type: 'string',
    },
    {
      name: 'principals',
      desc: "the list of principals included in the ssh user certificate. This is the list of usernames that the certificate holder may sign in as on a machine authorizing the signing certificate authority. Dangerously, if no principals are specified, this certificate may be used to log in as any user.",
      type: 'List<string>',
    },
    {
      name: 'critical_options',
      desc: "A map of critical options included in the certificate. Only two critical options are currently defined by OpenSSH: `force-command` and `source-address`. See [the OpenSSH certificate protocol spec](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys) for additional details.",
      type: 'Map<string, string>',
    },
    {
      name: 'extensions',
      desc: "A map of extensions included in the certificate. Extensions are additional metadata that can be interpreted by the SSH server for any purpose. These can be used to permit or deny the ability to open a terminal, do port forwarding, x11 forwarding, and more. If unspecified, the certificate will include limited permissions with the following extension map: `{\"permit-pty\": \"\", \"permit-user-rc\": \"\"}` OpenSSH understands a number of predefined extensions. See [the OpenSSH certificate protocol spec](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys) for additional details.",
      type: 'Map<string, string>',
    },
    {
      name: 'valid_after',
      desc: "the time when the ssh host certificate becomes valid, in RFC 3339 format.",
      type: 'string',
    },
    {
      name: 'valid_until',
      desc: "the time after which the ssh host certificate becomes invalid, in RFC 3339 format. the OpenSSH certificates RFC calls this `valid_before`.",
      type: 'string',
    },
    {
      name: 'certificate',
      desc: "the signed SSH certificate in OpenSSH Authorized Keys Format. this value should be placed in a `-cert.pub` certificate file on disk that should be referenced in your `sshd_config` configuration file with a `HostCertificate` directive",
      type: 'string',
    },
    ],
  SSHUserCertificateCreate: [
    {
      name: 'ssh_certificate_authority_id',
      desc: "the ssh certificate authority that is used to sign this ssh user certificate",
      type: 'string',
    },
    {
      name: 'public_key',
      desc: "a public key in OpenSSH Authorized Keys format that this certificate signs",
      type: 'string',
    },
    {
      name: 'principals',
      desc: "the list of principals included in the ssh user certificate. This is the list of usernames that the certificate holder may sign in as on a machine authorizing the signing certificate authority. Dangerously, if no principals are specified, this certificate may be used to log in as any user.",
      type: 'List<string>',
    },
    {
      name: 'critical_options',
      desc: "A map of critical options included in the certificate. Only two critical options are currently defined by OpenSSH: `force-command` and `source-address`. See [the OpenSSH certificate protocol spec](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys) for additional details.",
      type: 'Map<string, string>',
    },
    {
      name: 'extensions',
      desc: "A map of extensions included in the certificate. Extensions are additional metadata that can be interpreted by the SSH server for any purpose. These can be used to permit or deny the ability to open a terminal, do port forwarding, x11 forwarding, and more. If unspecified, the certificate will include limited permissions with the following extension map: `{\"permit-pty\": \"\", \"permit-user-rc\": \"\"}` OpenSSH understands a number of predefined extensions. See [the OpenSSH certificate protocol spec](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys) for additional details.",
      type: 'Map<string, string>',
    },
    {
      name: 'valid_after',
      desc: "The time when the user certificate becomes valid, in RFC 3339 format. Defaults to the current time if unspecified.",
      type: 'string',
    },
    {
      name: 'valid_until',
      desc: "The time when this host certificate becomes invalid, in RFC 3339 format. If unspecified, a default value of 24 hours will be used. The OpenSSH certificates RFC calls this `valid_before`.",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of this SSH User Certificate. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this SSH User Certificate. optional, max 4096 bytes.",
      type: 'string',
    },
    ],
  SSHUserCertificateList: [
    {
      name: 'ssh_user_certificates.id',
      desc: "unique identifier for this SSH User Certificate",
      type: 'string',
    },
    {
      name: 'ssh_user_certificates.uri',
      desc: "URI of the SSH User Certificate API resource",
      type: 'string',
    },
    {
      name: 'ssh_user_certificates.created_at',
      desc: "timestamp when the SSH User Certificate API resource was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'ssh_user_certificates.description',
      desc: "human-readable description of this SSH User Certificate. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'ssh_user_certificates.metadata',
      desc: "arbitrary user-defined machine-readable data of this SSH User Certificate. optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'ssh_user_certificates.public_key',
      desc: "a public key in OpenSSH Authorized Keys format that this certificate signs",
      type: 'string',
    },
    {
      name: 'ssh_user_certificates.key_type',
      desc: "the key type of the `public_key`, one of `rsa`, `ecdsa` or `ed25519`",
      type: 'string',
    },
    {
      name: 'ssh_user_certificates.ssh_certificate_authority_id',
      desc: "the ssh certificate authority that is used to sign this ssh user certificate",
      type: 'string',
    },
    {
      name: 'ssh_user_certificates.principals',
      desc: "the list of principals included in the ssh user certificate. This is the list of usernames that the certificate holder may sign in as on a machine authorizing the signing certificate authority. Dangerously, if no principals are specified, this certificate may be used to log in as any user.",
      type: 'List<string>',
    },
    {
      name: 'ssh_user_certificates.critical_options',
      desc: "A map of critical options included in the certificate. Only two critical options are currently defined by OpenSSH: `force-command` and `source-address`. See [the OpenSSH certificate protocol spec](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys) for additional details.",
      type: 'Map<string, string>',
    },
    {
      name: 'ssh_user_certificates.extensions',
      desc: "A map of extensions included in the certificate. Extensions are additional metadata that can be interpreted by the SSH server for any purpose. These can be used to permit or deny the ability to open a terminal, do port forwarding, x11 forwarding, and more. If unspecified, the certificate will include limited permissions with the following extension map: `{\"permit-pty\": \"\", \"permit-user-rc\": \"\"}` OpenSSH understands a number of predefined extensions. See [the OpenSSH certificate protocol spec](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys) for additional details.",
      type: 'Map<string, string>',
    },
    {
      name: 'ssh_user_certificates.valid_after',
      desc: "the time when the ssh host certificate becomes valid, in RFC 3339 format.",
      type: 'string',
    },
    {
      name: 'ssh_user_certificates.valid_until',
      desc: "the time after which the ssh host certificate becomes invalid, in RFC 3339 format. the OpenSSH certificates RFC calls this `valid_before`.",
      type: 'string',
    },
    {
      name: 'ssh_user_certificates.certificate',
      desc: "the signed SSH certificate in OpenSSH Authorized Keys Format. this value should be placed in a `-cert.pub` certificate file on disk that should be referenced in your `sshd_config` configuration file with a `HostCertificate` directive",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the ssh user certificates list API resource",
      type: 'string',
    },
    {
      name: 'next_page_uri',
      desc: "URI of the next page, or null if there is no next page",
      type: 'string',
    },
    ],
  SSHUserCertificateUpdate: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of this SSH User Certificate. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this SSH User Certificate. optional, max 4096 bytes.",
      type: 'string',
    },
    ],
  SentEvent: [
    {
      name: 'event_id',
      desc: "",
      type: 'string',
    },
    ],
  StaticBackend: [
    {
      name: 'id',
      desc: "unique identifier for this static backend",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the StaticBackend API resource",
      type: 'string',
    },
    {
      name: 'created_at',
      desc: "timestamp when the backend was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of this backend. Optional",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this backend. Optional",
      type: 'string',
    },
    {
      name: 'address',
      desc: "the address to forward to",
      type: 'string',
    },
    {
      name: 'tls.enabled',
      desc: "if TLS is checked",
      type: 'boolean',
    },
    ],
  StaticBackendCreate: [
    {
      name: 'description',
      desc: "human-readable description of this backend. Optional",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this backend. Optional",
      type: 'string',
    },
    {
      name: 'address',
      desc: "the address to forward to",
      type: 'string',
    },
    {
      name: 'tls.enabled',
      desc: "if TLS is checked",
      type: 'boolean',
    },
    ],
  StaticBackendList: [
    {
      name: 'backends.id',
      desc: "unique identifier for this static backend",
      type: 'string',
    },
    {
      name: 'backends.uri',
      desc: "URI of the StaticBackend API resource",
      type: 'string',
    },
    {
      name: 'backends.created_at',
      desc: "timestamp when the backend was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'backends.description',
      desc: "human-readable description of this backend. Optional",
      type: 'string',
    },
    {
      name: 'backends.metadata',
      desc: "arbitrary user-defined machine-readable data of this backend. Optional",
      type: 'string',
    },
    {
      name: 'backends.address',
      desc: "the address to forward to",
      type: 'string',
    },
    {
      name: 'backends.tls.enabled',
      desc: "if TLS is checked",
      type: 'boolean',
    },
    {
      name: 'uri',
      desc: "URI of the static backends list API resource",
      type: 'string',
    },
    {
      name: 'next_page_uri',
      desc: "URI of the next page, or null if there is no next page",
      type: 'string',
    },
    ],
  StaticBackendTLS: [
    {
      name: 'enabled',
      desc: "if TLS is checked",
      type: 'boolean',
    },
    ],
  StaticBackendUpdate: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of this backend. Optional",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this backend. Optional",
      type: 'string',
    },
    {
      name: 'address',
      desc: "the address to forward to",
      type: 'string',
    },
    {
      name: 'tls.enabled',
      desc: "if TLS is checked",
      type: 'boolean',
    },
    ],
  TCPEdge: [
    {
      name: 'id',
      desc: "unique identifier of this edge",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of what this edge will be used for; optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this edge. Optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'created_at',
      desc: "timestamp when the edge was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the edge API resource",
      type: 'string',
    },
    {
      name: 'hostports',
      desc: "hostports served by this edge",
      type: 'List<string>',
    },
    {
      name: 'backend.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'backend.backend.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'backend.backend.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'ip_restriction.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'ip_restriction.ip_policies.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'ip_restriction.ip_policies.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    ],
  TCPEdgeCreate: [
    {
      name: 'description',
      desc: "human-readable description of what this edge will be used for; optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this edge. Optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'hostports',
      desc: "hostports served by this edge",
      type: 'List<string>',
    },
    {
      name: 'backend.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'backend.backend_id',
      desc: "backend to be used to back this endpoint",
      type: 'string',
    },
    {
      name: 'ip_restriction.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'ip_restriction.ip_policy_ids',
      desc: "list of all IP policies that will be used to check if a source IP is allowed access to the endpoint",
      type: 'List<string>',
    },
    ],
  TCPEdgeList: [
    {
      name: 'tcp_edges.id',
      desc: "unique identifier of this edge",
      type: 'string',
    },
    {
      name: 'tcp_edges.description',
      desc: "human-readable description of what this edge will be used for; optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'tcp_edges.metadata',
      desc: "arbitrary user-defined machine-readable data of this edge. Optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'tcp_edges.created_at',
      desc: "timestamp when the edge was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'tcp_edges.uri',
      desc: "URI of the edge API resource",
      type: 'string',
    },
    {
      name: 'tcp_edges.hostports',
      desc: "hostports served by this edge",
      type: 'List<string>',
    },
    {
      name: 'tcp_edges.backend.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'tcp_edges.backend.backend.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'tcp_edges.backend.backend.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'tcp_edges.ip_restriction.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'tcp_edges.ip_restriction.ip_policies.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'tcp_edges.ip_restriction.ip_policies.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the TCP Edge list API resource",
      type: 'string',
    },
    {
      name: 'next_page_uri',
      desc: "URI of the next page, or null if there is no next page",
      type: 'string',
    },
    ],
  TCPEdgeUpdate: [
    {
      name: 'id',
      desc: "unique identifier of this edge",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of what this edge will be used for; optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this edge. Optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'hostports',
      desc: "hostports served by this edge",
      type: 'List<string>',
    },
    {
      name: 'backend.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'backend.backend_id',
      desc: "backend to be used to back this endpoint",
      type: 'string',
    },
    {
      name: 'ip_restriction.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'ip_restriction.ip_policy_ids',
      desc: "list of all IP policies that will be used to check if a source IP is allowed access to the endpoint",
      type: 'List<string>',
    },
    ],
  TLSCertificate: [
    {
      name: 'id',
      desc: "unique identifier for this TLS certificate",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the TLS certificate API resource",
      type: 'string',
    },
    {
      name: 'created_at',
      desc: "timestamp when the TLS certificate was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of this TLS certificate. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this TLS certificate. optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'certificate_pem',
      desc: "chain of PEM-encoded certificates, leaf first. See [Certificate Bundles](https://ngrok.com/docs/api#tls-certificates-pem).",
      type: 'string',
    },
    {
      name: 'subject_common_name',
      desc: "subject common name from the leaf of this TLS certificate",
      type: 'string',
    },
    {
      name: 'subject_alternative_names.dns_names',
      desc: "set of additional domains (including wildcards) this TLS certificate is valid for",
      type: 'List<string>',
    },
    {
      name: 'subject_alternative_names.ips',
      desc: "set of IP addresses this TLS certificate is also valid for",
      type: 'List<string>',
    },
    {
      name: 'issued_at',
      desc: "timestamp (in RFC 3339 format) when this TLS certificate was issued automatically, or null if this certificate was user-uploaded",
      type: 'string',
    },
    {
      name: 'not_before',
      desc: "timestamp when this TLS certificate becomes valid, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'not_after',
      desc: "timestamp when this TLS certificate becomes invalid, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'key_usages',
      desc: "set of actions the private key of this TLS certificate can be used for",
      type: 'List<string>',
    },
    {
      name: 'extended_key_usages',
      desc: "extended set of actions the private key of this TLS certificate can be used for",
      type: 'List<string>',
    },
    {
      name: 'private_key_type',
      desc: "type of the private key of this TLS certificate. One of rsa, ecdsa, or ed25519.",
      type: 'string',
    },
    {
      name: 'issuer_common_name',
      desc: "issuer common name from the leaf of this TLS certificate",
      type: 'string',
    },
    {
      name: 'serial_number',
      desc: "serial number of the leaf of this TLS certificate",
      type: 'string',
    },
    {
      name: 'subject_organization',
      desc: "subject organization from the leaf of this TLS certificate",
      type: 'string',
    },
    {
      name: 'subject_organizational_unit',
      desc: "subject organizational unit from the leaf of this TLS certificate",
      type: 'string',
    },
    {
      name: 'subject_locality',
      desc: "subject locality from the leaf of this TLS certificate",
      type: 'string',
    },
    {
      name: 'subject_province',
      desc: "subject province from the leaf of this TLS certificate",
      type: 'string',
    },
    {
      name: 'subject_country',
      desc: "subject country from the leaf of this TLS certificate",
      type: 'string',
    },
    ],
  TLSCertificateCreate: [
    {
      name: 'description',
      desc: "human-readable description of this TLS certificate. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this TLS certificate. optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'certificate_pem',
      desc: "chain of PEM-encoded certificates, leaf first. See [Certificate Bundles](https://ngrok.com/docs/api#tls-certificates-pem).",
      type: 'string',
    },
    {
      name: 'private_key_pem',
      desc: "private key for the TLS certificate, PEM-encoded. See [Private Keys](https://ngrok.com/docs/ngrok-link#tls-certificates-key).",
      type: 'string',
    },
    ],
  TLSCertificateList: [
    {
      name: 'tls_certificates.id',
      desc: "unique identifier for this TLS certificate",
      type: 'string',
    },
    {
      name: 'tls_certificates.uri',
      desc: "URI of the TLS certificate API resource",
      type: 'string',
    },
    {
      name: 'tls_certificates.created_at',
      desc: "timestamp when the TLS certificate was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'tls_certificates.description',
      desc: "human-readable description of this TLS certificate. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'tls_certificates.metadata',
      desc: "arbitrary user-defined machine-readable data of this TLS certificate. optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'tls_certificates.certificate_pem',
      desc: "chain of PEM-encoded certificates, leaf first. See [Certificate Bundles](https://ngrok.com/docs/api#tls-certificates-pem).",
      type: 'string',
    },
    {
      name: 'tls_certificates.subject_common_name',
      desc: "subject common name from the leaf of this TLS certificate",
      type: 'string',
    },
    {
      name: 'tls_certificates.subject_alternative_names.dns_names',
      desc: "set of additional domains (including wildcards) this TLS certificate is valid for",
      type: 'List<string>',
    },
    {
      name: 'tls_certificates.subject_alternative_names.ips',
      desc: "set of IP addresses this TLS certificate is also valid for",
      type: 'List<string>',
    },
    {
      name: 'tls_certificates.issued_at',
      desc: "timestamp (in RFC 3339 format) when this TLS certificate was issued automatically, or null if this certificate was user-uploaded",
      type: 'string',
    },
    {
      name: 'tls_certificates.not_before',
      desc: "timestamp when this TLS certificate becomes valid, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'tls_certificates.not_after',
      desc: "timestamp when this TLS certificate becomes invalid, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'tls_certificates.key_usages',
      desc: "set of actions the private key of this TLS certificate can be used for",
      type: 'List<string>',
    },
    {
      name: 'tls_certificates.extended_key_usages',
      desc: "extended set of actions the private key of this TLS certificate can be used for",
      type: 'List<string>',
    },
    {
      name: 'tls_certificates.private_key_type',
      desc: "type of the private key of this TLS certificate. One of rsa, ecdsa, or ed25519.",
      type: 'string',
    },
    {
      name: 'tls_certificates.issuer_common_name',
      desc: "issuer common name from the leaf of this TLS certificate",
      type: 'string',
    },
    {
      name: 'tls_certificates.serial_number',
      desc: "serial number of the leaf of this TLS certificate",
      type: 'string',
    },
    {
      name: 'tls_certificates.subject_organization',
      desc: "subject organization from the leaf of this TLS certificate",
      type: 'string',
    },
    {
      name: 'tls_certificates.subject_organizational_unit',
      desc: "subject organizational unit from the leaf of this TLS certificate",
      type: 'string',
    },
    {
      name: 'tls_certificates.subject_locality',
      desc: "subject locality from the leaf of this TLS certificate",
      type: 'string',
    },
    {
      name: 'tls_certificates.subject_province',
      desc: "subject province from the leaf of this TLS certificate",
      type: 'string',
    },
    {
      name: 'tls_certificates.subject_country',
      desc: "subject country from the leaf of this TLS certificate",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the TLS certificates list API resource",
      type: 'string',
    },
    {
      name: 'next_page_uri',
      desc: "URI of the next page, or null if there is no next page",
      type: 'string',
    },
    ],
  TLSCertificateSANs: [
    {
      name: 'dns_names',
      desc: "set of additional domains (including wildcards) this TLS certificate is valid for",
      type: 'List<string>',
    },
    {
      name: 'ips',
      desc: "set of IP addresses this TLS certificate is also valid for",
      type: 'List<string>',
    },
    ],
  TLSCertificateUpdate: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of this TLS certificate. optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this TLS certificate. optional, max 4096 bytes.",
      type: 'string',
    },
    ],
  TLSEdge: [
    {
      name: 'id',
      desc: "unique identifier of this edge",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of what this edge will be used for; optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this edge. Optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'created_at',
      desc: "timestamp when the edge configuration was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the edge API resource",
      type: 'string',
    },
    {
      name: 'hostports',
      desc: "hostports served by this edge",
      type: 'List<string>',
    },
    {
      name: 'backend.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'backend.backend.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'backend.backend.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'ip_restriction.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'ip_restriction.ip_policies.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'ip_restriction.ip_policies.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'mutual_tls.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'mutual_tls.certificate_authorities.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'mutual_tls.certificate_authorities.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'tls_termination.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'tls_termination.terminate_at',
      desc: "`edge` if the ngrok edge should terminate TLS traffic, `upstream` if TLS traffic should be passed through to the upstream ngrok agent / application server for termination. if `upstream` is chosen, most other modules will be disallowed because they rely on the ngrok edge being able to access the underlying traffic.",
      type: 'string',
    },
    {
      name: 'tls_termination.min_version',
      desc: "The minimum TLS version used for termination and advertised to the client during the TLS handshake. if unspecified, ngrok will choose an industry-safe default. This value must be null if `terminate_at` is set to `upstream`.",
      type: 'string',
    },
    ],
  TLSEdgeCreate: [
    {
      name: 'description',
      desc: "human-readable description of what this edge will be used for; optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this edge. Optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'hostports',
      desc: "hostports served by this edge",
      type: 'List<string>',
    },
    {
      name: 'backend.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'backend.backend_id',
      desc: "backend to be used to back this endpoint",
      type: 'string',
    },
    {
      name: 'ip_restriction.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'ip_restriction.ip_policy_ids',
      desc: "list of all IP policies that will be used to check if a source IP is allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'mutual_tls.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'mutual_tls.certificate_authority_ids',
      desc: "list of certificate authorities that will be used to validate the TLS client certificate presented by the initiator of the TLS connection",
      type: 'List<string>',
    },
    {
      name: 'tls_termination.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'tls_termination.terminate_at',
      desc: "`edge` if the ngrok edge should terminate TLS traffic, `upstream` if TLS traffic should be passed through to the upstream ngrok agent / application server for termination. if `upstream` is chosen, most other modules will be disallowed because they rely on the ngrok edge being able to access the underlying traffic.",
      type: 'string',
    },
    {
      name: 'tls_termination.min_version',
      desc: "The minimum TLS version used for termination and advertised to the client during the TLS handshake. if unspecified, ngrok will choose an industry-safe default. This value must be null if `terminate_at` is set to `upstream`.",
      type: 'string',
    },
    ],
  TLSEdgeList: [
    {
      name: 'tls_edges.id',
      desc: "unique identifier of this edge",
      type: 'string',
    },
    {
      name: 'tls_edges.description',
      desc: "human-readable description of what this edge will be used for; optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'tls_edges.metadata',
      desc: "arbitrary user-defined machine-readable data of this edge. Optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'tls_edges.created_at',
      desc: "timestamp when the edge configuration was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'tls_edges.uri',
      desc: "URI of the edge API resource",
      type: 'string',
    },
    {
      name: 'tls_edges.hostports',
      desc: "hostports served by this edge",
      type: 'List<string>',
    },
    {
      name: 'tls_edges.backend.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'tls_edges.backend.backend.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'tls_edges.backend.backend.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'tls_edges.ip_restriction.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'tls_edges.ip_restriction.ip_policies.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'tls_edges.ip_restriction.ip_policies.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'tls_edges.mutual_tls.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'tls_edges.mutual_tls.certificate_authorities.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'tls_edges.mutual_tls.certificate_authorities.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'tls_edges.tls_termination.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'tls_edges.tls_termination.terminate_at',
      desc: "`edge` if the ngrok edge should terminate TLS traffic, `upstream` if TLS traffic should be passed through to the upstream ngrok agent / application server for termination. if `upstream` is chosen, most other modules will be disallowed because they rely on the ngrok edge being able to access the underlying traffic.",
      type: 'string',
    },
    {
      name: 'tls_edges.tls_termination.min_version',
      desc: "The minimum TLS version used for termination and advertised to the client during the TLS handshake. if unspecified, ngrok will choose an industry-safe default. This value must be null if `terminate_at` is set to `upstream`.",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the TLS Edge list API resource",
      type: 'string',
    },
    {
      name: 'next_page_uri',
      desc: "URI of the next page, or null if there is no next page",
      type: 'string',
    },
    ],
  TLSEdgeUpdate: [
    {
      name: 'id',
      desc: "unique identifier of this edge",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of what this edge will be used for; optional, max 255 bytes.",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this edge. Optional, max 4096 bytes.",
      type: 'string',
    },
    {
      name: 'hostports',
      desc: "hostports served by this edge",
      type: 'List<string>',
    },
    {
      name: 'backend.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'backend.backend_id',
      desc: "backend to be used to back this endpoint",
      type: 'string',
    },
    {
      name: 'ip_restriction.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'ip_restriction.ip_policy_ids',
      desc: "list of all IP policies that will be used to check if a source IP is allowed access to the endpoint",
      type: 'List<string>',
    },
    {
      name: 'mutual_tls.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'mutual_tls.certificate_authority_ids',
      desc: "list of certificate authorities that will be used to validate the TLS client certificate presented by the initiator of the TLS connection",
      type: 'List<string>',
    },
    {
      name: 'tls_termination.enabled',
      desc: "`true` if the module will be applied to traffic, `false` to disable. default `true` if unspecified",
      type: 'boolean',
    },
    {
      name: 'tls_termination.terminate_at',
      desc: "`edge` if the ngrok edge should terminate TLS traffic, `upstream` if TLS traffic should be passed through to the upstream ngrok agent / application server for termination. if `upstream` is chosen, most other modules will be disallowed because they rely on the ngrok edge being able to access the underlying traffic.",
      type: 'string',
    },
    {
      name: 'tls_termination.min_version',
      desc: "The minimum TLS version used for termination and advertised to the client during the TLS handshake. if unspecified, ngrok will choose an industry-safe default. This value must be null if `terminate_at` is set to `upstream`.",
      type: 'string',
    },
    ],
  Tunnel: [
    {
      name: 'id',
      desc: "unique tunnel resource identifier",
      type: 'string',
    },
    {
      name: 'public_url',
      desc: "URL of the ephemeral tunnel's public endpoint",
      type: 'string',
    },
    {
      name: 'started_at',
      desc: "timestamp when the tunnel was initiated in RFC 3339 format",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "user-supplied metadata for the tunnel defined in the ngrok configuration file. See the tunnel [metadata configuration option](https://ngrok.com/docs#tunnel-definitions-metadata) In API version 0, this value was instead pulled from the top-level [metadata configuration option](https://ngrok.com/docs#config_metadata).",
      type: 'string',
    },
    {
      name: 'proto',
      desc: "tunnel protocol for ephemeral tunnels. one of `http`, `https`, `tcp` or `tls`",
      type: 'string',
    },
    {
      name: 'region',
      desc: "identifier of tune region where the tunnel is running",
      type: 'string',
    },
    {
      name: 'tunnel_session.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'tunnel_session.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'endpoint.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'endpoint.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'labels',
      desc: "the labels the tunnel group backends will match against, if this is a backend tunnel",
      type: 'Map<string, string>',
    },
    {
      name: 'backends.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'backends.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'forwards_to',
      desc: "upstream address the ngrok agent forwards traffic over this tunnel to. this may be expressed as a URL or a network address.",
      type: 'string',
    },
    ],
  TunnelGroupBackend: [
    {
      name: 'id',
      desc: "unique identifier for this TunnelGroup backend",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the TunnelGroupBackend API resource",
      type: 'string',
    },
    {
      name: 'created_at',
      desc: "timestamp when the backend was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of this backend. Optional",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this backend. Optional",
      type: 'string',
    },
    {
      name: 'labels',
      desc: "labels to watch for tunnels on, e.g. app->foo, dc->bar",
      type: 'Map<string, string>',
    },
    {
      name: 'tunnels.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'tunnels.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    ],
  TunnelGroupBackendCreate: [
    {
      name: 'description',
      desc: "human-readable description of this backend. Optional",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this backend. Optional",
      type: 'string',
    },
    {
      name: 'labels',
      desc: "labels to watch for tunnels on, e.g. app->foo, dc->bar",
      type: 'Map<string, string>',
    },
    ],
  TunnelGroupBackendList: [
    {
      name: 'backends.id',
      desc: "unique identifier for this TunnelGroup backend",
      type: 'string',
    },
    {
      name: 'backends.uri',
      desc: "URI of the TunnelGroupBackend API resource",
      type: 'string',
    },
    {
      name: 'backends.created_at',
      desc: "timestamp when the backend was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'backends.description',
      desc: "human-readable description of this backend. Optional",
      type: 'string',
    },
    {
      name: 'backends.metadata',
      desc: "arbitrary user-defined machine-readable data of this backend. Optional",
      type: 'string',
    },
    {
      name: 'backends.labels',
      desc: "labels to watch for tunnels on, e.g. app->foo, dc->bar",
      type: 'Map<string, string>',
    },
    {
      name: 'backends.tunnels.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'backends.tunnels.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the TunnelGroup backends list API resource",
      type: 'string',
    },
    {
      name: 'next_page_uri',
      desc: "URI of the next page, or null if there is no next page",
      type: 'string',
    },
    ],
  TunnelGroupBackendUpdate: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of this backend. Optional",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this backend. Optional",
      type: 'string',
    },
    {
      name: 'labels',
      desc: "labels to watch for tunnels on, e.g. app->foo, dc->bar",
      type: 'Map<string, string>',
    },
    ],
  TunnelList: [
    {
      name: 'tunnels.id',
      desc: "unique tunnel resource identifier",
      type: 'string',
    },
    {
      name: 'tunnels.public_url',
      desc: "URL of the ephemeral tunnel's public endpoint",
      type: 'string',
    },
    {
      name: 'tunnels.started_at',
      desc: "timestamp when the tunnel was initiated in RFC 3339 format",
      type: 'string',
    },
    {
      name: 'tunnels.metadata',
      desc: "user-supplied metadata for the tunnel defined in the ngrok configuration file. See the tunnel [metadata configuration option](https://ngrok.com/docs#tunnel-definitions-metadata) In API version 0, this value was instead pulled from the top-level [metadata configuration option](https://ngrok.com/docs#config_metadata).",
      type: 'string',
    },
    {
      name: 'tunnels.proto',
      desc: "tunnel protocol for ephemeral tunnels. one of `http`, `https`, `tcp` or `tls`",
      type: 'string',
    },
    {
      name: 'tunnels.region',
      desc: "identifier of tune region where the tunnel is running",
      type: 'string',
    },
    {
      name: 'tunnels.tunnel_session.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'tunnels.tunnel_session.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'tunnels.endpoint.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'tunnels.endpoint.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'tunnels.labels',
      desc: "the labels the tunnel group backends will match against, if this is a backend tunnel",
      type: 'Map<string, string>',
    },
    {
      name: 'tunnels.backends.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'tunnels.backends.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'tunnels.forwards_to',
      desc: "upstream address the ngrok agent forwards traffic over this tunnel to. this may be expressed as a URL or a network address.",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the tunnels list API resource",
      type: 'string',
    },
    {
      name: 'next_page_uri',
      desc: "URI of the next page, or null if there is no next page",
      type: 'string',
    },
    ],
  TunnelSession: [
    {
      name: 'agent_version',
      desc: "version of the ngrok agent that started this ngrok tunnel session",
      type: 'string',
    },
    {
      name: 'credential.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'credential.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'id',
      desc: "unique tunnel session resource identifier",
      type: 'string',
    },
    {
      name: 'ip',
      desc: "source ip address of the tunnel session",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined data specified in the metadata property in the ngrok configuration file. See the metadata configuration option",
      type: 'string',
    },
    {
      name: 'os',
      desc: "operating system of the host the ngrok agent is running on",
      type: 'string',
    },
    {
      name: 'region',
      desc: "the ngrok region identifier in which this tunnel session was started",
      type: 'string',
    },
    {
      name: 'started_at',
      desc: "time when the tunnel session first connected to the ngrok servers",
      type: 'string',
    },
    {
      name: 'transport',
      desc: "the transport protocol used to start the tunnel session. Either `ngrok/v2` or `ssh`",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI to the API resource of the tunnel session",
      type: 'string',
    },
    ],
  TunnelSessionList: [
    {
      name: 'tunnel_sessions.agent_version',
      desc: "version of the ngrok agent that started this ngrok tunnel session",
      type: 'string',
    },
    {
      name: 'tunnel_sessions.credential.id',
      desc: "a resource identifier",
      type: 'string',
    },
    {
      name: 'tunnel_sessions.credential.uri',
      desc: "a uri for locating a resource",
      type: 'string',
    },
    {
      name: 'tunnel_sessions.id',
      desc: "unique tunnel session resource identifier",
      type: 'string',
    },
    {
      name: 'tunnel_sessions.ip',
      desc: "source ip address of the tunnel session",
      type: 'string',
    },
    {
      name: 'tunnel_sessions.metadata',
      desc: "arbitrary user-defined data specified in the metadata property in the ngrok configuration file. See the metadata configuration option",
      type: 'string',
    },
    {
      name: 'tunnel_sessions.os',
      desc: "operating system of the host the ngrok agent is running on",
      type: 'string',
    },
    {
      name: 'tunnel_sessions.region',
      desc: "the ngrok region identifier in which this tunnel session was started",
      type: 'string',
    },
    {
      name: 'tunnel_sessions.started_at',
      desc: "time when the tunnel session first connected to the ngrok servers",
      type: 'string',
    },
    {
      name: 'tunnel_sessions.transport',
      desc: "the transport protocol used to start the tunnel session. Either `ngrok/v2` or `ssh`",
      type: 'string',
    },
    {
      name: 'tunnel_sessions.uri',
      desc: "URI to the API resource of the tunnel session",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI to the API resource of the tunnel session list",
      type: 'string',
    },
    {
      name: 'next_page_uri',
      desc: "URI of the next page, or null if there is no next page",
      type: 'string',
    },
    ],
  TunnelSessionsUpdate: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    ],
  UserAgent: [
    {
      name: 'raw',
      desc: "raw User-Agent request header",
      type: 'string',
    },
    {
      name: 'browser_name',
      desc: "browser name (e.g. Chrome)",
      type: 'string',
    },
    {
      name: 'browser_version',
      desc: "browser version (e.g. 102)",
      type: 'string',
    },
    {
      name: 'device_type',
      desc: "type of device (e.g. Desktop)",
      type: 'string',
    },
    {
      name: 'os_name',
      desc: "operating system name (e.g. MacOS)",
      type: 'string',
    },
    {
      name: 'os_version',
      desc: "operating system version (e.g. 10.15.7)",
      type: 'string',
    },
    ],
  WeightedBackend: [
    {
      name: 'id',
      desc: "unique identifier for this Weighted backend",
      type: 'string',
    },
    {
      name: 'uri',
      desc: "URI of the WeightedBackend API resource",
      type: 'string',
    },
    {
      name: 'created_at',
      desc: "timestamp when the backend was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of this backend. Optional",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this backend. Optional",
      type: 'string',
    },
    {
      name: 'backends',
      desc: "the ids of the child backends to their weights [0-10000]",
      type: 'Map<string, int64>',
    },
    ],
  WeightedBackendCreate: [
    {
      name: 'description',
      desc: "human-readable description of this backend. Optional",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this backend. Optional",
      type: 'string',
    },
    {
      name: 'backends',
      desc: "the ids of the child backends to their weights [0-10000]",
      type: 'Map<string, int64>',
    },
    ],
  WeightedBackendList: [
    {
      name: 'backends.id',
      desc: "unique identifier for this Weighted backend",
      type: 'string',
    },
    {
      name: 'backends.uri',
      desc: "URI of the WeightedBackend API resource",
      type: 'string',
    },
    {
      name: 'backends.created_at',
      desc: "timestamp when the backend was created, RFC 3339 format",
      type: 'string',
    },
    {
      name: 'backends.description',
      desc: "human-readable description of this backend. Optional",
      type: 'string',
    },
    {
      name: 'backends.metadata',
      desc: "arbitrary user-defined machine-readable data of this backend. Optional",
      type: 'string',
    },
    {
      name: 'backends.backends',
      desc: "the ids of the child backends to their weights [0-10000]",
      type: 'Map<string, int64>',
    },
    {
      name: 'uri',
      desc: "URI of the Weighted backends list API resource",
      type: 'string',
    },
    {
      name: 'next_page_uri',
      desc: "URI of the next page, or null if there is no next page",
      type: 'string',
    },
    ],
  WeightedBackendUpdate: [
    {
      name: 'id',
      desc: "",
      type: 'string',
    },
    {
      name: 'description',
      desc: "human-readable description of this backend. Optional",
      type: 'string',
    },
    {
      name: 'metadata',
      desc: "arbitrary user-defined machine-readable data of this backend. Optional",
      type: 'string',
    },
    {
      name: 'backends',
      desc: "the ids of the child backends to their weights [0-10000]",
      type: 'Map<string, int64>',
    },
    ],
  }

export function getApiObjectFields(key?: ApiObjectName): ApiObjectField[] {
	if (key == null) {
		return [];
	}
	return apiObjectFields[key];
}
