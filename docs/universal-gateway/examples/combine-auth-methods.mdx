---
title: "Combine Authentication Methods"
description: "Support multiple ways for your users to connect to upstream services with a flexible OR operator pattern."
sidebar_label: "Combine Authentication Methods"
categories:
  - authn-authz
  - traffic-control
---

import ReserveDomain from "./snippets/_reserve-domain.mdx";
import CloudEndpoint from "./snippets/_cloud-endpoint.mdx";
import TryOut from "./snippets/_try-out.mdx";
import Back from "./snippets/_back-to-examples.mdx";

Some services need to support different groups of users with different types of credentials.
Internal teams might use static IPs, but external users authenticate using JWTs.
With ngrokâ€™s Traffic Policy engine, you can let both types of users through safely without making any changes to your upstream service.

This example walks you through how to apply multiple authentication layers to a single endpoint using [action result variables](/docs/traffic-policy/variables/action/) and expressions that mimic an `OR` operator.
You'll allow requests from trusted IPs `OR` those containing valid JWTs, and then reject all others.

## 1. Start an endpoint for your service

Start an internal [Agent Endpoint](/docs/universal-gateway/agent-endpoints/), replacing `$PORT` based on where your service listens.
You can also use one of our [SDKs](/docs/agent-sdks) or the [Kubernetes Operator](/docs/k8s).

```bash
ngrok http $PORT --url https://service.internal
```

## 2. Reserve a domain

<ReserveDomain />

## 3. Create a Cloud Endpoint

<CloudEndpoint />

## 4. Add layers of authentication with Traffic Policy

While still viewing your new Cloud Endpoint in the dashboard, copy and paste the policy below into the Traffic Policy editor.
You will need to change:

- `$TRUSTED_IP_FOO`/`$TRUSTED_IP_BAR`: Replace with public IPs of those who should have access to your service or an [IP policy](https://dashboard.ngrok.com/ip-restrictions) in your ngrok dashboard.
- `$YOUR_JWT_DOMAIN`: The domain name for your tenant at your JWTÂ providerâ€”for example, with Auth0, it looks something like `https://example.us.auth0`.

```yaml
on_http_request:
  # Check whether a request's IP matches your allow list
  - actions:
      - type: restrict-ips
        config:
          # By specifying `false`, you allow the action to run and generate
          # response variables, like `action.ngrok.restrict_ips.action, which
          # allow you to more precisely customize how your policy responds.
          enforce: false
          allow:
            - $TRUSTED_IP_FOO
            - $TRUSTED_IP_BAR

  # Accept the request if its IP matches your allow list
  - expressions:
      - actions.ngrok.restrict_ips.action == "allow"
    actions:
      - type: forward-internal
        config:
          url: https://service.internal

  # Validate a JWT token if one exists on an `Authorization` header.
  - expressions:
      - actions.ngrok.restrict_ips.action == "deny"
    actions:
      - type: jwt-validation
        config:
          issuer:
            allow_list:
              - value: "https://$YOUR_JWT_DOMAIN"
          http:
            tokens:
              - type: "jwt"
                method: "header"
                name: "Authorization"
                prefix: "Bearer "
          jws:
            allowed_algorithms:
              - "RS256"
            keys:
              sources:
                additional_jkus:
                  - "https://$YOUR_JWT_DOMAIN/.well-known/jwks.json"

  # Allow the request if the JWT token is verified by your provider.
  - expressions:
      - actions.ngrok.jwt_validation.tokens[0].verified
    actions:
      - type: forward-internal
        config:
          url: https://service.internal

  # Catch-all custom response for any unauthenticated requests
  - actions:
      - type: custom-response
        config:
          status_code: 401
          headers: {}
          body: >-
            <!DOCTYPE html>
            <html lang="en">
            <head>
              <meta charset="UTF-8" />
              <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
              <title>Unauthorized</title>
              <style>
                body{margin:0;height:100vh;background-color:#f9f9f9;display:flex;align-items:center;justify-content:center;font-family:system-ui,sans-serif}.box{padding:2rem 3rem;border:2px solid #d9534f;border-radius:12px;background-color:#fff3f3;color:#d9534f;font-size:1.5rem;text-align:center;box-shadow:0 4px 12px rgba(0,0,0,.1)}
              </style>
            </head>
            <body>
              <div class="box">
                ðŸš« Access denied
              </div>
            </body>
            </html>
```

**What's happening here?**
This policy has three logical sections, where the first two allow traffic to reach your upstream after authenticating with one method `OR` another, and the third is a catch-all error response for requests that fail to authenticate against any method.

The first section checks every HTTP request to see if its source IP matches one on your `allow` list for `restrict-ips`, but doesn't actually enforce the restriction there.
Instead, the following expression checks whether the [`restrict-ips` action result variable](/docs/traffic-policy/actions/restrict-ips/#action-result-variables) `actions.ngrok.restrict_ips.action` is `allow`, which means that it would have allow the request directly if you had set `enforce: true`.
If that expression is true, then the policy forwards the request to your upstream service.

The second section begins the `OR` logic for all requests that did not match the IP `allow` list.
If these requests contain a valid JWT token, then the policy forwards them to your upstream service.

Finally, the policy denies all requests that did not authenticate either by IP or JWT and delivers a custom HTML response.

## 6. Try out your endpoint

<TryOut />

Add your JWT as a header to verify your `jwt-validation` action works as expected.

```bash
curl https://$NGROK_DOMAIN \
  --header 'Authorization: Bearer $JWT_FROM_PROVIDER'
```

## What's next?

- Layer in more authentication mechanisms, like the [`oauth`](/docs/traffic-policy/actions/oauth) or [`basic-auth`](/docs/traffic-policy/actions/basic-auth) actions using the same pattern of checking the subsequent action result variables with an expression.
- Use the action result variables and [CEL interpolation](/docs/traffic-policy/concepts/cel-interpolation) to add specific error messages to your catch-all `custom-response` action.
- View your traffic in [Traffic Inspector](https://dashboard.ngrok.com/traffic-inspector) to see requests that failed to authenticate but should haveâ€”for example, maybe a specific IP address is missing from your `restrict-ips` allow list or a user who doesn't realize they're using an invalid JWT token.
