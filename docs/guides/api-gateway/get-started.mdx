---
title: Get started - Deliver and secure APIs in production
tags:
  - guides
  - API
  - gateway
  - security
  - microservices
---

# Get started - Deliver and secure APIs in production

You've developed a world-class API, and now you want to make it available for clients to access. This guide takes you from
bringing your API online in one line to configuring an API gateway that simplifies routing, security, contract management,
protocol translation, and more, providing a single point of entry for clients and services accessing your APIs.

## Prerequisites
You'll need an ngrok account to follow the steps in this guide. You can [sign up for free](https://dashboard.ngrok.com/signup) if you don't already have one.

You'll also need a deployed API to manage with ngrok. If you're just getting started or performing a proof-of-concept, you can
deploy our sample REST API for testing purposes.

## Install the ngrok agent
[Download](https://ngrok.com/download) the appropriate version of the ngrok agent, and install it on the same subnet as the API you wish to manage.

## Create an ngrok API key
[Create an ngrok API key](https://dashboard.ngrok.com/api-keys/new) using the ngrok dashboard. Make sure you save the API key before you leave the screen because it won't be displayed again.

## Add the API key to the ngrok agent
Run the following command to add the API key to your ngrok agent, substituting your API key for `{API_KEY}`:

```bash
ngrok config add-api-key {API_KEY}
```
## Setup sample API

To test the policy actions in this guide, you can use the sample application to simulate an environment with multiple APIs deployed and managed
independently.

First, clone the repo and start the application by running:

```js
npm run start
```

Then locate `src/index.js`. Modify the `PORT` value to `8002` and start a second instance.

```js
const PORT = 8001  // Change to 8002
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```
## Reserve a domain
Run the following command to reserve a domain:

```bash
ngrok api reserved-domains create --url {NGROK_SUBDOMAIN}.ngrok.app
```
If the subdomain you chose is already in use, you'll get a `400` error with a message to that effect. In that case, run the
command again with a different subdomain. Alternatively, you can reserve the domain through [the dashboard](https://dashboard.ngrok.com/domains/new),
which will show you which subdomains are available as you type.

This example uses an
[ngrok-managed domain](/docs/network-edge/domains-and-tcp-addresses/#ngrok-managed-domains) but you can use
your own [branded domain](/docs/network-edge/domains-and-tcp-addresses/#branded-domains) when you're ready for production.
In that case, substitute your branded subdomain for `{NGROK_SUBDOMAIN}.ngrok.app` in the command above, and
[follow the steps](/docs/guides/other-guides/how-to-set-up-a-custom-domain/#create-cname-record-in-domain-dns)
to configure DNS.

## Bring your API online
You've created internal endpoints to the two instances of your API, but you need a cloud endpoint to receive traffic and apply policies before
forwarding requests to your backend service via the internal endpoints. You'll start by bringing one of the instances online.

### Create an internal endpoint
Now create an internal endpoint for each instance of the API by running the following commands:

```bash
ngrok http 8001 --url=https://api.internal
```

### Create a traffic policy file
Unlike other endpoint types, cloud endpoints *must* contain at least one traffic policy action which specifies a `forward-internal` action
and the URL to an internal endpoint where traffic should be forwarded. Create a file called `policies.yaml` and paste the contents
below.

```bash
---
on_http_request:
  - actions:
      - type: forward-internal
        config:
          url: https://api.internal
          binding: internal
```

### Create a cloud endpoint
Run the following command from the same directory where you created `policies.yaml` to create a cloud endpoint, substituting the
subdomain (i.e. `mydomain.ngrok.app`) you reserved in the previous step for `{YOUR_DOMAIN}`:

```bash
ngrok api endpoints create \
    --bindings public \
    --description "sample description" \
    --metadata sample-metadata \
    --url https://{YOUR_DOMAIN} \
    --traffic-policy "$(cat policies.yaml)"
```

You'll receive a `201` response similar to the following:

```bash
{
  "bindings": [
    "public"
  ],
  "created_at": "2024-10-25T14:35:28Z",
  "description": "sample description",
  "domain": {
    "id": "rd_2nvupgtpY4RuEPITujbfHpkhxmO",
    "uri": "https://api.ngrok.com/reserved_domains/rd_2nvupgtpY4RuEPITujbfHpkhxmO"
  },
  "hostport": "mydomain.ngrok.app:443",
  "id": "ep_2nvwbSCefcZv0At2ewhzMHPBT3V",
  "metadata": "sample-metadata",
  "proto": "https",
  "public_url": "https://mydomain.ngrok.app",
  "traffic_policy": "{\"on_http_request\":[{\"actions\":[{\"type\":\"forward-internal\",\"config\":{\"url\":\"https://mandy.ngrok.internal\",\"binding\":\"internal\"}}]}]}",
  "type": "cloud",
  "updated_at": "2024-10-25T14:35:28Z",
  "uri": "https://api.ngrok.com/endpoints/ep_2nvwbSCefcZv0At2ewhzMHPBT3V",
  "url": "https://mydomain.ngrok.app"
}
```

Save the value of `id` because you'll need it in a later step.

### Access your API
You can now access your API via the subdomain your reserved above. For example,
you can run the following command to access the `cards` endpoint:

```bash
curl -X GET https://{YOUR_SUBDOMAIN}.ngrok.app/cards
```

You'll receive a `200` response similar to to the following:

```bash
{
  "cards": [
    {
      "id": "ccof:uIbfJXhXETSP197M3GB",
      "billing_address": {
        "address_line_1": "500 Electric Ave",
        "address_line_2": "Suite 600",
        "locality": "New York",
        "administrative_district_level_1": "NY",
        "postal_code": "10003",
        "country": "US"
      },
      "bin": "411111",
      "card_brand": "VISA",
      "card_type": "CREDIT",
      "cardholder_name": "Amelia Earhart",
      "customer_id": "VDKXEEKPJN48QDG3BGGFAK05P8",
      "enabled": true,
      "exp_month": 11,
      "exp_year": 2018,
      "last_4": "1111",
      "prepaid_type": "NOT_PREPAID",
      "reference_id": "user-id-1",
      "version": 1
    }
  ]
}
```

Stop the agent to remove the internal endpoint you just created.

## Manage APIs with traffic policy actions
Your API is now online, but it is completely exposed to the outside world. Next, add some traffic policy actions to authenticate
requests and shape the traffic that reaches your backend service. You'll do this by running a command to update the configuration
of your existing cloud endpoint, so you'll need the `id` from the previous step.

If you didn't save the id when you created
the cloud endpoint, run the following command, locate your endpoint, and grab its `id`:

```
ngrok api endpoints list
```

### Route by headers
You can configure a traffic policy action to direct traffic based on HTTP header values.

#### Start internal endpoints
To implement this example, run the following commands to start internal endpoints to the two instances of the sample API.

```bash
ngrok http 8001 --url=https://v1.api.internal
ngrok http 8002 --url=https://v2.api.internal
```
#### Update traffic policies

This examples looks for a header named `X-Api-Version` and routes traffic to different instances of the `/cards` endpoint of the sample API.
Feel free to modify it for your own API if you're not using the sample app. Update your `policies.yaml` file with the contents below.

```yaml
# Route by header
---
on_http_request:
  - expressions:
        - "'1' in req.headers['x-api-version']"
    actions:
      - type: forward-internal
        config:
          url: https://v1.api.internal
          binding: internal
  - expressions:
      - "'2' in req.headers['x-api-version']"
    actions:
      - type: forward-internal
        config:
          url: https://v2.api.internal
          binding: internal
  - actions:
      - type: forward-internal
        config:
          url: https://v2.api.internal
          binding: internal
```
:::note
You must always include the `forward-internal` action as the final step in your policy action since once it executes,
no subsequent policy actions will be executed. Additionally, you always need a terminating policy action.
In this case, the traffic forwards to `https://v2.api.internal` if the header is set to a value other than `1` or `2` or
if the header isn't present in the request.
:::

Run the following command, substituting your `{ENDPOINT_ID}`, to update the cloud endpoint with the new policy actions:

```bash
 ngrok api endpoints update {ENDPOINT_ID} --traffic-policy "$(cat policies.yaml)"
```
#### Test traffic policies
You can test this by passing a header value when you send a request to this API. Try it with version 1.

```bash
curl -X GET https://{YOUR_SUBDOMAIN}.ngrok.app/cards --header "X-Api-Version: 1"
```

You should see the following response:

```json
{
    "cards": [
        {
            "id": "ccof:uIbfJXhXETSP197M3GB",
            "billing_address": {
                "address_line_1": "500 Electric Ave",
                "address_line_2": "Suite 600",
                "locality": "New York",
                "administrative_district_level_1": "NY",
                "postal_code": "10003",
                "country": "US"
            },
            "bin": "411111",
            "card_brand": "VISA",
            "card_type": "CREDIT",
            "cardholder_name": "Amelia Earhart",
            "customer_id": "VDKXEEKPJN48QDG3BGGFAK05P8",
            "enabled": true,
            "exp_month": 11,
            "exp_year": 2018,
            "last_4": "1111",
            "prepaid_type": "NOT_PREPAID",
            "reference_id": "user-id-1",
            "version": 1
        }
    ]
}
```

Note that the `version` property is set to `1`. You can rerun the command above and change the value of the header to `2`,
or remove it altogether, and the value of the `version` property of the response will change accordingly.

### Route by path
Path-based routing enables you to direct traffic to different backend services.

If you're following along using our example API, you can implement this policy using the two separate internal endpoints
you started in the previous step. This simulates a production scenario where you need to route traffic to a single domain to multiple
backend services.

You can stop the internal endpoint you created in the previous step. Then run this command from a separate terminal for each
internal endpoint (`cards.company.internal`, `payments.company.internal`, and `inventory.company.internal`), substituting
the appropriate value for `{INTERNAL_ENDPOINT}`.

```bash
ngrok http {PORT} --url=https://{INTERNAL_ENDPOINT}
```
Copy the following contents into your `policy.yaml` file, overwriting all previous contents.

```yaml
# Route by path
---
on_http_request:
  # Handle /cards/*
  - expressions:
      - req.url.path.startsWith('/cards/')
    actions:
      - type: forward-internal
        config:
          url: http://cards.company.internal
  # Handle /payments/*
  - expressions:
      - req.url.path.startsWith('/payments/')
    actions:
      - type: forward-internal
        config:
          url: http://payments.company.internal
  # Handle /inventory/*
  - expressions:
      - req.url.path.startsWith('/inventory/')
    actions:
      - type: forward-internal
        config:
          url: http://inventory.company.internal
on_http_response:
  - expressions: []
    actions:
      - type: "add-headers"
        config:
          headers:
            x-req-url: "${req.url}"

```
Now, run the following command to apply the new policies to your cloud endpoint.

```bash
 ngrok api endpoints update {ENDPOINT_ID} --traffic-policy "$(cat policies.yaml)"
```

Run the following command to hit the `/cards` endpoint and display the response headers:

```bash
 curl -s -I -X GET https://{YOUR_DOMAIN}/cards
```

Your response should look similar to the following:

```bash
RESPONSE
```

Notice the `request-url` response header you added as part of the traffic policy above. It indicates that this request
came through on `https://{YOUR_DOMAIN}/cards` and was forwarded to `https://cards.company.internal`. You can repeat the steps
for the `/payments` and `/inventory` endpoints to see which internal endpoints ngrok forwarded each request.

### Configure URL rewrites
The URL Rewrite Traffic Policy action allows you to modify the incoming request URL using regular expressions before it
reaches the upstream service, without changing the URL seen by the client. This action allows you to route user requests
without exposing internal system details.

For example, you could use the following URL rewrite to redirect requests to the `/credit-cards` endpoint to the `/cards` endpoint
without the client seeing the backend URL.

```yaml
# URL Rewrite
---
on_http_request:
  - actions:
      - type: forward-internal
        config:
          url: https://mandy.ngrok.internal
          binding: internal
  - expressions:
      - "req.url.path == '/credit-cards'"
    actions:
        - type: "url-rewrite"
          config:
            from: "/credit-cards"
            to: "/cards"
```

### Enable rate limiting
Next, add rate limiting to your API gateway to ensure your service does not become overwhelmed by too many requests and
that each of your clients has fair access to your API. This traffic policy action allows 30 requests over a 60 second window
 based on the API key of the client as determined by the value of the HTTP header. You can also limit by
 [endpoint](/docs/http/traffic-policy/gallery/#rate-limit-for-specific-endpoint),
 [authentication status](/docs/http/traffic-policy/gallery/#rate-limit-api-consumers-based-on-authentication-status),
 or [pricing tier](/docs/http/traffic-policy/gallery/#rate-limit-api-consumers-based-on-pricing-tiers).

 Copy this policy into your `policy.yaml` file.

```yaml
# Rate Limiting
---
on_http_request:
  - actions:
      - type: forward-internal
        config:
          url: https://company.internal
          binding: internal
  - expressions: [ ]
    name: Add rate limiting
    actions:
        - type: rate-limit
          config:
            name: Only allow 30 requests per minute
            algorithm: sliding_window
            capacity: 30
            rate: 60s
            bucket_key:
              - req.Headers['x-api-key']
```

Run the following command, substituting your `{ENDPOINT_ID}`, to update the cloud endpoint with the new policy actions:

```bash
 ngrok api endpoints update {ENDPOINT_ID} --traffic-policy "$(cat policies.yaml)"
```


You can test the rate limiting action by running the following command, substituting the appropriate value for `{YOUR_DOMAIN}`.
```bash
for i in `seq 1 50`; do curl -X GET -w '%{http_code}' https://{YOUR_DOMAIN}/ ; done
```


### Add JWT Validation




###