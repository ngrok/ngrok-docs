import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# Deployment Guide

This guide is meant as the starting point for configuring, deploying, and operating the controller component itself. It focuses on configurations and settings for the whole controller, and thus its corresponding ingress class, rather than individual ingress resources and their annotations.

## Prerequisites

- A k8s cluster and access to it via kubectl - We recommend using a recent version of k8s and will specify and test past versions as a part of [this GitHub issue](https://github.com/ngrok/kubernetes-ingress-controller/issues/154)
- helm - 3.0.0 or later.

## Installation

It is recommended to use helm to install the operator. Alternatively, the container is available on docker hub at `ngrok/ingress-controller` and can be run directly with hand crafted manifests.

To install via helm, run the following commands to export your credentials as environment variables and add the operator to helm:

```bash
export NGROK_API_KEY=<YOUR Secret API KEY>
export NGROK_AUTHTOKEN=<YOUR Secret Auth Token>
helm repo add ngrok https://ngrok.github.io/kubernetes-ingress-controller
```

<Tabs groupId="k8s" queryString="k8s-basic">
	<TabItem value="ingress" label="Ingress Controller" default>
Run the following commands to install the ingress controller 
```bash
helm install ngrok-ingress-controller ngrok/kubernetes-ingress-controller \
  --namespace ngrok-ingress-controller \
  --create-namespace \
  --set credentials.apiKey=$NGROK_API_KEY \
  --set credentials.authtoken=$NGROK_AUTHTOKEN
```
	</TabItem>
	<TabItem value="gatewayAPI" label="Gateway API">
Run the following commands to instal the core Gateway API CRDs and the Gateway API components of the ngrok Kubernetes Operator 
```bash
kubectl apply -f https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.0.0/standard-install.yaml
helm install ngrok-ingress-controller ngrok/kubernetes-ingress-controller \
  --namespace ngrok-ingress-controller \
  --create-namespace \
  --set credentials.apiKey=$NGROK_API_KEY \
  --set credentials.authtoken=$NGROK_AUTHTOKEN
    --set useExperimentalGatewayApi=true
```
	</TabItem>
</Tabs>



For a more robust _infrastructure as code_ way of passing your credentials, see the [credentials](#credentials-setup) page.

Once installed and healthy, you can try creating an ingress object using the output example from the helm install!

### Alternate options

<Tabs groupId="k8s" queryString="k8s-basic">
	<TabItem value="ingress" label="Ingress Controller" default>
For a quick install, you can also use the combined manifests directly from the repo and begin changing resources:

```bash
kubectl apply -n ngrok-ingress-controller -f https://raw.githubusercontent.com/ngrok/kubernetes-ingress-controller/main/manifest-bundle.yaml
```
	</TabItem>
	<TabItem value="gatewayAPI" label="Gateway API">
:::: note
The above solution is the recommended way to set up the Gateway API
::::
	</TabItem>
</Tabs>

## Credentials

In order to use the ngrok Kubernetes Operator, you will need an ngrok account. Once you have an account, you will need to log into the [ngrok dashboard](https://dashboard.ngrok.com) to gather the necessary credentials.

You will need two things from the dashboard:

- Your auth token, which can be found [here](https://dashboard.ngrok.com/auth/your-authtoken)
- An API key, which can be found [here](https://dashboard.ngrok.com/api)

These credentials will be created as a Kubernetes secret, which the controller will have access to. The auth token is used to create tunnels, and the API key is used to manage edges and other resources via the ngrok API.

### Setup {#credentials-setup}

While the quickstart guide shows you can pass the credential values directly via helm values, we do not recommend this for production scenarios. Instead, we recommend creating a Kubernetes secret and passing the secret name to the helm chart. This allows for easier infrastructure as code in a more secure manner.

### Creating the Secret

To create the secret, follow these steps:

- Make sure the secret is in the same namespace as the ingress controller
- Use a well-formed name that can be passed to the helm chart
- Add two keys to the secret: `API_KEY` and `AUTHTOKEN`

Here is an example secret manifest:

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: ngrok-ingress-controller-credentials
  namespace: ngrok-ingress-controller
data:
  API_KEY: "YOUR-API-KEY-BASE64"
  AUTHTOKEN: "YOUR-AUTHTOKEN-BASE64"
```

## Common Helm K8s Overrides

This section provides some common use cases and recommendations when using this helm chart in a production setting. The Helm chart offers a variety of overrides that are useful for many different use cases in Kubernetes. Below is a list of common recipes that you may find helpful. If your use case is not achievable with the existing set of values, please log an issue detailing your use case and the values you would like to see added. For a full list of values, see [here](https://github.com/ngrok/kubernetes-ingress-controller/blob/main/helm/ingress-controller/values.yaml).

### Deployment Scaling

By default, the replica count is set to 1 via `replicaCount` . We recommend overriding this to 2 or more to ensure high availability during roll-outs and failures, and to spread out the load.

### Image Configuration

The default image tag is `latest`, which is not recommended for production deployments. Instead, you should set the `image.tag` value to a specific version of the controller. You can find available versions in the releases section. Additionally, you may choose to mirror the image to a private registry and set the `image.repository` value to the private registry, along with any required pull secrets.

### Applying Labels and Annotations

You may want to add specific labels or annotations to your resources, to help them be discovered and interact with other services like log scrapers or service meshes. You can set the `commonLabels` and `commonAnnotations` values for all resources created by the helm chart. Additionally, you can set annotations just on the pods themselves by setting the `podAnnotations` value.

### Adding Extra Volumes and Environment Variables

The helm chart also allows you to add extra volumes and environment variables to the operator, which is useful for mounting secrets or configmaps that contain credentials or other configuration values. This can be done by setting the `extraVolumes` and `extraEnv` values.

### ngrok Region

ngrok runs globally distributed tunnel servers around the world to enable fast, low latency traffic to your applications. See https://ngrok.com/docs/network-edge/#points-of-presence for more information on ngrok's regions.

Similar to the agent, if you do not explicitly pick a region via helm when installing the operator, the operator will attempt to pick the region with the least latency, which is usually the one geographically closest to your machine.

See the [helm value `region`](https://github.com/ngrok/kubernetes-ingress-controller/blob/main/helm/ingress-controller/README.md#controller-parameters) to configure a specific region for the controller to use.

## Metrics

This operator exposes prometheus metrics on the `/metrics` endpoint. The metrics are exposed on the `:8080` port and can be scraped by prometheus or other services using typical means.

This project is built using kube-builder, so out of the box it exposes the metrics listed here

https://book.kubebuilder.io/reference/metrics-reference.html?highlight=metrics#default-exported-metrics-references

## White Label Agent Ingress

If you're running the ngrok operator behind a corporate firewall, you may encounter connectivity issues due to the agent or controller not being able to communicate with the ngrok network edge. If you're facing such issues, you can run the ngrok cli command, which is documented [here](https://ngrok.com/docs/guides/running-behind-firewalls) to diagnose the problem.

However, if opening connectivity is not an option, you can set up a custom ingress domain on your dashboard. This way, you can configure the operator to use the custom domain instead of the default ngrok.app domain.

To get started with this, go to your dashboard and create a custom ingress domain. Once created, you can configure the operator by using the following command:

```bash
helm install my-ingress-controller ngrok/kubernetes-ingress-controller \
  --set serverAddr="ngrok.mydomain.com:443"
```

## Multiple Ingress Controller Installations
:::: note
This capability only applies to the Ingress Controller
::::

The Ngrok Kubernetes Ingress Controller supports the Kubernetes concept of [Ingress Classes](https://kubernetes.io/docs/concepts/services-networking/ingress/) which allows you to run multiple ingress controllers in the same cluster. This feature is useful if you want to run multiple versions of the Ngrok Kubernetes Ingress Controller or other ingress controllers in the same cluster.

### What is Ingress Class Filtering?

Ingress controllers work by watching Kubernetes Ingress resources for changes and reconciling them to provide ingress to services. When multiple ingress controllers are installed in the same cluster, they can both try to reconcile all ingress objects by default, which can cause conflicts and unexpected behavior. To address this issue, Ingress Classes can be set on ingress objects and controllers can filter ingresses to only those that match their ingress class.

By default, the Ngrok Kubernetes Ingress Controller creates a non-default ingress class with the name `ngrok`, which the controller watches for changes. In order for the controller to reconcile an ingress, the ingress must have the same ingress class as the controller.

```yaml
spec:
  ...
  ingressClassName: ngrok
  rules:
  ...
```

You can override this name via the helm value `ingressClass.name`, or if there aren't other ingress controllers in the cluster, you can set it to default to be true and not have to add the `ingressClass` to the ingress objects' specs.

### Multiple ngrok Kubernetes Ingress Controller Installations

While it's possible to install multiple versions of the controller right now, they can't watch separate ingress classes yet which would cause them to conflict. https://github.com/ngrok/kubernetes-ingress-controller/issues/87 tracks this work.

### Watching Specific Namespaces

By default, the ingress controller watches all namespaces. It's a common use case to need a controller to watch only a specific namespace in the case where you may run a controller in a namespace for each team or environment. In order to watch only a specific namespace for ingress objects, you can set the helm value [`watchNamespace`](https://github.com/ngrok/kubernetes-ingress-controller/blob/main/helm/ingress-controller/README.md#controller-parameters) to the namespace you want to watch.