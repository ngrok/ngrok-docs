name: Vale Linting

on:
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  vale:
    name: Run Vale
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install dependencies
        run: |
          corepack enable
          corepack install
          pnpm install

      - name: Install Vale
        run: |
          VALE_VERSION=$(curl -s https://api.github.com/repos/errata-ai/vale/releases/latest | grep '"tag_name":' | cut -d '"' -f 4)
          VALE_VERSION_NUM=${VALE_VERSION#v}
          echo "Installing Vale ${VALE_VERSION} (${VALE_VERSION_NUM})"
          wget "https://github.com/errata-ai/vale/releases/download/${VALE_VERSION}/vale_${VALE_VERSION_NUM}_Linux_64-bit.tar.gz" -O vale.tar.gz
          if [ ! -f vale.tar.gz ] || [ ! -s vale.tar.gz ]; then
            echo "Error: Failed to download Vale"
            exit 1
          fi
          tar -xzf vale.tar.gz -C /tmp
          sudo mv /tmp/vale /usr/local/bin/vale
          vale --version

      - name: Run Vale
        id: vale
        continue-on-error: true
        run: |
          set +e
          export PATH="$PATH:$(pwd)/node_modules/.bin"
          vale --output=JSON --glob='!{snippets/**,errors/**,agent/cli-api.mdx,agent/cli.mdx}' . > vale-results.json 2>&1
          VALE_EXIT_CODE=$?
          echo "exit_code=$VALE_EXIT_CODE" >> $GITHUB_OUTPUT
          exit 0

      - name: Parse Vale results and comment on PR
        id: parse_results
        continue-on-error: true
        uses: actions/github-script@v7
        if: github.event_name == 'pull_request' && github.event.pull_request
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            
            let valeResults = {};
            try {
              if (!fs.existsSync('vale-results.json')) {
                console.log('vale-results.json file does not exist');
                valeResults = {};
              } else {
                const valeOutput = fs.readFileSync('vale-results.json', 'utf8');
                console.log('Vale output length:', valeOutput.length);
                console.log('Vale output preview:', valeOutput.substring(0, 200));
                
                const jsonMatch = valeOutput.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                  const parsed = JSON.parse(jsonMatch[0]);
                  if (parsed.Code && parsed.Text) {
                    console.log('Vale encountered an error:', parsed.Text);
                    console.log('Skipping comment posting due to Vale error');
                    return;
                  } else {
                    valeResults = parsed;
                    console.log('Parsed JSON successfully, found', Object.keys(valeResults).length, 'files with issues');
                  }
                } else if (valeOutput.trim() === '' || valeOutput.trim() === '{}') {
                  console.log('No Vale issues found (empty output)');
                  valeResults = {};
                } else {
                  console.log('Could not parse Vale output as JSON. Full output:', valeOutput);
                  valeResults = {};
                }
              }
            } catch (error) {
              console.log('Error parsing Vale JSON output:', error.message);
              console.log('Stack:', error.stack);
              valeResults = {};
            }
            
            const prNumber = context.issue.number;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            
            const issuesByFile = {};
            let totalErrors = 0;
            let totalWarnings = 0;
            let totalSuggestions = 0;
            
            for (const [file, alerts] of Object.entries(valeResults)) {
              if (!alerts || alerts.length === 0) continue;
              
              issuesByFile[file] = {
                errors: [],
                warnings: [],
                suggestions: []
              };
              
              for (const alert of alerts) {
                const severity = alert.Severity?.toLowerCase() || 'suggestion';
                const issue = {
                  line: alert.Line || 0,
                  message: alert.Message || '',
                  check: alert.Check || '',
                  severity: severity
                };
                
                if (severity === 'error') {
                  issuesByFile[file].errors.push(issue);
                  totalErrors++;
                } else if (severity === 'warning') {
                  issuesByFile[file].warnings.push(issue);
                  totalWarnings++;
                } else {
                  issuesByFile[file].suggestions.push(issue);
                  totalSuggestions++;
                }
              }
            }
            
            let commentBody = '## üìù Vale Linting Results\n\n';
            commentBody += '### Summary\n\n';
            if (totalErrors > 0) {
              commentBody += `‚ùå **Errors:** ${totalErrors}\n`;
            }
            if (totalWarnings > 0) {
              commentBody += `‚ö†Ô∏è **Warnings:** ${totalWarnings}\n`;
            }
            if (totalSuggestions > 0) {
              commentBody += `üí° **Suggestions:** ${totalSuggestions}\n`;
            }
            commentBody += '\n---\n\n';
            commentBody += '### Issues by File\n\n';
            for (const [file, issues] of Object.entries(issuesByFile)) {
              const fileErrors = issues.errors.length;
              const fileWarnings = issues.warnings.length;
              const fileSuggestions = issues.suggestions.length;
              
              if (fileErrors === 0 && fileWarnings === 0 && fileSuggestions === 0) continue;
              
              commentBody += `#### \`${file}\`\n\n`;
              
              if (fileErrors > 0) {
                commentBody += `**Errors (${fileErrors}):**\n`;
                for (const error of issues.errors) {
                  commentBody += `- **Line ${error.line}:** ${error.message} \`${error.check}\`\n`;
                }
                commentBody += '\n';
              }
              
              if (fileWarnings > 0) {
                commentBody += `**Warnings (${fileWarnings}):**\n`;
                for (const warning of issues.warnings) {
                  commentBody += `- **Line ${warning.line}:** ${warning.message} \`${warning.check}\`\n`;
                }
                commentBody += '\n';
              }
              
              if (fileSuggestions > 0) {
                commentBody += `**Suggestions (${fileSuggestions}):**\n`;
                for (const suggestion of issues.suggestions.slice(0, 10)) {
                  commentBody += `- **Line ${suggestion.line}:** ${suggestion.message} \`${suggestion.check}\`\n`;
                }
                if (fileSuggestions > 10) {
                  commentBody += `- *... and ${fileSuggestions - 10} more suggestions*\n`;
                }
                commentBody += '\n';
              }
              
              commentBody += '\n';
            }
            
            if (totalErrors > 0 || totalWarnings > 0 || totalSuggestions > 0) {
              const pr = await github.rest.pulls.get({
                owner,
                repo,
                pull_number: prNumber,
              });
              
              const headSha = pr.data.head.sha;
              const prFiles = await github.rest.pulls.listFiles({
                owner,
                repo,
                pull_number: prNumber,
              });
              
              const changedFiles = new Set(prFiles.data.map(f => f.filename));
              
              const postedComments = new Set();
              for (const [file, issues] of Object.entries(issuesByFile)) {
                if (!changedFiles.has(file)) continue;
                
                const allIssues = [...issues.errors, ...issues.warnings];
                if (allIssues.length === 0) continue;
                
                for (const issue of allIssues) {
                  const commentKey = `${file}:${issue.line}:${issue.check}`;
                  if (postedComments.has(commentKey)) continue;
                  postedComments.add(commentKey);
                  
                  try {
                    await github.rest.pulls.createReviewComment({
                      owner,
                      repo,
                      pull_number: prNumber,
                      commit_id: headSha,
                      path: file,
                      line: issue.line,
                      side: 'RIGHT',
                      body: `**${issue.severity.toUpperCase()}**: ${issue.message}\n\n*Rule: \`${issue.check}\`*`
                    });
                  } catch (e) {
                    console.log(`Failed to post comment on ${file}:${issue.line}:`, e.message);
                  }
                }
              }
              
              const comments = await github.rest.issues.listComments({
                owner,
                repo,
                issue_number: prNumber,
              });
              
              const botComment = comments.data.find(
                comment => comment.user.type === 'Bot' && comment.body.includes('Vale Linting Results')
              );
              
              if (botComment) {
                await github.rest.issues.updateComment({
                  owner,
                  repo,
                  comment_id: botComment.id,
                  body: commentBody
                });
              } else {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: prNumber,
                  body: commentBody
                });
              }
            }
            
            try {
              if (fs.existsSync('vale-results.json')) {
                fs.unlinkSync('vale-results.json');
                console.log('Cleaned up vale-results.json');
              }
            } catch (e) {
              console.log('Error cleaning up JSON file:', e.message);
            }
            
            if (typeof core !== 'undefined') {
              core.setOutput('total_errors', totalErrors.toString());
              core.setOutput('total_warnings', totalWarnings.toString());
              core.setOutput('total_suggestions', totalSuggestions.toString());
            }
            
            console.log('Summary: Errors:', totalErrors, 'Warnings:', totalWarnings, 'Suggestions:', totalSuggestions);

      - name: Check results and set status
        id: check_status
        run: |
          if [ -f vale-results.json ]; then
            if command -v jq &> /dev/null; then
              TOTAL_ERRORS=$(jq '[.[] | .[] | select(.Severity == "error")] | length' vale-results.json 2>/dev/null || echo "0")
              TOTAL_WARNINGS=$(jq '[.[] | .[] | select(.Severity == "warning")] | length' vale-results.json 2>/dev/null || echo "0")
            else
              TOTAL_ERRORS=$(grep -o '"Severity":"error"' vale-results.json 2>/dev/null | wc -l || echo "0")
              TOTAL_WARNINGS=$(grep -o '"Severity":"warning"' vale-results.json 2>/dev/null | wc -l || echo "0")
            fi
          else
            TOTAL_ERRORS=0
            TOTAL_WARNINGS=0
          fi
          
          if [ -n "${{ steps.parse_results.outputs.total_errors }}" ]; then
            TOTAL_ERRORS="${{ steps.parse_results.outputs.total_errors }}"
          fi
          if [ -n "${{ steps.parse_results.outputs.total_warnings }}" ]; then
            TOTAL_WARNINGS="${{ steps.parse_results.outputs.total_warnings }}"
          fi
          
          TOTAL_ERRORS=${TOTAL_ERRORS:-0}
          TOTAL_WARNINGS=${TOTAL_WARNINGS:-0}
          
          if [ "$TOTAL_ERRORS" -gt 0 ]; then
            echo "‚ùå Vale found $TOTAL_ERRORS error(s). Please fix them before merging."
            echo "::error::Vale found $TOTAL_ERRORS error(s). Please fix them before merging."
            exit 1
          elif [ "$TOTAL_WARNINGS" -gt 0 ]; then
            echo "‚ö†Ô∏è Vale found $TOTAL_WARNINGS warning(s). Consider addressing them."
            echo "::warning::Vale found $TOTAL_WARNINGS warning(s). Consider addressing them."
          else
            echo "‚úÖ Vale linting passed with no errors or warnings."
          fi

