name: Vale Linting

on:
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  vale:
    name: Run Vale
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Vale
        run: |
          # Install the latest Vale release
          wget -q https://github.com/errata-ai/vale/releases/latest/download/vale_Linux_64-bit.tar.gz -O vale.tar.gz
          tar -xzf vale.tar.gz -C /tmp
          sudo mv /tmp/vale /usr/local/bin/vale
          vale --version

      - name: Run Vale
        id: vale
        continue-on-error: true
        run: |
          set +e
          vale --output=JSON --glob='!{snippets/**,errors/**,agent/cli-api.mdx,agent/cli.mdx}' . > vale-results.json 2>&1
          VALE_EXIT_CODE=$?
          echo "exit_code=$VALE_EXIT_CODE" >> $GITHUB_OUTPUT
          exit 0

      - name: Parse Vale results and comment on PR
        id: parse_results
        continue-on-error: true
        uses: actions/github-script@v7
        if: github.event_name == 'pull_request'
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const core = require('@actions/core');
            
            // Read Vale JSON output
            let valeResults = {};
            try {
              const valeOutput = fs.readFileSync('vale-results.json', 'utf8');
              // Vale might output errors to stderr mixed with JSON, try to extract JSON
              const jsonMatch = valeOutput.match(/\{[\s\S]*\}/);
              if (jsonMatch) {
                valeResults = JSON.parse(jsonMatch[0]);
              } else if (valeOutput.trim() === '' || valeOutput.trim() === '{}') {
                // No issues found
                valeResults = {};
              } else {
                console.log('Could not parse Vale output as JSON:', valeOutput);
                valeResults = {};
              }
            } catch (error) {
              console.log('Error parsing Vale JSON output:', error.message);
              // If there's an error parsing, Vale likely found issues
              // Try to check if file exists and has content
              try {
                const valeOutput = fs.readFileSync('vale-results.json', 'utf8');
                if (valeOutput.trim() && !valeOutput.trim().startsWith('{')) {
                  console.log('Vale output (non-JSON):', valeOutput);
                }
              } catch (e) {
                console.log('No vale-results.json file found');
              }
              valeResults = {};
            }
            
            const context = github.context;
            const prNumber = context.payload.pull_request.number;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            
            // Group issues by file and severity
            const issuesByFile = {};
            let totalErrors = 0;
            let totalWarnings = 0;
            let totalSuggestions = 0;
            
            for (const [file, alerts] of Object.entries(valeResults)) {
              if (!alerts || alerts.length === 0) continue;
              
              issuesByFile[file] = {
                errors: [],
                warnings: [],
                suggestions: []
              };
              
              for (const alert of alerts) {
                const severity = alert.Severity?.toLowerCase() || 'suggestion';
                const issue = {
                  line: alert.Line || 0,
                  message: alert.Message || '',
                  check: alert.Check || '',
                  severity: severity
                };
                
                if (severity === 'error') {
                  issuesByFile[file].errors.push(issue);
                  totalErrors++;
                } else if (severity === 'warning') {
                  issuesByFile[file].warnings.push(issue);
                  totalWarnings++;
                } else {
                  issuesByFile[file].suggestions.push(issue);
                  totalSuggestions++;
                }
              }
            }
            
            // Build comment body
            let commentBody = '## üìù Vale Linting Results\n\n';
            
            if (totalErrors === 0 && totalWarnings === 0 && totalSuggestions === 0) {
              commentBody += '‚úÖ **No issues found!** All files pass Vale linting.\n';
            } else {
              // Summary
              commentBody += '### Summary\n\n';
              if (totalErrors > 0) {
                commentBody += `‚ùå **Errors:** ${totalErrors}\n`;
              }
              if (totalWarnings > 0) {
                commentBody += `‚ö†Ô∏è **Warnings:** ${totalWarnings}\n`;
              }
              if (totalSuggestions > 0) {
                commentBody += `üí° **Suggestions:** ${totalSuggestions}\n`;
              }
              commentBody += '\n---\n\n';
              
              // Detailed results by file
              commentBody += '### Issues by File\n\n';
              for (const [file, issues] of Object.entries(issuesByFile)) {
                const fileErrors = issues.errors.length;
                const fileWarnings = issues.warnings.length;
                const fileSuggestions = issues.suggestions.length;
                
                if (fileErrors === 0 && fileWarnings === 0 && fileSuggestions === 0) continue;
                
                commentBody += `#### \`${file}\`\n\n`;
                
                // Errors
                if (fileErrors > 0) {
                  commentBody += `**Errors (${fileErrors}):**\n`;
                  for (const error of issues.errors) {
                    commentBody += `- **Line ${error.line}:** ${error.message} \`${error.check}\`\n`;
                  }
                  commentBody += '\n';
                }
                
                // Warnings
                if (fileWarnings > 0) {
                  commentBody += `**Warnings (${fileWarnings}):**\n`;
                  for (const warning of issues.warnings) {
                    commentBody += `- **Line ${warning.line}:** ${warning.message} \`${warning.check}\`\n`;
                  }
                  commentBody += '\n';
                }
                
                // Suggestions
                if (fileSuggestions > 0) {
                  commentBody += `**Suggestions (${fileSuggestions}):**\n`;
                  for (const suggestion of issues.suggestions.slice(0, 10)) {
                    commentBody += `- **Line ${suggestion.line}:** ${suggestion.message} \`${suggestion.check}\`\n`;
                  }
                  if (fileSuggestions > 10) {
                    commentBody += `- *... and ${fileSuggestions - 10} more suggestions*\n`;
                  }
                  commentBody += '\n';
                }
                
                commentBody += '\n';
              }
            }
            
            // Find existing comments
            const comments = await github.rest.issues.listComments({
              owner,
              repo,
              issue_number: prNumber,
            });
            
            const botComment = comments.data.find(
              comment => comment.user.type === 'Bot' && comment.body.includes('Vale Linting Results')
            );
            
            // Post or update comment
            if (botComment) {
              await github.rest.issues.updateComment({
                owner,
                repo,
                comment_id: botComment.id,
                body: commentBody
              });
            } else {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: prNumber,
                body: commentBody
              });
            }
            
            // Write counts to output for use in next step
            core.setOutput('total_errors', totalErrors.toString());
            core.setOutput('total_warnings', totalWarnings.toString());
            core.setOutput('total_suggestions', totalSuggestions.toString());

      - name: Check results and set status
        id: check_status
        run: |
          # Parse Vale results to determine status
          if [ -f vale-results.json ]; then
            # Use jq if available, otherwise use a simple grep approach
            if command -v jq &> /dev/null; then
              TOTAL_ERRORS=$(jq '[.[] | .[] | select(.Severity == "error")] | length' vale-results.json 2>/dev/null || echo "0")
              TOTAL_WARNINGS=$(jq '[.[] | .[] | select(.Severity == "warning")] | length' vale-results.json 2>/dev/null || echo "0")
            else
              # Fallback: count occurrences (not perfect but works)
              TOTAL_ERRORS=$(grep -o '"Severity":"error"' vale-results.json 2>/dev/null | wc -l || echo "0")
              TOTAL_WARNINGS=$(grep -o '"Severity":"warning"' vale-results.json 2>/dev/null | wc -l || echo "0")
            fi
          else
            TOTAL_ERRORS=0
            TOTAL_WARNINGS=0
          fi
          
          # Use outputs from parse_results if available (for PRs), otherwise use direct parsing
          if [ -n "${{ steps.parse_results.outputs.total_errors }}" ]; then
            TOTAL_ERRORS="${{ steps.parse_results.outputs.total_errors }}"
          fi
          if [ -n "${{ steps.parse_results.outputs.total_warnings }}" ]; then
            TOTAL_WARNINGS="${{ steps.parse_results.outputs.total_warnings }}"
          fi
          
          # Ensure we have numeric values
          TOTAL_ERRORS=${TOTAL_ERRORS:-0}
          TOTAL_WARNINGS=${TOTAL_WARNINGS:-0}
          
          if [ "$TOTAL_ERRORS" -gt 0 ]; then
            echo "‚ùå Vale found $TOTAL_ERRORS error(s). Please fix them before merging."
            echo "::error::Vale found $TOTAL_ERRORS error(s). Please fix them before merging."
            exit 1
          elif [ "$TOTAL_WARNINGS" -gt 0 ]; then
            echo "‚ö†Ô∏è Vale found $TOTAL_WARNINGS warning(s). Consider addressing them."
            echo "::warning::Vale found $TOTAL_WARNINGS warning(s). Consider addressing them."
          else
            echo "‚úÖ Vale linting passed with no errors or warnings."
          fi

