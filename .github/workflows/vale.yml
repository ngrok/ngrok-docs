name: Vale Linting

on:
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  vale:
    name: Run Vale
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Vale
        run: |
          # Install Vale from latest release
          VALE_VERSION=$(curl -s https://api.github.com/repos/errata-ai/vale/releases/latest | grep '"tag_name":' | cut -d '"' -f 4)
          VALE_VERSION_NUM=${VALE_VERSION#v}
          echo "Installing Vale ${VALE_VERSION} (${VALE_VERSION_NUM})"
          wget "https://github.com/errata-ai/vale/releases/download/${VALE_VERSION}/vale_${VALE_VERSION_NUM}_Linux_64-bit.tar.gz" -O vale.tar.gz
          if [ ! -f vale.tar.gz ] || [ ! -s vale.tar.gz ]; then
            echo "Error: Failed to download Vale"
            exit 1
          fi
          tar -xzf vale.tar.gz -C /tmp
          sudo mv /tmp/vale /usr/local/bin/vale
          vale --version

      - name: Run Vale
        id: vale
        continue-on-error: true
        run: |
          set +e
          vale --output=JSON --glob='!{snippets/**,errors/**,agent/cli-api.mdx,agent/cli.mdx}' . > vale-results.json 2>&1
          VALE_EXIT_CODE=$?
          echo "exit_code=$VALE_EXIT_CODE" >> $GITHUB_OUTPUT
          exit 0

      - name: Parse Vale results and comment on PR
        id: parse_results
        continue-on-error: true
        uses: actions/github-script@v7
        if: github.event_name == 'pull_request' && github.event.pull_request
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            
            // Read Vale JSON output
            let valeResults = {};
            try {
              if (!fs.existsSync('vale-results.json')) {
                console.log('vale-results.json file does not exist');
                valeResults = {};
              } else {
                const valeOutput = fs.readFileSync('vale-results.json', 'utf8');
                console.log('Vale output length:', valeOutput.length);
                console.log('Vale output preview:', valeOutput.substring(0, 200));
                
                // Vale might output errors to stderr mixed with JSON, try to extract JSON
                const jsonMatch = valeOutput.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                  const parsed = JSON.parse(jsonMatch[0]);
                  // Check if this is an error object (has Code, Text, etc) rather than file-based results
                  if (parsed.Code && parsed.Text) {
                    console.log('Vale encountered an error:', parsed.Text);
                    console.log('Skipping comment posting due to Vale error');
                    valeResults = {};
                  } else {
                    valeResults = parsed;
                    console.log('Parsed JSON successfully, found', Object.keys(valeResults).length, 'files with issues');
                  }
                } else if (valeOutput.trim() === '' || valeOutput.trim() === '{}') {
                  // No issues found
                  console.log('No Vale issues found (empty output)');
                  valeResults = {};
                } else {
                  console.log('Could not parse Vale output as JSON. Full output:', valeOutput);
                  valeResults = {};
                }
              }
            } catch (error) {
              console.log('Error parsing Vale JSON output:', error.message);
              console.log('Stack:', error.stack);
              valeResults = {};
            }
            
            // Get PR info - use event data as fallback
            let prNumber, owner, repo;
            try {
              // Try github.context.payload first
              if (github && github.context && github.context.payload && github.context.payload.pull_request) {
                prNumber = github.context.payload.pull_request.number;
                owner = github.context.repo.owner;
                repo = github.context.repo.repo;
              } 
              // Fallback to github.event
              else if (github && github.event && github.event.pull_request) {
                prNumber = github.event.pull_request.number;
                owner = github.context.repo.owner;
                repo = github.context.repo.repo;
              } 
              // Last resort - use context.repo and event.number
              else if (github && github.context && github.context.repo) {
                prNumber = github.event.number || github.event.issue?.number;
                owner = github.context.repo.owner;
                repo = github.context.repo.repo;
              } else {
                console.log('Could not determine PR context. github:', !!github, 'context:', !!github?.context, 'event:', !!github?.event);
                return;
              }
              
              if (!prNumber || !owner || !repo) {
                console.log('Missing required PR info. prNumber:', prNumber, 'owner:', owner, 'repo:', repo);
                return;
              }
            } catch (e) {
              console.log('Error getting PR context:', e.message);
              console.log('Stack:', e.stack);
              return;
            }
            
            // Group issues by file and severity
            const issuesByFile = {};
            let totalErrors = 0;
            let totalWarnings = 0;
            let totalSuggestions = 0;
            
            for (const [file, alerts] of Object.entries(valeResults)) {
              if (!alerts || alerts.length === 0) continue;
              
              issuesByFile[file] = {
                errors: [],
                warnings: [],
                suggestions: []
              };
              
              for (const alert of alerts) {
                const severity = alert.Severity?.toLowerCase() || 'suggestion';
                const issue = {
                  line: alert.Line || 0,
                  message: alert.Message || '',
                  check: alert.Check || '',
                  severity: severity
                };
                
                if (severity === 'error') {
                  issuesByFile[file].errors.push(issue);
                  totalErrors++;
                } else if (severity === 'warning') {
                  issuesByFile[file].warnings.push(issue);
                  totalWarnings++;
                } else {
                  issuesByFile[file].suggestions.push(issue);
                  totalSuggestions++;
                }
              }
            }
            
            // Build comment body
            let commentBody = '## üìù Vale Linting Results\n\n';
            
            // Summary
            commentBody += '### Summary\n\n';
            if (totalErrors > 0) {
              commentBody += `‚ùå **Errors:** ${totalErrors}\n`;
            }
            if (totalWarnings > 0) {
              commentBody += `‚ö†Ô∏è **Warnings:** ${totalWarnings}\n`;
            }
            if (totalSuggestions > 0) {
              commentBody += `üí° **Suggestions:** ${totalSuggestions}\n`;
            }
            commentBody += '\n---\n\n';
            
            // Detailed results by file
            commentBody += '### Issues by File\n\n';
            for (const [file, issues] of Object.entries(issuesByFile)) {
              const fileErrors = issues.errors.length;
              const fileWarnings = issues.warnings.length;
              const fileSuggestions = issues.suggestions.length;
              
              if (fileErrors === 0 && fileWarnings === 0 && fileSuggestions === 0) continue;
              
              commentBody += `#### \`${file}\`\n\n`;
              
              // Errors
              if (fileErrors > 0) {
                commentBody += `**Errors (${fileErrors}):**\n`;
                for (const error of issues.errors) {
                  commentBody += `- **Line ${error.line}:** ${error.message} \`${error.check}\`\n`;
                }
                commentBody += '\n';
              }
              
              // Warnings
              if (fileWarnings > 0) {
                commentBody += `**Warnings (${fileWarnings}):**\n`;
                for (const warning of issues.warnings) {
                  commentBody += `- **Line ${warning.line}:** ${warning.message} \`${warning.check}\`\n`;
                }
                commentBody += '\n';
              }
              
              // Suggestions
              if (fileSuggestions > 0) {
                commentBody += `**Suggestions (${fileSuggestions}):**\n`;
                for (const suggestion of issues.suggestions.slice(0, 10)) {
                  commentBody += `- **Line ${suggestion.line}:** ${suggestion.message} \`${suggestion.check}\`\n`;
                }
                if (fileSuggestions > 10) {
                  commentBody += `- *... and ${fileSuggestions - 10} more suggestions*\n`;
                }
                commentBody += '\n';
              }
              
              commentBody += '\n';
            }
            
            // Only post comment if there are issues to report
            if (totalErrors > 0 || totalWarnings > 0 || totalSuggestions > 0) {
              // Find existing comments
              const comments = await github.rest.issues.listComments({
                owner,
                repo,
                issue_number: prNumber,
              });
              
              const botComment = comments.data.find(
                comment => comment.user.type === 'Bot' && comment.body.includes('Vale Linting Results')
              );
              
              // Post or update comment
              if (botComment) {
                await github.rest.issues.updateComment({
                  owner,
                  repo,
                  comment_id: botComment.id,
                  body: commentBody
                });
              } else {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: prNumber,
                  body: commentBody
                });
              }
            }
            
            // Write counts to output for use in next step
            // core is available in github-script context
            if (typeof core !== 'undefined') {
              core.setOutput('total_errors', totalErrors.toString());
              core.setOutput('total_warnings', totalWarnings.toString());
              core.setOutput('total_suggestions', totalSuggestions.toString());
            }
            
            console.log('Summary: Errors:', totalErrors, 'Warnings:', totalWarnings, 'Suggestions:', totalSuggestions);

      - name: Check results and set status
        id: check_status
        run: |
          # Parse Vale results to determine status
          if [ -f vale-results.json ]; then
            # Use jq if available, otherwise use a simple grep approach
            if command -v jq &> /dev/null; then
              TOTAL_ERRORS=$(jq '[.[] | .[] | select(.Severity == "error")] | length' vale-results.json 2>/dev/null || echo "0")
              TOTAL_WARNINGS=$(jq '[.[] | .[] | select(.Severity == "warning")] | length' vale-results.json 2>/dev/null || echo "0")
            else
              # Fallback: count occurrences (not perfect but works)
              TOTAL_ERRORS=$(grep -o '"Severity":"error"' vale-results.json 2>/dev/null | wc -l || echo "0")
              TOTAL_WARNINGS=$(grep -o '"Severity":"warning"' vale-results.json 2>/dev/null | wc -l || echo "0")
            fi
          else
            TOTAL_ERRORS=0
            TOTAL_WARNINGS=0
          fi
          
          # Use outputs from parse_results if available (for PRs), otherwise use direct parsing
          if [ -n "${{ steps.parse_results.outputs.total_errors }}" ]; then
            TOTAL_ERRORS="${{ steps.parse_results.outputs.total_errors }}"
          fi
          if [ -n "${{ steps.parse_results.outputs.total_warnings }}" ]; then
            TOTAL_WARNINGS="${{ steps.parse_results.outputs.total_warnings }}"
          fi
          
          # Ensure we have numeric values
          TOTAL_ERRORS=${TOTAL_ERRORS:-0}
          TOTAL_WARNINGS=${TOTAL_WARNINGS:-0}
          
          if [ "$TOTAL_ERRORS" -gt 0 ]; then
            echo "‚ùå Vale found $TOTAL_ERRORS error(s). Please fix them before merging."
            echo "::error::Vale found $TOTAL_ERRORS error(s). Please fix them before merging."
            exit 1
          elif [ "$TOTAL_WARNINGS" -gt 0 ]; then
            echo "‚ö†Ô∏è Vale found $TOTAL_WARNINGS warning(s). Consider addressing them."
            echo "::warning::Vale found $TOTAL_WARNINGS warning(s). Consider addressing them."
          else
            echo "‚úÖ Vale linting passed with no errors or warnings."
          fi

