export const IntegrationPageList = ({ name }) => {

	const integrations = [
		{
		  "name": "1password",
		  "path": "/integrations/1password",
		  "docs": [
			{
			  "path": "/integrations/1password/cli-client",
			  "frontMatter": {
				"title": "1Password ngrok shell plugin",
				"description": "Secure your ngrok credentials with 1Password",
				"tags": [
				  "1password",
				  "security",
				  "password vault",
				  "command line"
				]
			  },
			  "content": "\n# 1Password CLI Integration for ngrok\n<Tip>\n**TL;DR**\n\n\n\nTo activate the 1Password ngrok shell plugin:\n\n1. [Sign up for 1Password](https://1password.com/sign-up/)\n1. Install and sign in to [1Password](https://support.1password.com/get-the-apps/) on your machine\n1. Install the [1Password CLI](https://app-updates.agilebits.com/product_history/CLI2) on your machine\n1. [Integrate the 1Password CLI with the 1Password desktop app](https://developer.1password.com/docs/cli/app-integration)\n1. Import your ngrok credentials into 1Password\n1. Launch ngrok\n</Tip>\n\nThis guide covers how to set up the 1Password CLI with the ngrok shell extension to store and access your ngrok credentials via 1Password. This combination gives you the speed and simplicity of ngrok protected by the power of 1Password’s vault.\n\nBy integrating ngrok with 1Password, you can:\n\n- _Store your credentials in exactly one place_, limiting the risk of not updating environments after resetting tokens\n- _Share credentials between environments securely_, eliminating the risk of copy and pasting credentials in other tools or reusing credentials between multiple projects accidentally\n- _Switch between credentials as necessary_ to test with different ngrok configurations, feature sets, or even accounts\n\nPrerequisites:\n\n- A 1Password account\n- [1Password desktop app](https://support.1password.com/get-the-apps/) installed on your machine (v8 or later)\n- [1Password CLI](https://app-updates.agilebits.com/product_history/CLI2) installed on your machine (v2.14.0 or later)\n- [ngrok](https://download.ngrok.com) installed on your machine\n- Basic familiarity with the command line\n\nTip: One of the easiest mistakes is failing to connect the App to the CLI. In the 1Password App, go to Settings > Developer and select “Connect with the 1Password CLI”\n\n## **Step 1**: Initialize the 1Password ngrok shell plugin\n\nTo configure the ngrok shell extension, open a terminal and run this command:\n\n```bash\nop plugin init ngrok\n```\n\nIf you are logged into the 1Password app, you will be presented with a permission request:\n\n![Initialize the 1Password ngrok shell plugin](img/1password-connect-app-to-cli.png)\n\nOtherwise you will be forced to authenticate and then will be presented with this request. Choose “Allow Access” and you will be presented with a command line option:\n\n![Import your ngrok credentials into 1Password](img/1password-add-ngrok-authtoken.png)\n\nFor initialization, select “Import into 1Password,” copy and paste your ngrok authtoken into the command line, and hit enter. Next, give it a memorable name. Finally, choose when you want to use it. The entire configuration looks like:\n\n![Import your ngrok credentials into 1Password](img/1password-add-ngrok-authtoken.gif)\n\n## **Step 2**: Clean up your ngrok.yml file\n\nNow that your credentials are safely in your 1Password vault, you can remove them from your local environment. Use your text editor to update .ngrok2/ngrok.yml and remove the authtoken value:\n\n```bash\nvim .ngrok2/ngrok.yml\n```\n\nYou can delete the entire authtoken line right now but to test safely, you can alternatively prefix the line with a pound sign (#). Either way, ngrok will no longer find and use that value.\n\n## **Step 3**: Start your tunnel\n\nNow that we have our environment configured, we start our tunnel. 1Password will intercept the request, determine which credential to use, and start a tunnel as we requested.\n\n![Import your ngrok credentials into 1Password](img/1password-start-ngrok.gif)\n\nBy following this guide, you have successfully integrated the 1Password CLI with ngrok, allowing you to securely manage your ngrok credentials and even choose between multiple credentials at runtime to demonstrate and test under different configurations.\n",
			  "contentTitle": "1Password ngrok shell plugin"
			}
		  ],
		  "metadata": {
			"name": "1password",
			"description": "",
			"excerpt": "",
			"title": "1Password"
		  }
		},
		{
		  "name": "aftership",
		  "path": "/integrations/aftership",
		  "docs": [
			{
			  "path": "/integrations/aftership/webhooks",
			  "frontMatter": {
				"description": "Develop and test AfterShip webhooks from localhost",
				"title": "AfterShip Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate AfterShip webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure AfterShip webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with AfterShip by using Webhooks.\nAfterShip webhooks can be used to notify an external application whenever specific events occur in your AfterShip account.\n\nBy integrating ngrok with AfterShip, you can:\n\n- **Develop and test AfterShip webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from AfterShip** in real-time via the inspection UI and API.\n- **Modify and Replay AfterShip Webhook requests** with a single click and without spending time reproducing events manually in your AfterShip account.\n- **Secure your app with AfterShip validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with AfterShip).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate AfterShip \n\nTo register a webhook on your AfterShip account follow the instructions below:\n\n1. Access [AfterShip](https://www.aftership.com/) and sign in using your AfterShip account.\n\n1. On the left menu, click **Notifications** and then click **Webhooks**.\n\n1. On the **Webhooks** page, click **Add webhook URL**.\n\n1. On the **Add webhook URL** popup, enter the URL provided by the ngrok agent to expose your application to the internet in the **Webhook URL** field (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![aftership URL to Publish](img/ngrok_url_configuration_aftership.png)\n\n1. Click **Save**.\n\n   Confirm your localhost app receives a notification and logs both headers and body in the terminal.\n\n### Run Webhooks with AfterShip and ngrok\n\nAfterShip sends different request body contents depending on the status of the shipments created in your account.\nYou can trigger new calls from AfterShip to your application by following the instructions below.\n\n1. On the [AfterShip console](https://admin.aftership.com/), click **Shipments** on the left menu and then click **Add shipment**.\n\n1. On the **Add new shipment** page, enter a tracking number in the **Tracking no.** field and then click **Save shipment**. Optionally, you can fill in all fields on this page.\n\n   Confirm your localhost app receives an event notification and logs both headers and body in the terminal.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your AfterShip webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Access [AfterShip](https://www.aftership.com/) and sign in using your AfterShip account.\n\n1. On the left menu, click **Notifications** and then click **Webhooks**.\n\n1. On the **Webhooks** page, copy the value of the **Webhook secret**.\n\n1. Create a traffic policy file named `aftership_policy.yml`, replacing `{your webhook secret}` with the value you have copied before (See [Integrate ngrok and AfterShip.](#setup-webhook)):\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: aftership\n             secret: \"{your webhook secret}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file aftership_policy.yml\n   ```\n\n1. Access [AfterShip](https://www.aftership.com/) and create a new shipment.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "AfterShip Webhooks"
			}
		  ],
		  "metadata": {
			"name": "aftership",
			"description": "",
			"excerpt": "",
			"title": "AfterShip"
		  }
		},
		{
		  "name": "airship",
		  "path": "/integrations/airship",
		  "docs": [
			{
			  "path": "/integrations/airship/webhooks",
			  "frontMatter": {
				"description": "Develop and test Airship webhooks from localhost",
				"title": "Airship Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Airship webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Airship webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Airship by using Webhooks.\nYou can configure an open channel to deliver notifications to any device through webhooks.\n\nBy integrating ngrok with Airship, you can:\n\n- **Develop and test Airship webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Airship** in real-time via the inspection UI and API.\n- **Modify and Replay Airship Webhook requests** with a single click and without spending time reproducing events manually in your Airship account.\n- **Secure your app with Airship validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Airship).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Airship \n\nTo register a webhook on your Airship account follow the instructions below:\n\n1. Access [Airship](https://www.airship.com/) and sign in using your Airship account.\n\n1. On the **App Projects** page, click on one of your projects.\n\n1. On the top menu, click **Settings**, click **Open Channels** under the **Channels** section, and then click **Configure new Open Channel**.\n\n1. Enter `My Local Webhook` in the **Display Name** field, enter `MyLocalWebhook` in the **Name** field, and enter the URL provided by the ngrok agent to expose your application to the internet in the **Webhook URL** field (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![Webhook URL](img/ngrok_url_configuration_airship.png)\n\n1. Click **Save**.\n\n### Run Webhooks with Airship and ngrok\n\nAirship sends different request body contents depending on the event that is being triggered.\nYou can trigger new calls from Airship to your application by following the instructions below.\n\n1. Access your Airship application from the [Applications](https://go.airship.com/apps/) page.\n\n1. On the top menu, click **Messages**, click **Messages Overview**, and then click the **+** icon on the top right corner of the page.\n\n1. On the **What would you like to create** page, click the **Message** tile.\n\n1. On the **Who will receive your message** page, select **My Local Webhook** as the channel and select the users.\n\n1. Click **Content** on the top menu, click **Custom Message**, and enter any text in the **Alert Text** field.\n\n1. Click **Delivery** on the top menu and click **Send now**.\n\n1. Click **Review & Send** on the top menu and click **Send Message**.\n\n   Confirm your localhost app receives event notifications and logs both headers and body in the terminal.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Airship webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Access your Airship application from the [Applications](https://go.airship.com/apps/) page.\n\n1. On the top menu, click **Settings**, click **Open Channels** under the **Channels** section, and then click **Edit** in the **My Local Webhook** tile.\n\n1. Select **Signature** in the **Authentication** field, enter `12345` in the **Secret Key** field, and then click **Update**.\n\n1. Create a traffic policy file named `airship_policy.yml`, replacing `{your webhook secret}` with the value of the **Secret Key** field:\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: airship\n             secret: \"{your webhook secret}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file airship_policy.yml\n   ```\n\n1. Access your [Airship](https://www.airship.com) application and create a new message.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "Airship Webhooks"
			}
		  ],
		  "metadata": {
			"name": "airship",
			"description": "",
			"excerpt": "",
			"title": "Airship"
		  }
		},
		{
		  "name": "alchemy",
		  "path": "/integrations/alchemy",
		  "docs": [
			{
			  "path": "/integrations/alchemy/webhooks",
			  "frontMatter": {
				"description": "Develop and test Alchemy webhooks from localhost",
				"title": "Alchemy Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\nTo integrate Alchemy webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Alchemy webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Alchemy by using Webhooks.\nAlchemy webhooks can be used to notify an external application whenever specific events occur in your Alchemy account.\n\nBy integrating ngrok with Alchemy, you can:\n\n- **Develop and test Alchemy webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Alchemy** in real time via the inspection UI and API.\n- **Modify and Replay Alchemy Webhook requests** with a single click and without spending time reproducing events manually in your Alchemy account.\n- **Secure your app with Alchemy validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Alchemy).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Alchemy \n\nTo register a webhook on your Alchemy account follow the instructions below:\n\n1. Access the [Alchemy dashboard](https://dashboard.alchemy.com/) and sign in using your Alchemy account.\n\n1. On the left menu, click the **Data** icon and then click **Webhooks**.\n\n1. On the **Webhooks** page, click **Create Webhook** for one of the types presented on the screen.\n   In this tutorial, click **Create Webhook** for the **Address Activity** type.\n\n1. Select the **Chain** and the **Network** you want to monitor activities and then enter the URL provided by the ngrok agent to expose your application to the internet in the **WEBHOOK URL** field (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![Alchemy ENDPOINT URL](img/ngrok_url_configuration_alchemy.png)\n\n1. Click **Test Webhook** and verify your localhost application receives a notification event.\n\n1. Enter your wallet address in the **Ethereum Address** field and then click **Create Webhook**.\n\n### Run Webhooks with Alchemy and ngrok\n\nAlchemy sends different request body contents depending on the type of webhook.\n\nIn this example, because you chose the **Address Activity** webhook, you need to receive or send tokens to your address.\n\nTo test your webhook, follow the steps below:\n\n1. Access the [Alchemy dashboard](https://dashboard.alchemy.com/) and sign in using your Alchemy account.\n\n1. On the left menu, click the **Data** icon and then click **Webhooks**.\n\n1. On the **Webhooks** page, scroll down to the **Address Activity** section, click the 3 dots for the webhook you registered, and then click **Send Test Notification**.\n\n   Confirm your localhost app receives the test event notification and logs both headers and body in the terminal.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Alchemy webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Access the [Alchemy dashboard](https://dashboard.alchemy.com/) and sign in using your Alchemy account.\n\n1. On the left menu, click the **Data** icon and then click **Webhooks**.\n\n1. On the **Webhooks** page, scroll down to the **Address Activity** section, click the 3 dots for the webhook you registered, and then click **Signing Key**.\n\n1. On the pop-up, copy the value of the **Signing key** field and click **Close**.\n\n1. Create a traffic policy file named `alchemy_policy.yml`, replacing `{your signing key}` with the value you have copied before:\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: alchemy\n             secret: \"{your signing key}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file alchemy_policy.yml\n   ```\n\n**Note**: After restarting the ngrok agent, the address of the agent will be modified.\nBecause Alchemy doesn't allow you to edit your webhook registration,\nit's recommended that you create a domain on your ngrok account, and run the agent using the following parameter `--url https://myexample.ngrok.app`\n\n1. Access the [Alchemy dashboard](https://dashboard.alchemy.com/) and test the webhook endpoint or create an event by using the Alchemy SDK.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "Alchemy Webhooks"
			}
		  ],
		  "metadata": {
			"name": "alchemy",
			"description": "",
			"excerpt": "",
			"title": "Alchemy"
		  }
		},
		{
		  "name": "amazon",
		  "path": "/integrations/amazon",
		  "docs": [
			{
			  "path": "/integrations/amazon/oauth",
			  "frontMatter": {
				"description": "Authenticate users with Amazon OAuth",
				"title": "Amazon OAuth"
			  },
			  "content": "import Amazon from \"/snippets/traffic-policy/actions/oauth/examples/custom-amazon-example.mdx\";\nimport UpdatePolicyInstructions from \"/snippets/traffic-policy/actions/oauth/update-policy/update-policy-instructions.mdx\";\n\n\n\n## Configure Login with Amazon\n\nThe step-by-step instructions below follow Amazon's documentation on [Register for Login with Amazon](https://developer.amazon.com/docs/login-with-amazon/register-web.html) for websites.\n\n### Create a Security Profile for ngrok\n\n1.  Navigate to the [Login with Amazon](https://developer.amazon.com/loginwithamazon/console/site/lwa/overview.html) portal, and sign in with your Amazon Developer credentials.\n\n    <Note>\n    If you don't have a developer account, you'll need to sign up for a new one.\n    </Note>\n\n2.  Click **Create a New Security Profile**, provide a **Name** and a **Description** for your security profile, enter the privacy URL provided by your application (i.e. `https://ngrok.com/privacy`) in the **Consent Privacy Notice URL**, and then click **Save**.\n    ![](/img/howto/oauth/1-amazon-register.png)\n\n3.  Click **Show Client ID and Client Secret** to reveal your **Client ID** and **Client Secret** values and make a note of both of them.\n\n4.  Hover over the gear icon of the **Security Profile** you created and then click **Web Settings**.\n\n5.  On the **Security Profile** page, click **Edit**, enter `https://idp.ngrok.com/oauth2/callback` in the **Allowed Return URLs** field, and then click **Save**.\n    ![](/img/howto/oauth/2-amazon-register.png)\n\n### Update your ngrok endpoint traffic policy\n\n<UpdatePolicyInstructions showScopesTip={true} policySnippet={<Amazon />} />\n\n### Additional application setup information\n\n- [Login with Amazon Documentation](https://developer.amazon.com/docs/login-with-amazon/documentation-overview.html)\n- [Login with Amazon for Websites Overview](https://developer.amazon.com/docs/login-with-amazon/web-docs.html)\n",
			  "contentTitle": "Amazon OAuth"
			}
		  ],
		  "metadata": {
			"name": "amazon",
			"description": "",
			"excerpt": "",
			"title": "Amazon"
		  }
		},
		{
		  "name": "amazon-cloudwatch",
		  "path": "/integrations/amazon-cloudwatch",
		  "docs": [
			{
			  "path": "/integrations/amazon-cloudwatch/event-destination",
			  "frontMatter": {
				"title": "Send Network Logs from ngrok to AWS CloudWatch",
				"description": "Send network traffic logs from ngrok to AWS CloudWatch",
				"tags": [
				  "events",
				  "logs",
				  "cloudwatch",
				  "aws",
				  "event destinations"
				]
			  },
			  "content": "\n# AWS CloudWatch Event Destination\n<Tip>\n**TL;DR**\n\n\n\nTo send ngrok events to CloudWatch:\n\n1. [Obtain CloudWatch log group ARN](#obtain-cloudwatch-arn)\n1. [Create Log Export](#create-log-export)\n1. [Create Event Destination](#create-destination)\n</Tip>\n\nThis guide covers how to send ngrok events including network traffic logs into AWS CloudWatch.\nYou may want to keep an audit log of configuration changes within your ngrok\naccount, record all traffic to your endpoints for active monitoring/troubleshooting, or\nyou may use AWS CloudWatch as a SIEM and want to use it for security inspections.\n\nBy integrating ngrok with CloudWatch, you can:\n\n- **Quickly identify application issues** in real-time using ngrok request events using CloudWatch visibility.\n- **Historically audit changes occurring within an account**. Be able to historically audit changes within an account.\n- **Profile usage of your service** by using CloudWatch queries and analytic charts.\n- **Identify security issues** by using ngrok events.\n\n## **Step 1**: Obtain CloudWatch Log Group ARN \n\nFor ngrok to successfully send events into CloudWatch we'll require a log group ARN. To\neither create or retrieve the ARN, reference the following [AWS CloudWatch\nGuide](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html#Create-Log-Group).\nYou may also reference the [AWS Log role\ndocumentation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-logs-loggroup.html).\n\n## **Step 2**: Create a Log Export \n\n1. Using a browser, go to the [ngrok dashboard](https://dashboard.ngrok.com) and navigate to **Events Stream** under the **Traffic Observability** section on the left hand navigation and select **Create Subscription**.\n\n   ![ngrok log export](img/event_sub.png)\n\n2. Within the Log Exporting configuration, provide a description for the export and within the sources tab select **Add Source** to choose which events you would like to send to CloudWatch.\n\nOnce complete, select **Add Event Sources** to confirm your selections.\n\n![ngrok event sources](img/event_sources.png)\n\n## **Step 3**: Create Event Destination \n\nTo send the events to CloudWatch we'll need to assign an Event Destination to the Log Export.\n\n1. Within the Log Exporting configuration Destination Tab, select **Add Destination.**\n\n2. Choose AWS CloudWatch Logs as the target and fill in the correct information.\n   - **Log Group ARN**\n   - **Description** - Optional\n\n3. **Create IAM Role** - An IAM role is required to allow ngrok to stream logs into\n   CloudWatch. Using the information provided by your preferred method of creation, either\n   **API** or **CLI Script**, create the IAM role and provide the role ARN. For the\n   fastest integration or proof of concept, we recommend using the **CLI Script**.\n<Note>\n**SECURITY BEST PRACTICE**\n\n\n\nIf configuring your IAM role manually, ensure that you configure the Trust Policy with a\ncondition that includes the ExternalId. This will ensure that the only data allowed to\ningested by AWS will be from your ngrok account. If you configure the IAM role with the\nCLI script, this will be done automatically.\n</Note>\n\n![ngrok event destination](img/event_destination.png)\n\n4. Once all required inputs have values, select **Send Test Event** and you should be presented with a Success message. Select **Done** and the CloudWatch Event Destination setup is complete.\n\n![ngrok event destination success](img/success.png)\n",
			  "contentTitle": "Send Network Logs from ngrok to AWS CloudWatch"
			}
		  ],
		  "metadata": {
			"name": "amazon-cloudwatch",
			"description": "",
			"excerpt": "",
			"title": "Amazon CloudWatch"
		  }
		},
		{
		  "name": "amazon-eks",
		  "path": "/integrations/amazon-eks",
		  "docs": [
			{
			  "path": "/integrations/amazon-eks/eks",
			  "frontMatter": {
				"title": "Kubernetes ingress to services hosted on EKS",
				"description": "Learn how to get started running the ngrok Kubernetes Operator on AWS EKS",
				"tags": [
				  "kubernetes",
				  "k8s",
				  "eks",
				  "elastic kubernetes service",
				  "ingress controller",
				  "kubernetes operator",
				  "operator"
				]
			  },
			  "content": "\nThe [ngrok Kubernetes Operator](https://github.com/ngrok/ngrok-operator) is our official open-source controller for adding public and secure ingress traffic to your k8s services. It works out of the box with n AWS EKS Kubernetes cluster to provide ingress to your services no matter the network configuration, as long as it has outbound access to the ngrok service. This allows ngrok to be portable and work seamlessly across any type of infrastructure.\n\n## What you'll need\n\n- An [AWS EKS cluster](https://eksctl.io/usage/creating-and-managing-clusters/).\n- An [ngrok account](https://ngrok.com/signup).\n- [kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl/) and [Helm\n  3.0.0+](https://helm.sh/docs/intro/install/) installed on your local\n  workstation.\n- The [ngrok Kubernetes Operator](/k8s/) installed on\n  your cluster.\n- A reserved domain, which you can get in the ngrok\n  [dashboard](https://dashboard.ngrok.com/domains) or with the [ngrok\n  API](/api/resources/reserved-domains/).\n  - You can choose from an ngrok subdomain or bring your own custom branded\n    domain, like `https://api.example.com`.\n  - We'll refer to this domain as `<NGROK_DOMAIN>`.\n\n## Ensure `kubectl` can speak with your cluster \n\nWith an AWS EKS cluster, authentication for `kubectl` happens with a credential helper. So in-order to deploy the ngrok Kubernetes Operator to your cluster, you'll need to ensure that you can use the `aws` CLI and that the credential helper is available.\n\nRecent versions of `eksctl` rely on the `aws eks get-token` command, which requires the `aws` CLI to be at-least version `1.16.156`.\n\nLet's ensure that you have the `aws` CLI installed and configured with your AWS credentials. You can confirm this works and you're authenticated correctly by running the following command:\n\n```bash\naws --version\naws sts get-caller-identity\n```\n\nIf this works, we can now request a kubeconfig:\n\n```bash\n# This will merge the cluster into your $KUBECONFIG or ~/.kube/config\naws eks update-kubeconfig --region <region-code> --name <my-cluster>\n\n# To keep your kubeconfig isolated, use:\naws eks update-kubeconfig --kubeconfig kubeconfig --region <region-code> --name <my-cluster>\nexport KUBECONFIG=$(pwd)/kubeconfig\n```\n\n## Install a sample application and Kubernetes ingress \n\nCreate a manifest file (for example `ngrok-manifest.yaml`) with the following contents. You will need to replace the `NGROK_DOMAIN` on line 45 with your own custom value. This is the URL you will use to access your service from anywhere. If you're on a free account, it must be on a static subdomain which you can claim by logging into your account and following the instructions on the claim static subdomain banner. For paid accounts, you can use a custom domain or a subdomain of `ngrok.app` or `ngrok.dev` (for example, `username-loves-ingress.ngrok.app` or `k8s.example.com`).\n\n```yaml showLineNumbers\napiVersion: v1\nkind: Service\nmetadata:\n  name: game-2048\nspec:\n  ports:\n    - name: http\n      port: 80\n      targetPort: 80\n  selector:\n    app: game-2048\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: game-2048\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: game-2048\n  template:\n    metadata:\n      labels:\n        app: game-2048\n    spec:\n      containers:\n        - name: backend\n          image: alexwhen/docker-2048\n          ports:\n            - name: http\n              containerPort: 80\n---\n# Configuration for ngrok's Kubernetes Operator\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: game-2048-ingress\n  namespace: default\nspec:\n  ingressClassName: ngrok\n  rules:\n    - host: <NGROK_DOMAIN>\n      http:\n        paths:\n          - path: /\n            pathType: Prefix\n            backend:\n              service:\n                name: game-2048\n                port:\n                  number: 80\n```\n\n1. Apply the manifest file to your k8s cluster.\n\n   ```bash\n   kubectl apply -f ngrok-manifest.yaml\n   ```\n\n   **Note:** If you get an error when applying the manifest, double check that you've updated the `NGROK_DOMAIN` value and try again.\n\n1. Access your ingress URL using the subdomain you chose in the manifest file above (i.e. `https://my-awesome-k8s-cluster.ngrok.app`) to confirm the 2048 app is accessible from the internet.\n\n   ![application public](/img/howto/kubernetes-operator/k8s-ingress-app-2.png)\n\n## Add edge security to your app \n\nWith our [Traffic Policy system](/traffic-policy/) and the [`oauth`\naction](/traffic-policy/actions/oauth), ngrok manages OAuth protection\nentirely at its cloud service. ngrok's edge authenticates and authorizes all\nrequests before allowing ingress and access to your endpoint, meaning you don't\nneed to add any additional services to your cluster, or alter any routes.\n\nTo enable the `oauth` action, you'll create a new `NgrokTrafficPolicy` custom\nresource and apply it to your entire `Ingress` with an annotation. You can also\napply the policy to just a specific backend or as the default backend for an\n`Ingress`—see our doc on using the [Operator with\nIngresses](/k8s/guides/using-ingresses/#using-ngroktrafficpolicy-with-ingress).\n\n1. Edit your existing `2048.yaml` manifest with the following, leaving the\n   `Service` and `Deployment` as they were. Note the new `annotations` field and\n   the `NgrokTrafficPolicy` CR.\n\n   ```yaml\n    ...\n   ---\n   # Configuration for ngrok's Kubernetes Operator\n   apiVersion: networking.k8s.io/v1\n   kind: Ingress\n   metadata:\n     name: game-2048-ingress\n     namespace: default\n     annotations:\n       k8s.ngrok.com/traffic-policy: oauth\n   spec:\n     ingressClassName: ngrok\n     rules:\n       - host: <NGROK_DOMAIN>\n         http:\n           paths:\n             - path: /\n               pathType: Prefix\n               backend:\n                 service:\n                   name: game-2048\n                   port:\n                     number: 80\n   ---\n   # Traffic Policy configuration for OAuth\n   apiVersion: ngrok.k8s.ngrok.com/v1alpha1\n   kind: NgrokTrafficPolicy\n   metadata:\n     name: oauth\n     namespace: default\n   spec:\n     policy:\n   \t   on_http_request:\n   \t\t   - type: oauth\n   \t\t\t   config:\n   \t\t\t     provider: google\n   ```\n\n1. Re-apply your `2048.yaml` configuration.\n\n   ```bash\n   kubectl apply -f 2048.yaml\n   ```\n\n1. When you open your demo app again, you'll be asked to log in via Google.\n   That's a start, but what if you want to authenticate only yourself or colleagues?\n\n1. You can use [expressions](/traffic-policy/concepts/expressions) and [CEL\n   interpolation](/traffic-policy/concepts/cel-interpolation) to filter out\n   and reject OAuth logins that don't contain `example.com`. Update the\n   `NgrokTrafficPolicy` portion of your manifest after changing `example.com` to\n   your domain.\n\n   ```yaml\n   # Traffic Policy configuration for OAuth\n   apiVersion: ngrok.k8s.ngrok.com/v1alpha1\n   kind: NgrokTrafficPolicy\n   metadata:\n     name: oauth\n     namespace: default\n   spec:\n     policy:\n       on_http_request:\n         - type: oauth\n           config:\n             provider: google\n         - expressions:\n             - \"!actions.ngrok.oauth.identity.email.endsWith('@example.com')\"\n           actions:\n             - type: custom-response\n               config:\n                 body: Hey, no auth for you ${actions.ngrok.oauth.identity.name}!\n                 status_code: 400\n   ```\n\n1. Check out your deployed 2048 app once again. If you log in with an email that\n   doesn't match your domain, ngrok rejects your request. Authentication... done!\n",
			  "contentTitle": "Kubernetes ingress to services hosted on EKS"
			}
		  ],
		  "metadata": {
			"name": "amazon-eks",
			"description": "",
			"excerpt": "",
			"title": "Amazon EKS"
		  }
		},
		{
		  "name": "amazon-firehose",
		  "path": "/integrations/amazon-firehose",
		  "docs": [
			{
			  "path": "/integrations/amazon-firehose/event-destination",
			  "frontMatter": {
				"title": "Send Network Logs from ngrok to AWS Firehose",
				"description": "Send network traffic logs from ngrok to AWS Firehose",
				"tags": [
				  "events",
				  "logs",
				  "firehose",
				  "aws",
				  "event destinations"
				]
			  },
			  "content": "\n# AWS Firehose Event Destination\n<Tip>\n**TL;DR**\n\n\n\nTo send ngrok events to Firehose:\n\n1. [Obtain Firehose Delivery Stream ARN](#obtain-firehose-arn)\n1. [Create Log Export](#create-log-export)\n1. [Create Event Destination](#create-destination)\n</Tip>\n\nThis guide covers how to send ngrok events including network traffic logs into AWS Firehose.\nYou may want to keep an audit log of configuration changes within your ngrok\naccount, record all traffic to your endpoints for active monitoring/troubleshooting, or\nyou may use AWS Firehose as a SIEM and want to use it for security inspections.\n\nBy integrating ngrok with AWS Firehose, you can:\n\n- **Quickly identify application issues** in real-time using ngrok request events using Firehose data processing.\n- **Historically audit changes occurring within an account**. Be able to historically audit changes within an account.\n- **Profile usage of your service** by using Firehose queries and real-time data analytics.\n- **Identify security issues** by using ngrok events.\n\n## **Step 1**: Obtain Firehose Delivery Stream ARN \n\nFor ngrok to successfully send events into AWS Firehose we'll require a delivery stream\nARN. To create the ARN, you can follow [this AWS\nguide](https://docs.aws.amazon.com/firehose/latest/dev/basic-create.html).\n\nngrok is a **Direct PUT** Source type, and you can choose any Firehose destination you\nwish. For testing, it may be easiest to create a S3 bucket as the destination.\n\nOnce you've created your AWS Firehose, keep the Delivery Stream ARN handy for **[Step 3](#create-destination)**.\n\n## **Step 2**: Create a Log Export \n\n1. Using a browser, go to the [ngrok dashboard](https://dashboard.ngrok.com) and under **Traffic Observability** navigate to **Events Stream** on the left hand navigation and select **Create Subscription**.\n\n   ![ngrok log export](img/event_sub.png)\n\n2. Within the Log Exporting configuration, provide a description for the export and within the sources tab select **Add Source** to choose which events you would like to send to Firehose.\n\nFor information about the events, see the [ngrok event documentation](/obs/events/reference/).\n\nOnce complete, select **Add Event Sources** to confirm your selections.\n\n![ngrok event sources](img/event_sources.png)\n\n## **Step 3**: Create Event Destination \n\nTo send the events to Firehose we'll need to assign an Event Destination to the Log Export.\n\n1. Within the Log Exporting configuration Destination Tab, select **Add Destination.**\n\n1. Choose AWS Firehose Logs as the target and fill in the correct information.\n   - **Delivery Stream ARN**\n   - **Description** - Optional\n\n1. **Create IAM Role** - An IAM role is required to allow ngrok to stream logs into\n   Firehose. Using the information provided by your preferred method of creation, either\n   **API** or **CLI Script**, create the IAM role and provide the role ARN. For the\n   fastest integration or proof of concept, we recommend using the **CLI Script**.\n<Note>\n**SECURITY BEST PRACTICE**\n\n\n\nIf configuring your IAM role manually, ensure that you configure the Trust Policy with a\ncondition that includes the ExternalId. This will ensure that the only data allowed to\ningested by AWS will be from your ngrok account. If you configure the IAM role with the\nCLI script, this will be done automatically.\n</Note>\n\n![ngrok event destination](img/event_destination.png)\n\n4. Once all required inputs have values, select **Send Test Event** and you should be presented with a Success message. Select **Done** and the Firehose Event Destination setup is complete.\n\n![ngrok event destination success](img/success.png)\n",
			  "contentTitle": "Send Network Logs from ngrok to AWS Firehose"
			}
		  ],
		  "metadata": {
			"name": "amazon-firehose",
			"description": "",
			"excerpt": "",
			"title": "Amazon Kinesis Data Firehose"
		  }
		},
		{
		  "name": "amazon-kinesis",
		  "path": "/integrations/amazon-kinesis",
		  "docs": [
			{
			  "path": "/integrations/amazon-kinesis/event-destination",
			  "frontMatter": {
				"title": "Send Network Logs from ngrok to AWS Kinesis",
				"description": "Send network traffic logs from ngrok to AWS Kinesis",
				"tags": [
				  "events",
				  "logs",
				  "kinesis",
				  "aws",
				  "event destinations"
				]
			  },
			  "content": "\n# AWS Kinesis Event Destination\n<Tip>\n**TL;DR**\n\n\n\nTo send ngrok events to Kinesis:\n\n1. [Obtain Kinesis Data Stream ARN](#obtain-kinesis-arn)\n1. [Create Log Export](#create-log-export)\n1. [Create Event Destination](#create-destination)\n</Tip>\n\nThis guide covers how to send ngrok events including network traffic logs into AWS Kinesis.\nYou may want to keep an audit log of configuration changes within your ngrok\naccount, record all traffic to your endpoints for active monitoring/troubleshooting, or\nyou may use AWS Kinesis as a SIEM and want to use it for security inspections.\n\nBy integrating ngrok with Kinesis, you can:\n\n- **Quickly identify application issues** in real-time using ngrok request events using Kinesis data processing.\n- **Historically audit changes occurring within an account**. Be able to historically audit changes within an account.\n- **Profile usage of your service** by using Kinesis queries and real-time data analytics.\n- **Identify security issues** by using ngrok events.\n\n## **Step 1**: Obtain Kinesis Data Stream ARN \n\nFor ngrok to successfully send events into Kinesis we'll require a data stream ARN. To\ncreate the AWS Kinesis Data Stream and retrieve the ARN, reference the AWS documentation\nfor [Creating a Kinesis Data\nStream](https://docs.aws.amazon.com/streams/latest/dev/how-do-i-create-a-stream.html).\n\n## **Step 2**: Create a Log Export \n\n1. Using a browser, go to the [ngrok dashboard](https://dashboard.ngrok.com) and navigate to **Events** on the left hand navigation and select **Create Subscription**.\n\n   ![ngrok log export](img/event_sub.png)\n\n2. Within the Log Exporting configuration, provide a description for the export and within the sources tab select **Add Source** to choose which events you would like to send to Kinesis.\n\nOnce complete, select **Add Event Sources** to confirm your selections.\n\n![ngrok event sources](img/event_sources.png)\n\n## **Step 3**: Create Event Destination \n\nTo send the events to Kinesis we'll need to assign an Event Destination to the Log Export.\n\n1. Within the Log Exporting configuration Destination Tab, select **Add Destination.**\n\n1. Choose AWS Kinesis as the target and fill in the correct information.\n   - **Stream ARN**\n   - **Description** - Optional\n\n1. **Create IAM Role** - An IAM role is required to allow ngrok to stream logs into\n   Kinesis. Using the information provided by your preferred method of creation, either\n   **API** or **CLI Script**, create the IAM role and provide the role ARN. For the\n   fastest integration or proof of concept, we recommend using the **CLI Script**.\n<Note>\n**SECURITY BEST PRACTICE**\n\n\n\nIf configuring your IAM role manually, ensure that you configure the Trust Policy with a\ncondition that includes the ExternalId. This will ensure that the only data allowed to\ningested by AWS will be from your ngrok account. If you configure the IAM role with the\nCLI script, this will be done automatically.\n</Note>\n\n![ngrok event destination](img/event_destination.png)\n\n4. Once all required inputs have values, select **Send Test Event** and you should be presented with a Success message. Select **Done** and the Kinesis Event Destination setup is complete.\n\n![ngrok event destination success](img/success.png)\n",
			  "contentTitle": "Send Network Logs from ngrok to AWS Kinesis"
			}
		  ],
		  "metadata": {
			"name": "amazon-kinesis",
			"description": "",
			"excerpt": "",
			"title": "Amazon Kinesis"
		  }
		},
		{
		  "name": "amazon-sns",
		  "path": "/integrations/amazon-sns",
		  "docs": [
			{
			  "path": "/integrations/amazon-sns/webhooks",
			  "frontMatter": {
				"description": "Develop and test Amazon SNS webhooks from localhost",
				"title": "Amazon SNS Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Amazon SNS webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Amazon SNS webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Amazon SNS by using Webhooks.\nAmazon SNS webhooks can be used to notify an external application whenever a message is published to a topic.\n\nBy integrating ngrok with Amazon SNS, you can:\n\n- **Develop and test Amazon SNS webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Amazon SNS** in real-time via the inspection UI and API.\n- **Modify and Replay Amazon SNS Webhook requests** with a single click and without spending time reproducing notifications manually in your Amazon SNS topic.\n- **Secure your app with Amazon SNS validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Amazon SNS).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Amazon SNS \n\nTo register a webhook on your Amazon SNS topic follow the instructions below.\n\n1. Access [Amazon Cloud Service](https://aws.amazon.com/) and sign in using your Amazon account.\n\n1. On the AWS dashboard, enter `sns` in the search bar and then click the **Simple Notification Service** link that appears in the list.\n\n1. On the Amazon SNS **Dashboard** page, click **Topics** on the left menu, and then click **Create topic**.\n\n1. On the **Create topic** page, click the **Standard** tile, enter `MyTopic` in the **Name** field, and then click **Create topic**.\n\n1. Click **Subscriptions** on the left menu and then click **Create subscription**.\n\n1. On the **Create subscription** page, select your topic in the **Topic ARN** field, select **HTTPS** in the **Protocol** field, and enter the URL provided by the ngrok agent to expose your application to the internet in the **Endpoint** field (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![Endpoint](img/ngrok_url_configuration_amazonsns.png)\n\n1. Click **Create subscription**.\n\n1. Confirm your localhost app receives a **SubscriptionConfirmation** notification and logs both headers and body in the terminal.\n\n1. Copy the value of the **SubscribeURL** field from the body of the request.\n\n1. On the Amazon SNS **Subscriptions** page, select the **Pending confirmation** subscription from the list, click **Confirm subscription**, enter the value of the **SubscribeURL** in the **url** field, and then click **Confirm subscription**.\n\n   You should receive a message that says **Subscription was confirmed successfully**.\n\n### Run Webhooks with Amazon SNS and ngrok\n\nAny message published to the Amazon SNS topic triggers your HTTPS subscription. To publish a message to the SNS topic manually, follow the steps below:\n\n1. On the AWS dashboard, enter `sns` in the search bar and then click the **Simple Notification Service** link that appears in the list.\n\n1. On the Amazon SNS **Dashboard**, click **Topics** on the left menu, and then click the topic you previously associated with the Lambda function.\n\n1. On the topic page, click **Publish message**, enter `My message` in the **Subject** field, enter `This is my message` in the **Message body to send to the endpoint** field, and then click **Publish message**.\n\n   Confirm your localhost app receives a notification and logs both headers and body in the terminal.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Amazon SNS topic are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Access [Amazon Cloud Service](https://aws.amazon.com/), sign in using your Amazon account, and access the Amazon SNS **Dashboard** page.\n\n1. Click **Topics** on the left menu, click your topic and copy the value of the **Topic owner** field.\n\n1. Create a traffic policy file named `amazon_sns_policy.yml`, replacing `{Topic owner}` with the value you copied before:\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: sns\n             secret: \"{Topic owner}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file amazon_sns_policy.yml\n   ```\n\n1. Access [Amazon Cloud Service](https://aws.amazon.com/), sign in using your Amazon account, access the Amazon SNS **Dashboard** page, and publish a new message to your topic.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "Amazon SNS Webhooks"
			}
		  ],
		  "metadata": {
			"name": "amazon-sns",
			"description": "",
			"excerpt": "",
			"title": "Amazon SNS"
		  }
		},
		{
		  "name": "argocd",
		  "path": "/integrations/argocd",
		  "docs": [
			{
			  "path": "/integrations/argocd/apiops",
			  "frontMatter": {
				"title": "Deploy a production API and gateway with APIOps using Argo CD and ngrok",
				"description": "Deploy an API using a APIOps-based deployment and lifecycle management process with Argo CD, ngrok's API gateway, the ngrok Kubernetes Operator, and the Kubernetes Gateway API."
			  },
			  "content": "\nUsing this guide, you'll deploy a demo API to a Kubernetes cluster using an APIOps workflow. This process consolidates the backend API service, Kubernetes configurations, and API policy definitions into a single repository that defines the _desired state_ of your deployment.\n\nHere is what you'll be building with:\n\n- ngrok's out-of-the-box [**API Gateway**](https://ngrok.com/use-cases/api-gateway), which instantly tunnels production API traffic through the globally available ngrok network without requiring additional infrastructure or complex configurations.\n- The ngrok [**Kubernetes Operator**](https://github.com/ngrok/ngrok-operator/), which adds secure public ingress and middleware execution to Kubernetes deployments with declarative CRDs.\n- The new [**Kubernetes Gateway API**](https://kubernetes.io/docs/concepts/services-networking/gateway/), a role-oriented mechanism for provisioning load-balancing infrastructure and routing traffic, with fantastic support for [developer-defined](https://ngrok.com/blog-post/developer-defined-golden-path-kubernetes-gateway-api) paths to deploying production APIs.\n- [**Argo CD**](https://argo-cd.readthedocs.io/en/stable/), a declarative, GitOps continuous delivery tool for Kubernetes that lets you version-control all your definitions, configurations, and environments&mdash;even an API gateway.\n\n## What you'll need\n\n- [Argo CD](https://argo-cd.readthedocs.io/en/stable/cli_installation/) installed locally.\n- An existing remote or local Kubernetes cluster _OR_ [minikube](https://minikube.sigs.k8s.io/docs/start/) to create a\n  new demo cluster locally, which will be referred to as `<YOUR-CLUSTER>`.\n- An [AWS EKS cluster](https://eksctl.io/usage/creating-and-managing-clusters/).\n- An [ngrok account](https://ngrok.com/signup).\n- [kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl/) and [Helm\n  3.0.0+](https://helm.sh/docs/intro/install/) installed on your local\n  workstation.\n- The [ngrok Kubernetes Operator](/k8s/) installed on\n  your cluster.\n- A reserved domain, which you can get in the ngrok\n  [dashboard](https://dashboard.ngrok.com/domains) or with the [ngrok\n  API](/api/resources/reserved-domains/).\n  - You can choose from an ngrok subdomain or bring your own custom branded\n    domain, like `https://api.example.com`.\n  - We'll refer to this domain as `<NGROK_DOMAIN>`.\n\n## Deploy Argo CD \n\nNext, set up Argo CD on your cluster to enable GitOps.\n\n1. Create a namespace for Argo CD:\n\n   ```bash\n   kubectl create namespace argocd\n   ```\n\n1. Apply Argo CD's default manifest to your Kubernetes cluster.\n\n   ```bash\n   kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml\n   ```\n\n1. Verify you have deployed Argo CD successfully via a single running pod.\n\n   ```bash\n   kubectl get pods --namespace argocd\n\n   NAME                                               READY   STATUS    RESTARTS   AGE\n   argocd-application-controller-0                    1/1     Running   0          44s\n   argocd-applicationset-controller-65bb5ff89-lcmbk   1/1     Running   0          45s\n   argocd-dex-server-6f898cbd9-slg8h                  1/1     Running   0          45s\n   argocd-notifications-controller-64bc7c9f7-dgnfm    1/1     Running   0          45s\n   argocd-redis-5df55f45b7-2sf62                      1/1     Running   0          45s\n   argocd-repo-server-74d5f58dc5-dgbnr                0/1     Running   0          45s\n   argocd-server-5b86767ddb-57xlj                     0/1     Running   0          44s\n   ```\n\n1. Log into the Argo CD web UI, first by creating a new port-forwarding session.\n\n   ```bash\n   kubectl port-forward svc/argocd-server -n argocd 8080:443\n   ```\n\n   When you navigate to `http://<YOUR-CLUSTER>:8080`, you'll first see a warning about self-signed certificates, which you can accept to proceed. Finally, Argo CD prompts you to login with a username and password. The username is `admin`, and you can retrieve the automatically-generated administrator password with the following:\n\n   ```bash\n   argocd admin initial-password -n argocd\n   ```\n\n   Once logged in, you'll have access to the Argo CD UI.\n\n   ![Screenshot of Argo CD deployed on Kubernetes](img/argo-setup.png)\n\n1. Finally, log in to Argo CD via the CLI to enable administration.\n\n   ```bash\n   argocd login <YOUR-CLUSTER>:8080\n   ```\n\n## Set up the demo API \n\nNext, you need to set up the Git repository for the API you'll deploy behind your ngrok API gateway. GitOps (and thus APIOps) requires declarative and version-controlled configuration, and that includes the hostname for your deployment. You can't simply clone the demo API repository and apply it to your cluster, as the ngrok-supplied hostname will already be in use.\n\nIf you have an existing API and GitOps configuration, you're more than welcome to [skip to step 4](#deploy-demo-api) while adopting the Argo CD CLI commands to your Git repository.\n\n1. Create a new ngrok static domain. Navigate to the [**Domains** section](https://dashboard.ngrok.com/domains) of the ngrok dashboard and click **Create Domain** or **New Domain**. This static domain, which will look like `example.ngrok.app`, will be your `NGROK_DOMAIN` for the remainder of this guide.\n\n1. Fork the repository for the demo API at [ngrok-samples/apiops-demo](https://github.com/ngrok-samples/apiops-demo).\n\n1. In your fork, open `gateway.yaml` and replace the values of lines 18 and 37 with the ngrok domain you just created (e.g. `one-two-three.ngrok.app`).\n\n1. Add, commit, and push these changes to your fork.\n\n## Deploy your demo API with Argo CD \n\nNow that your demo API is forked and properly configured on GitHub, you can connect it to Argo CD to sync, reconcile, and deploy.\n\n1. Register the demo app with Argo CD, replacing `<YOUR-GITHUB-USERNAME>` to point to your fork of the demo API repository.\n\n   ```bash\n   argocd app create apiops-demo \\\n     --repo https://github.com/<YOUR-GITHUB-USERNAME>/apiops-demo.git \\\n     --path . \\\n     --dest-server https://kubernetes.default.svc \\\n     --dest-namespace apiops-demo\n   ```\n\n   Refresh the Argo CD UI to see your app. Take note of the **Missing** and **OutOfSync** status report—they are not errors, but rather reflect the fact that Argo CD doesn't automatically sync and deploy a newly registered app.\n\n   ![Viewing all applications registreed to an Argo CD instance](img/argo-tile.png)\n\n   You can still click on the app to view additional details about the deployment _and_ the Git repository on which it is based.\n\n1. Use the Argo CD CLI to perform a manual first sync of your registered app against your Git repository.\n\n   ```bash\n   argocd app sync apiops-demo\n   ```\n\n   Refresh the UI to see that your demo API is properly synced and deployed.\n\n   ![alt text](img/argo-synced.png)\n\n   You can also navigate to the **Edges** view of your [ngrok dashboard](https://dashboard.ngrok.com/edges), then click on the Edge associated with the ngrok domain you created earlier, to see that the ngrok Kubernetes Operator pushed its definitions to the ngrok Edge via secure tunnel.\n\n   ![alt text](img/ngrok-tunnel.png)\n\n   Finally, you can `curl` your deployed API, with ngrok's API gateway functionality handling ingress and TLS automatically on your behalf. You'll only see `null` in response, but it's still proof your demo API is working as expected.\n\n   ```bash\n   curl \\\n     -X GET \\\n     -H \"Content-Type: application/json\" \\\n     https://<NGROK-DOMAIN>/legend\n   ```\n\n## Enable APIOps in Argo CD \n\nA fundamental component of GitOps, and thus APIOps, is that because your Git repository contains the latest version of your desired state, your deployment toolkit should automatically update the production deployment without any manual processes.\n\n1. Enable [auto sync](https://argo-cd.readthedocs.io/en/stable/user-guide/auto_sync/) of your app the Git repository that stores your desired state.\n\n   ```\n   argocd app set apiops-demo --sync-policy automated\n   ```\n\n   You can confirm this change in the Argo CD UI:\n\n   ![Enabling auto sync for an Argo CD-deployed API](img/argo-auto-sync.png)\n\n   <Note>\n   The default polling interval, at which Argo CD looks for changes to the desired state in your Git repo, is 3 minutes. You can alter this behavior with the [`timeout.reconciliation` value](https://argo-cd.readthedocs.io/en/stable/faq/#how-often-does-argo-cd-check-for-changes-to-my-git-or-helm-repository) in Argo CD's configuration.\n   </Note>\n\n1. Optionally, you can test auto sync by editing the number of replicas of the demo API deployed in your cluster. In your Git repository, open the` deployment.yaml` file and edit the `replicas` value:\n\n   ```yaml\n   spec:\n     replicas: 5\n   ```\n\n   To push these changes to your production cluster, add, commit, and push them to your Git repository.\n\n   ```bash\n   git add .\n   git commit -m \"Increase replicas to 5\"\n   git push origin main\n   ```\n\n   Argo CD will soon poll your repository, identify changes, and reconcile the deployed state to increase the number of replicas.\n\n   ![Automatically increase the number of replicas via GitOps](img/argo-replicas.png)\n\n## Configure your API gateway with traffic policies \n\nThe ngrok team [recently rolled out support](https://ngrok.com/blog-post/policy-support-in-gateway-api) for using the [Traffic Policy module](/traffic-policy/) alongside the Kubernetes Gateway API. This allows you to place all your Traffic Policy actions into a single `NgrokTrafficPolicy` CRD, controlling your ngrok-powered API gateway with an APIOps workflow with version-controlled and declarative manifests.\n\nThe project comes with a basic example of such a Traffic Policy—[see `traffic-policy.yaml` for details](https://github.com/ngrok-samples/apiops-demo/blob/main/traffic-policy.yaml)—but because rate limiting is typically the first order of business in protecing any API from abuse, let's walk through that process.\n\n1. In your fork of the demo API project, create a new file called `rate-limiting.yaml`. Open the file and add the following YAML:\n\n   ```yaml\n   kind: NgrokTrafficPolicy\n   apiVersion: ngrok.k8s.ngrok.com/v1alpha1\n   metadata:\n     name: traffic-policy-rate-limiting\n   spec:\n     policy:\n       on_http_request:\n         - actions:\n             - type: \"rate-limit\"\n               config:\n                 name: \"Only allow 10 requests per minute\"\n                 algorithm: \"sliding_window\"\n                 capacity: 10\n                 rate: \"60s\"\n                 bucket_key:\n                   - \"req.headers['host']\"\n   ```\n\n   This example policy includes a low limit for demonstration purposes, but you can change the `capacity` value to your needs in production.\n\n1. Next, insert the highlight YAML below into the `HTTPRoute` in your `deployment.yaml`.\n\n   This defines a [filter](https://gateway-api.sigs.k8s.io/api-types/httproute/#filters-optional), which must be processes during the request or response lifecycle, allowing you to inject policy into all traffic arriving to your API through your ngrok API gateway.\n\n   ```yaml\n    apiVersion: gateway.networking.k8s.io/v1\n    kind: HTTPRoute\n    metadata:\n      name: apiops-demo-route\n      namespace: apiops-demo\n    spec:\n      parentRefs:\n        - kind: Gateway\n          name: apiops-demo-gateway\n          namespace: apiops-demo\n      hostnames:\n        - \"apiops-demo.ngrok.app\"\n      rules:\n        - matches:\n            - path:\n                type: PathPrefix\n                value: /\n          filters:\n            - type: ExtensionRef\n              extensionRef:\n                group: ngrok.k8s.ngrok.com\n                kind: NgrokTrafficPolicy\n                name: traffic-policy-rate-limiting\n          backendRefs:\n            - name: apiops-demo-service\n              port: 80\n              kind: Service\n   ```\n\n1. Add, commit, and push this change to your Git repository. Argo CD will auto sync this latest commit then reconcile the deployed state with those changes to the `NgrokTrafficPolicy` CRD and `HTTPRoute`.\n\n   Once the ngrok Kubernetes Operator picks up those changes, it will push definitions to your ngrok Edge—you can verify those changes directly in your [ngrok dashboard](https://dashboard.ngrok.com/edges/):\n\n   ![Validate successful Traffic Policy upload](img/ngrok-traffic-policy.png)\n\n1. Optionally, test your new rate limiting policy by `curl`-ing your API in a quick loop.\n\n   ```bash\n   for i in `seq 1 50`; do \\\n     curl -s -o /dev/null \\\n       -w \"\\n%{http_code}\" \\\n       -X GET https://apiops-demo.ngrok.app/legend ; \\\n   done\n   ```\n\n   You should see [`429` response codes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429) as your ngrok API gateway rate-limits your IP address.\n\n## What's next?\n\nYou've now built a proof of concept for deploying an API to production using ngrok and Argo CD. You can use this combination to deploy real-world API behind a production-grade gateway with no arcane configurations or expensive external infrastructure.\n\nIn a real-world deployment, you would also integrate your Git repository with a proper CI/CD pipeline, which would run tests for security, governance, and code quality. By only merging changes that pass your CI/CD pipeline, you can better guarantee the production-readiness of your API.\n\nIf you're looking for more Traffic Policy opportunities, check out our [guide to integrate with Auth0](/integrations/jwt-validation/auth0/) for JWT-based authentication. Our [library of \"drop-in\" examples](https://ngrok.com/blog-post/api-gateway-policy-management-examples) contains additional use cases like blocking traffic from specific countries, deprecating API versions, [event logging](/obs/), and more. The [Traffic Policy docs](/traffic-policy/) also contains an exhaustive list of actions and syntax reference.\n",
			  "contentTitle": "Deploy a production API and gateway with APIOps using Argo CD and ngrok"
			}
		  ],
		  "metadata": {
			"name": "argocd",
			"description": "",
			"excerpt": "",
			"title": "Argo CD"
		  }
		},
		{
		  "name": "auth0",
		  "path": "/integrations/auth0",
		  "docs": [
			{
			  "path": "/integrations/auth0/dashboard-sso",
			  "frontMatter": {
				"title": "Configure Auth0 Single Sign-On with SAML",
				"description": "Configure Single Sign-On for your ngrok dashboard using Auth0 as the Identity Provider"
			  },
			  "content": "\nThis guide walks you through configuring the ngrok dashboard to use Auth0 as an identity provider and enable single sign-on within SAML for your ngrok account.\nThis should not be confused with configuring an ngrok endpoint to allow your application users to log in using Auth0.\n\n## What you'll need\n\n- Admin access to create new applications in Auth0\n- Admin access to edit your ngrok account settings\n- An ngrok Enterprise account\n\n## 1. Create an Application in Auth0\n\n1. From the \"Applications\" menu, click the blue \"Create Application\" button.\n   ![Create Application](img/auth0app.png)\n\n2. Name your application, select the application type of Native and click the Create button.\n   ![Select Application Type](img/auth0createapp.png)\n3. Select your application and choose the Addons tab. Turn SAML2 support on.\n   ![Select SAML](img/select_saml.png)\n\n4. In the popup window on the Usage tab download the Identity Provider Metadata from the provided link.\n\n## 2. Configure Single Sign-On (SSO) for your ngrok account\n\n1. Log into your ngrok dashboard and navigate to the \"Settings > Account\" section in the left navigation menu.\n2. Select \"+ New Identity Provider\" button to add a new SAML identity provider.\n   ![Add Identity Provider](img/sso_section_dash.png)\n3. Add a helpful description, and then upload the metadata.xml file from Auth0 into the ngrok dashboard.\n4. In the Options section, select whether you'd like to allow users to log into the dashboard directly from their ngrok dashboard\n   ![Upload XML](img/upload_xml.png)\n5. Click \"Save\". Clicking Save will create the integration and generate the required URLs for your Auth0 Application.\n   ![Enter SP Information](img/save_saml.png)\n\n## 3. Add the ngrok generated URLs to your Auth0 SAML application\n\n1. Back in your Auth0 account, select your Application and click on the Addons tab. Again select the SAML2 Web App. In the popup window select the Settings tab.\n   1. Paste in the Application Callback URL (ACS) obtained from the ngrok IdP settings - SAML Provider/Service Provider - ACS URL as seen above.\n   2. In the settings code block window paste in the following and Save:\n      ```json\n      {\n        \"nameIdentifierFormat\": \"urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress\",\n        \"nameIdentifierProbes\": [\n          \"email\"\n        ],\n        \"mappings\": {\n          \"email\": \"email\"\n        }\n      }\n      ```\n\nYou should now be configured to log into your ngrok account using Auth0.\n\nBy default, your ngrok account will still allow users to log in with their existing credentials as well as through Auth0 (\"Mixed Mode\").\nOnce you verify that everything is working properly with your integration, you can enable \"SSO Enforced\" in the ngrok Dashboard which will require all new users to log in through Auth0 for their ngrok account.\n",
			  "contentTitle": "Configure Auth0 Single Sign-On with SAML"
			},
			{
			  "path": "/integrations/auth0/jwt-action",
			  "frontMatter": {
				"title": "Enable JWT validation with Auth0",
				"description": "Configure JWT Validation for tokens issued from Auth0"
			  },
			  "content": "\nimport IntegrationDocs from \"/snippets/traffic-policy/actions/jwt-validation/examples/integration-auth0/index.mdx\";\n\n<IntegrationDocs />\n",
			  "contentTitle": "Enable JWT validation with Auth0"
			},
			{
			  "path": "/integrations/auth0/sso-oidc",
			  "frontMatter": {
				"title": "Auth0 Endpoint SSO (OpenID Connect)",
				"description": "Use Auth0 OIDC to secure access to ngrok endpoints"
			  },
			  "content": "\nimport Disclaimer from \"/snippets/integrations/_endpoint-sso-disclaimer.mdx\";\n\n<Disclaimer />\n<Tip>\n**TL;DR**\n\n\n\nTo secure access to ngrok with Auth0 Single Sign-On using OpenID Connect:\n\n1. [Configure Auth0 SSO](#configure-Auth0)\n1. [Configure ngrok](#configure-ngrok)\n1. [Test access to ngrok with Auth0 SSO](#test-sso)\n</Tip>\n\nThis article details how to configure Auth0 as the primary Identity Provider for ngrok tunnels.\nBy integrating Auth0 SSO with ngrok, you can:\n\n- **Restrict access to ngrok tunnels** only to users authenticated via Auth0\n- **Use Auth0 security policies and MFA authenticators**.\n- **Use Auth0's Dashboard to facilitate access to ngrok apps**.\n\n## Supported Features\n\nThe ngrok integration with Auth0 supports:\n\n- **SP-Initiated SSO**: In this mode, users access ngrok edges and tunnels and are redirected to Auth0 for authentication.\n\n## Requirements\n\nTo configure ngrok tunnels with Auth0, you must have:\n\n- an Auth0 account with administrative rights to create apps\n- an ngrok enterprise account with an access token or admin access to configure edges with OpenID Connect.\n\n## Configuration Steps\n\nTo integrate ngrok with Auth0 SSO, you will need to:\n\n1. Configure Auth0 with the ngrok app\n1. Configure ngrok with the SSO settings provided by Auth0\n\n## **Step 1**: Configure Auth0 \n\n### Add the ngrok App in Auth0\n\n1. Access the [Auth0 Dashboard](https://manage.auth0.com/dashboard/), and sign in using your Auth0 account.\n\n1. On the left menu, click **Applications**, click **Applications**, and then click **Create Application**.\n\n1. On the **Create application** popup, enter `ngrok oidc` in the **name** field, click the **Single Page Web Applications** tile, and then click **Create**.\n\n1. On the **ngrok oidc** page, click the **Settings** tab and make note of the **Domain**, **Client ID**, and **Client Secret** values.\n\n1. Enter `https://idp.ngrok.com/oauth2/callback` in the **Allowed Callback URLs** field, and enter the URL provided by the ngrok agent to expose your application to the internet in the **Application Login URI** field (i.e. `https://myexample.ngrok.app`).\n   ![Auth0 configuration](img/ngrok_url_configuration_auth0.png)\n\n1. Click **Save Changes**.\n\n### Grant access to Auth0 users\n\nAuth0 allows administrators to restrict access to SSO apps — such as ngrok — via user group assignments. By default, apps created in Auth0 have no group assignments — in other words, nobody can use Auth0 SSO to access ngrok until you assign a group to the app.\n\nTo assign Auth0 groups to the ngrok app:\n\n1. On the [Auth0 Dashboard](https://manage.auth0.com/dashboard/), click **User Management** on the left menu, click **Users**, and then click **Create User**.\n\n1. Enter an email address in the **Email** field, provide a **Password**, and then click **Create**.\n\n## **Step 2**: Configure ngrok \n\nngrok can leverage Auth0 SSO in two ways:\n\n- From the ngrok CLI (using the `--oidc` parameter)\n- From the ngrok dashboard\n\n### **Option 1**: ngrok CLI\n\n> **Note:** For this tutorial, we assume you have an app running locally (i.e., on localhost:3000) with the ngrok client installed.\n\n1. Launch a terminal\n\n1. Enter the following command to launch an ngrok tunnel with Auth0 SSO:\n\n   ```bash\n   ngrok http 3000 --oidc=AUTH0_OAUTH_URL \\\n   --oidc-client-id=Auth0_CLIENT_ID \\\n   --oidc-client-secret=Auth0_CLIENT_SECRET \\\n   ```\n\n   **Note**: Replace the following with values:\n   - Auth0_OAUTH_URL: The domain value you copied from Auth0, in the form of an URL (i.e. `https://dev-abcd1234.us.auth0.com/`).\n   - Auth0_CLIENT_ID: The client id you copied from Auth0.\n   - Auth0_CLIENT_SECRET: The client secret you copied from Auth0.\n\n   Alternatively, add the `--url YOUR_DOMAIN` argument to get your custom URL, replacing `YOUR_DOMAIN` with your URL of preference.\n\n1. Copy the URL available next to **Forwarding** (for example, `https://Auth0-sso-test.ngrok.app`).\n\n1. Skip to **Step 3**\n\n### **Option 2**: ngrok Edge\n\nTo configure an edge with Auth0:\n\n1. Access the [ngrok Dashboard](https://dashboard.ngrok.com/) and sign in using your ngrok account.\n\n1. On the left menu, click **Universal Gateway** and then click **Edges**.\n\n1. If you don't have an edge already set to add Auth0 SSO, create a test edge:\n   - Click **+ New Edge**.\n   - Click **Create HTTPS Edge**.\n   - Click the **pencil icon** next to \"no description\", enter `Edge with Auth0 SSO OIDC` as the edge name, and click **Save**.\n\n1. On the edge settings menu, click **OIDC**.\n\n1. Click **Begin setup** and enter the following values into the fields:\n   ![Auth0 config in ngrok](img/auth0-1.png)\n   - **Issuer URL**: The domain value you copied from Auth0, in the form of a URL (i.e. `https://dev-abcd1234.us.auth0.com/`).\n   - **Client ID**: The client id you copied from Auth0.\n   - **Client Secret**: The client secret you copied from Auth0.\n\n1. Click **Save** at the top, and then click the left arrow to go back to the **Edges** page.\n\n1. Launch a tunnel connected to your Auth0 edge:\n<Tip>\n**Note**\n\n\nFor this step, we assume you have an app running locally (i.e. on localhost:3000) with the ngrok client installed.\n</Tip>\n\n1.  Click **Start a tunnel**.\n\n1.  Click the **copy icon** next to the tunnel command.\n    ![tunnel config](img/auth0-2.png)\n\n1.  Launch a tunnel:\n    - Launch a terminal.\n    - Paste the command but replace `http://localhost:80` with your localhost app address (i.e., `http://localhost:3000`).\n    - Click **Enter** and an ngrok tunnel associated with your edge configuration will launch.\n\n1.  To confirm that the tunnel is connected to your edge:\n    - Return to the ngrok dashboard\n    - Close the **Start a tunnel** and the **Tunnel group** tabs\n    - Refresh the test edge page. Under traffic, you will see the message _You have 1 tunnel online. Start additional tunnels to begin load balancing._\n      ![tunnel confirmed](img/auth0-3.png)\n\n1.  In the test edge, copy the **endpoint URL**. (You use this URL to test the Auth0 Authentication)\n    ![tunnel url](img/auth0-4.png)\n\n## Step 3: Test the integration \n\n1. In your browser, launch an incognito window.\n\n1. Access your ngrok tunnel (i.e., `https://auth0-sso-test.ngrok.app` or using the copied endpoint URL).\n\n1. You should be prompted to log in with your Auth0 credentials.\n\n1. After logging in, you should be able to see your web app.\n",
			  "contentTitle": "Auth0 Endpoint SSO (OpenID Connect)"
			}
		  ],
		  "metadata": {
			"name": "auth0",
			"description": "",
			"excerpt": "",
			"title": "Auth0"
		  }
		},
		{
		  "name": "autodesk",
		  "path": "/integrations/autodesk",
		  "docs": [
			{
			  "path": "/integrations/autodesk/webhooks",
			  "frontMatter": {
				"description": "Develop and test Autodesk webhooks from localhost",
				"title": "Autodesk Platform Services Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Autodesk Platform Services webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Autodesk webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Autodesk Platform Services by using Webhooks.\nAutodesk Platform Services webhooks can be used to notify an external application whenever specific events occur in your Autodesk account.\n\nBy integrating ngrok with Autodesk, you can:\n\n- **Develop and test Autodesk webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Autodesk** in real-time via the inspection UI and API.\n- **Modify and Replay Autodesk Webhook requests** with a single click and without spending time reproducing events manually in your Autodesk account.\n- **Secure your app with Autodesk validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Autodesk).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Autodesk \n\nTo register a webhook on your Autodesk account follow the instructions below:\n\n1. Access [Autodesk Platform Services](https://aps.autodesk.com/) and sign in using your Autodesk account.\n\n1. On the **Platform Services** page, click your avatar icon on the top-right corner of the page, click **Applications**, click **Create Application**, enter a name in the **Name** field, and then click **Create**.\n\n1. In the **Client Credentials** section of your application page, copy the values of the **Client ID** and the **Client Secret** fields for later use.<br/>\n   **Tip**: Click the eye icon to reveal the **Client Secret** value to copy or click the copy icon.\n\n1. In the **General Settings** section, enter the URL provided by the ngrok agent to expose your application to the internet in the **Callback URL** field (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![Callback URL](img/ngrok_url_configuration_autodesk.png)\n\n1. In the **API Access** section, select the **Data Management API** and the **Webhooks API** from the list, and then click **Save changes**.<br/>\n   **Tip**: This tutorial uses the **Data Management** service as an example. Select other APIs for use with other Autodesk Platform Services.\n\n1. In a terminal window, run the following command to obtain an access token:\n   ```bash\n   curl -v 'https://developer.api.autodesk.com/authentication/v1/authenticate'\n   -X 'POST'\n   -H 'Content-Type: application/x-www-form-urlencoded'\n   -d '\n       client_id=CLIENT_ID&\n       client_secret=CLIENT_SECRET&\n       grant_type=client_credentials&\n       scope=data:read\n   '\n   ```\n1. Copy the value of the **access_token** attribute from the response json.\n\n1. Run the following command to register a webhook to Autodesk Data Management:\n\n   ```bash\n   curl -X 'POST'\\\n    -v 'https://developer.api.autodesk.com/webhooks/v1/systems/data/events/dm.*/hooks'\\\n    -H 'Content-Type: application/json'\\\n    -H 'authorization: Bearer ACCESS_TOKEN'\\\n    -d '{\n           \"callbackUrl\": \"CALLBACK_URL\",\n           \"scope\": {\n                \"folder\": \"FOLDER_URN\"\n           },\n           \"hookAttribute\": {\n                \"projectId\": \"PROJECT_ID\",\n           },\n           \"filter\": \"$[?(@.ext=='txt')]\"\n     }'\n   ```\n\n   **Note**: Replace the following with the corresponding values:\n   - ACCESS_TOKEN: the access token copied on previous steps.\n   - CALLBACK_URL: the URL provided by the ngrok agent to expose your application to the internet (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   - FOLDER_URN: Your Autodesk Data Management folder URN\n   - PROJECT_ID: Your Autodesk Data Management project ID.\n\n1. Make sure the response from the above command is `HTTP/1.1 201`.\n\n### Run Webhooks with Autodesk and ngrok\n\nAutodesk Platform Services sends a different request to your webhook endpoint depending on the event being triggered.\nFor example, you can trigger new calls from Autodesk to your application whenever you add a file to a folder in Data Management.\n\n1. On your desktop start menu, select **Autodesk Data Management**, click **Autodesk Data Management Server Console** and sign in using your username and password.\n\n1. Access the folder you assigned to your webhook, upload a text file, and confirm your localhost app receives a notification and logs both headers and body in the terminal.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Autodesk webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Run the following command to register a webhook secret to your webhook:\n\n   ```bash\n   curl -X 'POST'\\\n    -v 'https://developer.api.autodesk.com/webhooks/v1/tokens'\\\n    -H 'Content-Type: application/json'\\\n    -H 'authorization: Bearer ACCESS_TOKEN'\\\n    -d '{\n           \"token\": \"YOUR_WEBHOOK_SECRET\"\n     }'\n   ```\n\n   **Note**: Replace the following with the corresponding values:\n   - ACCESS_TOKEN: the access token copied on previous steps.\n   - YOUR_WEBHOOK_SECRET: a value to sign each webhook request.\n\n1. Make sure the response from the above command is `HTTP/1.1 200`.\n\n1. Create a traffic policy file named `autodesk_policy.yml`, replacing `{your client secret}` with the value you copied before:\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: autodesk\n             secret: \"{your client secret}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file autodesk_policy.yml\n   ```\n\n1. Access the folder you assigned to your webhook, upload a text file, and confirm your localhost app receives a notification and logs both headers and body in the terminal.\n",
			  "contentTitle": "Autodesk Platform Services Webhooks"
			}
		  ],
		  "metadata": {
			"name": "autodesk",
			"description": "",
			"excerpt": "",
			"title": "Autodesk"
		  }
		},
		{
		  "name": "microsoft-entra-id",
		  "path": "/integrations/azure-ad",
		  "docs": [
			{
			  "path": "/integrations/azure-ad/k8s",
			  "frontMatter": {
				"description": "Add ingress to any app running in Kubernetes, then restrict access to only users authorized through Microsoft Entra ID, using the ngrok Kubernetes Operator.",
				"title": "Ingress to apps secured by Microsoft Entra ID in Kubernetes"
			  },
			  "content": "<Tip>\n**TL;DR**\n\n\n\nTo use the ngrok Kubernetes Operator with Microsoft Entra ID:\n\n1. [Create a cluster and deploy an example app](#create-cluster-deploy-example-app)\n2. [Add the ngrok Kubernetes Operator](#add-the-ngrok-kubernetes-operator)\n3. [Update your ngrok Edge to enable SAML](#update-your-ngrok-edge-to-enable-SAML)\n4. [Create an enterprise app in Microsoft Entra ID](#create-an-enterprise-app)\n5. [Finish adding Microsoft Entra ID authorization to your ngrok Edge](#finish-adding-entra-ID-authorization-ngrok-edge)\n6. [Test authorization to your app using Microsoft Entra ID](#test-authorization-using-microsoft-entra-id)\n</Tip>\n\nThe [ngrok Kubernetes Operator](/k8s) is ngrok's official controller for adding secure public ingress and middleware execution to your Kubernetes apps with ngrok's cloud service. With ngrok, you can manage and secure traffic to your apps at every stage of the development lifecycle while also benefitting from simpler configurations, security, and edge acceleration.\n\nMicrosoft Azure Active Directory (AD)—now known as [Microsoft Entra ID](https://www.microsoft.com/en-us/security/business/identity-access/microsoft-entra-id) (see the tip below)—is an identity and access management platform that helps administrators and DevOps engineers safeguard their organization's multicloud environment with strong authentication and unified identity management, whether they operate in Azure cloud or on-premises.\n<Note>\n**In October 2023, Azure Active Directory (AD) was [renamed to Microsoft Entra ID](https://learn.microsoft.com/en-us/entra/fundamentals/new-name) to \"communicate the multicloud, multiplatform functionality\" and \"alleviate confusion with Windows Server Active Directory.\" This name change changes nothing about the product or its capabilities. We have used **Microsoft Entra ID** up to this point due to the recency of the change, but will use **Entra ID** for the remainder.**\n</Note>\n\nThe ngrok Kubernetes Operator and Microsoft Entra ID integrate by letting you not only route public traffic to an app deployed on a Kubernetes cluster, but also restrict access only to users who you have authorized through Microsoft Entra ID.\n\nWith this guide, you'll (optionally) create a new Kubernetes cluster and example deployment and install the ngrok Kubernetes Operator to securely route traffic through the [ngrok cloud service](https://ngrok.com/product/cloud-edge). You'll then use the ngrok dashboard to enable Security Assertion Markup Language (SAML), using Microsoft Entra ID as your identity provider, to authorize specific users with a single sign-on experience.\n<Warning>\n**This tutorial requires:**\n\n\n\n1. An [ngrok account](https://ngrok.com/signup) at the [**pay-as-you-go** or **custom**](https://ngrok.com/pricing) tiers.\n2. A Microsoft Azure account with access to an existing Microsoft Entra ID tenant or the ability to create a new tenant with an Microsoft Entra ID P1 or P2 license.\n3. A Kubernetes cluster, either locally or in a public cloud, with an app you'd like to be publicly accessible to specific users.\n</Warning>\n\n## **Step 1**: Create a cluster and deploy an example app \n\nThis guide requires you to deploy _some_ app on _any_ Kubernetes cluster, either locally or in a public cloud, to provide an endpoint for ngrok's secure tunnel. You can use any cluster and any app, but for demonstration, we'll create a local Kubernetes cluster with [minikube](https://minikube.sigs.k8s.io/docs/) and deploy the [Online Boutique](https://github.com/GoogleCloudPlatform/microservices-demo) example.\n\nIf you already have a cluster and app, skip to [Step 2: Add the ngrok Kubernetes Operator](#add-the-ngrok-kubernetes-operator).\n\n1. Download the `GoogleCloudPlatform/microservices-demo` project to your local workstation and navigate into the new directory.\n\n   ```bash\n   git clone https://github.com/GoogleCloudPlatform/microservices-demo\n   cd microservices-demo\n   ```\n\n1. Create a new minikube cluster.\n\n   ```bash\n   minikube start -p online-boutique\n   ```\n\n1. Apply the manifests for the Online Boutique.\n\n   ```bash\n   kubectl apply -f ./release/kubernetes-manifests.yaml\n   ```\n\n## **Step 2**: Add the ngrok Kubernetes Operator \n\nNext, you'll configure and deploy the [ngrok Kubernetes Operator](https://github.com/ngrok/ngrok-operator) to expose your app to the public internet through the ngrok cloud service.\n\n1. Add the ngrok Helm repository if you haven't already.\n\n   ```bash\n   helm repo add ngrok https://charts.ngrok.com\n   ```\n\n1. Create a ngrok static subdomain for ingress if you don't have one already. Navigate to the [**Domains** section](https://dashboard.ngrok.com/domains) of the ngrok dashboard and click **Create Domain** or **New Domain**. This static subdomain will be your `NGROK_DOMAIN` for the remainder of this guide.\n\n   Creating a subdomain on the ngrok network provides a public route to accept HTTP, HTTPS, and TLS traffic.\n\n1. Set up the `AUTHTOKEN` and `API_KEY` exports, which allows Helm to install the Operator using your ngrok credentials. Find your `AUTHTOKEN` under [**Your Authtoken**](https://dashboard.ngrok.com/get-started/your-authtoken) in the ngrok dashboard.\n\n   To create a new API key, navigate to the [**API** section](https://dashboard.ngrok.com/api) of the ngrok dashboard, click the **New API Key** button, change the description or owner, and click the **Add API Key** button. Copy the API key token shown in the modal window before closing it, as the ngrok dashboard will not show you the token again.\n\n   ```bash\n   export NGROK_AUTHTOKEN=[YOUR-AUTHTOKEN]\n   export NGROK_API_KEY=[YOUR-API-KEY]\n   ```\n\n1. Install the ngrok Kubernetes Operator with Helm.\n\n   ```bash\n   helm install ngrok-ingress-controller ngrok/kubernetes-ingress-controller \\\n     --namespace ngrok-ingress-controller \\\n     --create-namespace \\\n     --set credentials.apiKey=$NGROK_API_KEY \\\n     --set credentials.authtoken=$NGROK_AUTHTOKEN\n   ```\n\n1. Verify the health of your new Operator pod.\n\n   ```bash\n   kubectl get pods -l 'app.kubernetes.io/name=kubernetes-ingress-controller'\n\n   NAME                                                              READY   STATUS    RESTARTS   AGE\n   ngrok-ingress-controller-kubernetes-ingress-controller-man2fg5p   1/1     Running   0          2m23s\n   ```\n\n1. Create a new `boutique-ingress.yml` file, which defines how the ngrok Kubernetes Operator should route traffic on your `NGROK_DOMAIN` to your Online Boutique app.\n<Tip>\n**Make sure you edit line `9` of the manifest below, which contains the `NGROK_DOMAIN` variable, with the ngrok subdomain you already created. It should look something like `one-two-three.ngrok.app`.**\n\n\n\n   If you are adding the ngrok Kubernetes Operator to a different deployment, you will need also change the `metadata.name`, `service.name`, and `service.port.number` values to match your app's configuration. See the [controller docs](https://github.com/ngrok/ngrok-operator/tree/main/docs) for additional details on `spec` settings and common overrides.\n</Tip>\n\n   ```yaml\n   apiVersion: networking.k8s.io/v1\n   kind: Ingress\n   metadata:\n     name: boutique-ingress\n     namespace: default\n   spec:\n     ingressClassName: ngrok\n     rules:\n       - host: NGROK_DOMAIN\n         http:\n           paths:\n             - path: /\n               pathType: Prefix\n               backend:\n                 service:\n                   name: frontend\n                   port:\n                     number: 80\n   ```\n\n1. Apply the `boutique-ingress.yaml` manifest you just created.\n\n   ```bash\n   kubectl apply -f boutique-ingress.yaml\n   ```\n\n   Give your cluster a few moments to launch the necessary resources and for ngrok's cloud service to pick up the new tunnel.\n<Tip>\n**If you see an error when applying the manifest, double-check that you've updated the `NGROK_DOMAIN` value and re-apply.**\n</Tip>\n\n1. Access your app, with ingress now handled by ngrok, by navigating to your ngrok domain, e.g. `https://one-two-three.ngrok.app`, in your browser.\n\n## **Step 3**: Update your ngrok Edge to enable SAML \n\nYour Kubernetes-based app is now publicly accessible through the ngrok cloud service—to restrict access to only authorized users with proper Microsoft Entra ID credentials, you first need to enable SAML on your Edge.\n\n1. Navigate to the [**Edges** section](https://dashboard.ngrok.com/edges) of the ngrok dashboard and click on the Edge created by the ngrok Kubernetes Operator. The domain name should match your `NGROK_DOMAIN`, and you should see **Created by kubernetes-ingress-controller** in the edge's description.\n\n   ![Finding your edge in the ngrok dashboard](img/k8s_edge-dashboard.png)\n\n1. From the Overview, click **Add SAML**, then **Begin setup**.\n\n1. In the **IdP Metadata** textbox, add the following:\n\n   ```xml\n   <EntityDescriptor xmlns=\"urn:oasis:names:tc:SAML:2.0:metadata\"></EntityDescriptor>\n   ```\n\n1. Click **Save**, at which point ngrok will update your SAML configuration with **SP Metadata**, **Entity ID**, and **ACS URL** values—you'll need these in the next step.\n\n![An ngrok Edge with SAML enabled](img/k8s_saml-enabled.png)\n\n## **Step 4**: Create an enterprise app in Microsoft Entra ID \n\nWith SAML configured on your ngrok Edge, you can now configure Microsoft Entra ID to operate as your identity provider, often called **IdP**.\n\n1. Access your [Microsoft Entra ID tenant](https://portal.azure.com/#view/Microsoft_AAD_IAM/ActiveDirectoryMenuBlade/~/Overview) in the Azure console.\n\n1. Click **Enterprise applications** in the left-hand sidebar, then **+ New application**, and finally **+ Create your own application**. Give your app a name—for our example, `online-boutique` will work nicely, and make sure you've selected the **Integrate any other application you don't find in the gallery (Non-gallery)** option.\n\n   ![Create an application on Amazon Microsoft Entra ID](img/k8s_create-app.png)\n\n1. Click **Create** to build your enterprise app, which will take you to its Overview dashboard.\n\n1. To provide specific users or groups access to your app, click **Assign users and groups** and follow the steps before heading back to the **Overview**.\n\n1. Click **Set up single sign on** to allow users to sign in to your app using their Microsoft Entra credentials, then choose **SAML** as your single sign-on protocol.\n\n   ![Choose SAML as your app's single sign-on protocol](img/k8s_choose-saml.png)\n\n1. Click **Edit** in the **Basic SAML Configuration** box. Copy the **Entity ID** from ngrok into the **Identifier (Entity ID)** field, and the **ACS URL** from ngrok into the **Reply URL (Assertion Consumer Service URL)** field. Click **Save** before you close the modal.\n\n   ![Configuring SAML in Microsoft Entra ID](img/k8s_configure-saml.png)\n\n1. In the **SAML Certificates** box, download the **Federation Metadata XML**.\n\n## **Step 5**: Finish adding Microsoft Entra ID authorization to your ngrok Edge \n\nTime to head back to your ngrok dashboard to finish the SAML configuration.\n\n1. Update the **IdP Metadata** field by clicking **Upload XML** and choosing the `.xml` file you just downloaded.\n\n   ![Updating the existing SAML configuration](img/k8s_update-saml-xml.png)\n\n1. Click **Save**.\n\n## **Step 6**: Test authorization to your app using Microsoft Entra ID \n\nYou've finished integrating the ngrok Kubernetes Operator and Microsoft Entra ID! Your app, whether the Online Boutique used throughout this guide or a custom deployment, is now publicly accessible only to those authorized with their Microsoft Entra ID credentials. Time to test how it works:\n\n1. Open an incognito/private window in your browser, or a different browser than you've used so far, and navigate again to your `NGROK_DOMAIN`. You should see a single sign-on screen from Microsoft.\n\n   ![The single sign-on screen from Microsoft](img/k8s_sso-enabled.png)\n\n2. Enter credentials for a Microsoft account you assigned, either as an individual user or a group, to your enterprise application in Microsoft Entra ID during [step 4](#create-an-enterprise-app).\n\n   Behind the scenes, ngrok requests your identity provider, Microsoft Entra ID, for authentication. Once you sign in, or are already logged in, Microsoft Entra ID then returns a SAML assertion to ngrok, telling ngrok your authentication is confirmed and you have authorization to access the app.\n\n   Microsoft Entra ID will then redirect you back to your app!\n\n## What's next?\n\nYou've now integrated the ngrok Kubernetes Operator with Microsoft Entra ID to restrict access to your app to only authenticated users. With ngrok operating as middleware, handling both ingress to your Kubernetes cluster and the handshake with an Microsoft Entra ID as an identity provider, you can deploy and secure new apps in a multi-cloud environment using your existing Microsoft/Azure identity and access management settings.\n\nFrom an end user perspective, they only need to sign in once, using their Microsoft credentials, to authenticate themselves and access any number of applications you manage using Microsoft Entra ID.\n\nFrom here, you have a few options:\n\n### Clean up\n\nIf you created a local cluster with Minikube to launch the Online Boutique demo app, you can delete the cluster entirely:\n\n```bash\nminikube delete -p online-boutique\n```\n\nngrok will delete your Edge automatically. To restore your previous authorization settings, head back to [Microsoft Entra ID](https://portal.azure.com/#view/Microsoft_AAD_IAM/ActiveDirectoryMenuBlade/~/Overview) to delete your enterprise application.\n\n### Extend your ngrok Kubernetes Operator and Microsoft Entra ID integration\n\nngrok can manage multiple routes on a single Edge, allowing you to configure [name-based virtual hosting](https://github.com/ngrok/ngrok-operator/blob/main/docs/user-guide/ingress-to-edge-relationship.md#name-based-virtual-hosting) or [route\nmodules](https://github.com/ngrok/ngrok-operator/blob/main/docs/user-guide/route-modules.md) to secure multiple apps with a single sign-on experience.\n\n[Custom domains](https://github.com/ngrok/ngrok-operator/blob/main/docs/user-guide/custom-domain.md) and a [circuit breaker](/traffic-policy/actions/circuit-breaker/) are also good next steps to make your integration production-ready.\n\nLearn more about the ngrok Kubernetes Operator, or contribute, by checking out the [GitHub\nrepository](https://github.com/ngrok/ngrok-operator) and the [project-specific\ndocumentation](https://github.com/ngrok/ngrok-operator/tree/main/docs).\n",
			  "contentTitle": "Ingress to apps secured by Microsoft Entra ID in Kubernetes"
			},
			{
			  "path": "/integrations/azure-ad/sso-saml",
			  "frontMatter": {
				"description": "Use Microsoft Entra ID to secure access to ngrok endpoints",
				"title": "Microsoft Entra ID SSO (SAML)"
			  },
			  "content": "import Disclaimer from \"/snippets/integrations/_endpoint-sso-disclaimer.mdx\";\n\n<Disclaimer />\n<Tip>\n**TL;DR**\n\n\nTo have ngrok enforce Single Sign-On using SAML with Microsoft Entra ID:\n\n1. [Create an ngrok Edge](#create-edge)\n1. [Create a Microsoft Entra ID application](#create-app)\n1. [Update the ngrok Edge with the IdP metadata](#update-ngrok-edge)\n1. [Test your integration](#test-integration)\n1. [Bonus: configure ngrok to enforce authorization based on Azure groups](#bonus)\n</Tip>\n\nThis article details how to configure Microsoft Entra ID as an Identity Provider for your ngrok Edge. By integrating Microsoft Entra ID with ngrok, you can:\n\n- Restrict access to ngrok tunnels to only users who authenticated via Microsoft Entra ID\n- Configure Microsoft Entra ID and ngrok to enforce user and group authorization\n- Use Microsoft Entra ID's dashboard to facilitate access to ngrok applications\n\n## Requirements\n\nTo configure ngrok tunnels with Microsoft Entra ID, you must have:\n\n- an [ngrok Enterprise Account](https://ngrok.com/pricing) with an authtoken or admin access to configure edges with SAML\n- a Microsoft Azure account with access to an Microsoft Entra ID tenant\n\n## Step 1: Create an ngrok Edge \n\n1.  Go to the [ngrok dashboard](https://dashboard.ngrok.com)\n1.  Click **Universal Gateway** > **Edges**\n1.  Create an Edge:\n    1. Click **New Edge**\n    1. Click **HTTPS Edge**\n    1. Click the **Pencil Icon** next to \"no description\". Enter _Edge With Microsoft Entra ID SSO_ as the Edge name and click **Save**\n\n1.  Configure the SAML module for this Edge:\n    1. On the Routes section, click **SAML**\n    1. Click **Begin setup**\n    1. In the Identity Provider section, copy the following XML as a placeholder into the input box\n\n    ```xml\n    <EntityDescriptor xmlns=\"urn:oasis:names:tc:SAML:2.0:metadata\"></EntityDescriptor>\n    ```\n\n    ![img/1-3.png](img/1-3.png)\n    1. Click **Save**\n\n    1. Note that ngrok has now generated values for the fields in the Service Provider section. You will need to configure Microsoft Entra ID with these values later\n\n## Step 2: Create an Microsoft Entra ID application \n\n1. Go to your [Microsoft Entra ID tenant in Azure](https://portal.azure.com/#view/Microsoft_AAD_IAM/ActiveDirectoryMenuBlade/~/Overview)\n\n1. Create an enterprise application\n   1. Starting from the sidebar, in the Manage section, click **Enterprise Applications** > **New application**\n   1. Give your application a name (eg `www` for a website client). Click **Create**\n\n   ![img/2-2.png](img/2-2.png)\n\n1. To assign users/groups for this application, in the Getting Started section, click **1. Assign users and groups** > **Add user/group**\n\n1. Set up single sign on with SAML\n   1. In the Getting Started section, click on the box titled **2. Set up single sign on** > **SAML**\n   1. Configure SAML. In the Basic SAML Configuration box click **Edit**\n\n   ![img/2-4.png](img/2-4.png)\n   1. Add Identifier (Entity ID) and Reply URL (Assertion Consumer Service URL) values using the previously the ngrok generated Entity ID and ACS URL\n\n   ![img/2-4b.png](img/2-4b.png)\n   1. Click **Save**\n   1. Download the Metadata XML. In the SAML Certificates box > Token signing certificate section > click **Download** for the Federation Metadata XML\n\n   ![img/2-4c.png](img/2-4c.png)\n\n## Step 3: Update the ngrok Edge with the IdP metadata \n\n1. Back in the ngrok dashboard for your Edge's SAML configuration, upload the XML file generated by Microsoft Entra ID\n\n   ![img/3-1.png](img/3-1.png)\n\n1. Click **Save**\n\n## Step 4: Test the integration \n<Tip>\n**Note**\n\n\nFor this step, we assume you have an app running locally (i.e. on localhost:3000) with the ngrok client installed.\n</Tip>\n\n1. Launch a tunnel connected to your configured Edge\n\n1. On your Edge's page, in the Routes section, click **Start a tunnel**\n\n   ![img/4-1.png](img/4-1.png)\n\n1. Copy the tunnel command\n\n   ![img/4-1b.png](img/4-1b.png)\n\n1. Launch a terminal and paste the command, replacing `http://localhost:80` with your local web app address (e.g., `http://localhost:3000`)\n1. Hit **Enter** to launch the tunnel\n\n1. Confirm that the tunnel is connected to your edge\n   1. Return to the ngrok dashboard\n   1. Close the **Start a tunnel** and the **Tunnel group** drawers\n   1. Refresh the Edge page\n   1. In the Routes section > Traffic section you will see the message _You have 1 tunnel online. Start additional tunnels to begin load balancing._\n\n   ![img/4-2.png](img/4-2.png)\n\n1. Copy the ngrok url on the Endpoints section\n\n1. Access your Edge application\n   1. In your browser, launch an incognito window\n   1. Access your ngrok tunnel via your copied URL\n   1. You should be prompted to log in with your Microsoft credentials\n   1. After login, you should be able to see the application\n\n## Bonus: Configure ngrok to enforce authorization based on Azure groups \n\n1. In Azure, configure the SAML response to include group claims. In the Attributes & Claims box click **Edit**\n\n   ![img/5-1.png](img/5-1.png)\n\n1. Click **Add a group claim** > **Advanced options** > Customize the name of the group claim\n1. Set the name of the group claim to `groups`. This specific value is required for ngrok\n\n   ![img/5-3.png](img/5-3.png)\n\n1. Click **Save**\n1. Go to your group page and copy the object Id (Microsoft Entra ID returns group object Ids in the group claim)\n\n   ![img/5-5.png](img/5-5.png)\n\n1. Configure ngrok to enforce group authorization. In ngrok on your Edge's page, in the Authorization section, update the groups input with your Azure group object Id (NOT group name) values\n\n   ![img/5-6.png](img/5-6.png)\n\n1. Access your Edge application\n   1. In your browser, launch an incognito window\n   1. Access your ngrok tunnel via your copied URL\n   1. You should be prompted to log in with your Microsoft credentials\n   1. Only users assigned to the authorized groups will have access to the application\n",
			  "contentTitle": "Microsoft Entra ID SSO (SAML)"
			}
		  ],
		  "metadata": {
			"name": "microsoft-entra-id",
			"description": "",
			"excerpt": "",
			"title": "Microsoft Entra ID"
		  }
		},
		{
		  "name": "azure-ad-b2c",
		  "path": "/integrations/azure-ad-b2c",
		  "docs": [
			{
			  "path": "/integrations/azure-ad-b2c/sso-saml",
			  "frontMatter": {
				"description": "Use Microsoft Azure AD B2C to secure access to ngrok endpoints",
				"title": "Azure Active Directory B2C SSO (SAML)"
			  },
			  "content": "import Disclaimer from \"/snippets/integrations/_endpoint-sso-disclaimer.mdx\";\n\n<Disclaimer />\n<Tip>\n**TL;DR**\n\n\nTo have ngrok enforce Single Sign-On using SAML with Azure Active Directory B2C (Azure AD B2C):\n\n1. [Create an ngrok Edge](#create-edge)\n1. [Configure Azure AD B2C custom policies](#create-policies)\n1. [Create an Azure AD B2C SAML application](#create-app)\n1. [Update the ngrok Edge with the IdP metadata](#update-ngrok-edge)\n1. [Test your integration](#test-integration)\n1. [Bonus: Update your Azure AD B2C custom policies to support the password reset flow](#bonus)\n</Tip>\n\nThis article details how to configure Azure AD B2C as an Identity Provider for your ngrok Edge. By integrating Azure AD B2C with ngrok, you can:\n\n- Restrict access to ngrok tunnels to only users who authenticated via Azure AD B2C\n- Allow users to authenticate via a local account or federated accounts via Azure AD B2C\n\n## Requirements\n\nTo configure ngrok tunnels with Azure AD B2C, you must have:\n\n- an [ngrok Enterprise Account](https://ngrok.com/pricing) with an authtoken or admin access to configure edges with SAML\n- a Microsoft Azure account with access to an Azure AD B2C tenant\n- an understanding of Azure AD B2C [custom policies](https://learn.microsoft.com/en-us/azure/active-directory-b2c/custom-policy-overview)\n\n## Step 1: Create an ngrok Edge \n\n1.  Go to the [ngrok dashboard](https://dashboard.ngrok.com)\n1.  Click **Universal Gateway** > **Edges**\n1.  Create an Edge:\n    1. Click **New Edge**\n    1. Click **HTTPS Edge**\n    1. Click the **Pencil Icon** next to \"no description\". Enter _Edge With Azure Active Directory B2C SSO_ as the Edge name and click **Save**\n\n1.  Configure the SAML module for this Edge:\n    1. On the Routes section, click **SAML**\n    1. Click **Begin setup**\n    1. In the Identity Provider section, copy the following XML as a placeholder into the input box\n\n    ```xml\n    <EntityDescriptor xmlns=\"urn:oasis:names:tc:SAML:2.0:metadata\"></EntityDescriptor>\n    ```\n\n    ![img/1-3.png](img/1-3.png)\n    1. Click **Save**\n\n    1. Note that ngrok has now generated values for the fields in the Service Provider section. We will use these to configure Azure AD B2C later\n\n## Step 2: Configure Azure AD B2C custom policies \n\n1. Follow the directions based on the [Azure docs](https://learn.microsoft.com/en-us/azure/active-directory-b2c/tutorial-create-user-flows?pivots=b2c-custom-policy)\n\n1. Some hints\n   1. For a SAML application, you need to configure custom policies as it is not possible to use the user flows, as noted elsewhere in the [Azure docs](https://learn.microsoft.com/en-us/azure/active-directory-b2c/saml-service-provider?tabs=macos&pivots=b2c-user-flow#register-your-saml-application-in-azure-ad-b2c)\n   1. A couple resources to make the process of following these steps easier: you can follow along the docs with the templates shared in [Azure AD B2C custom policy starterpack](https://github.com/Azure-Samples/active-directory-b2c-custom-policy-starterpack), or you can to use the [IEF Setup App](https://b2ciefsetupapp.azurewebsites.net) to automate these steps\n   1. To keep things simple, use the `LocalAccounts` starter pack. This means users will sign up and log in as users in your Azure AD B2C tenant vs. with another identity provider This means you can skip configuring Facebook as an identity provider. If you are using the IEF Setup App, click the checkbox for `Remove Facebook references` before you deploy the starter pack\n   1. Skip the steps of `Register a web application` and `Enable ID token implicit grant` unless you'd like to test this now. We will register a SAML application and test it later\n\n## Step 3: Create an Azure AD B2C SAML application \n\n1. Follow the directions based on the [Azure docs](https://learn.microsoft.com/en-us/azure/active-directory-b2c/saml-service-provider?tabs=windows&pivots=b2c-custom-policy)\n\n1. Some hints\n   1. Update your previously created custom policies to use SAML. You can either update the files in the starterpack repo, or you can download the XML files for your existing policies from the [Identity Experience Framework page](https://portal.azure.com/#view/Microsoft_AAD_B2CAdmin/CustomPoliciesMenuBlade/~/overview/tenantId/ngroksaml.onmicrosoft.com)\n   1. If you are using the `LocalAccounts` starter pack, remember to adjust the orchestration step order value to `4` as noted in these docs\n   1. Use the following mapping of Azure AD B2C configuration properties to ngrok generated values (found in your Edge's SAML configuration in the Service Provider section) to configure your application\n\n   | Azure AD B2C      | ngrok         |\n   | ----------------- | ------------- |\n   | `RedirectURI`     | `ACS URL`     |\n   | `identifierUri`   | `EntityID`    |\n   | `samlMetadataUrl` | `SP Metadata` |\n\n   ![img/3-2.png](img/3-2.png)\n\n   ![img/3-2b.png](img/3-2b.png)\n\n## Step 4: Update the ngrok Edge with the IdP metadata \n\n1. Back in the ngrok dashboard for your Edge's SAML configuration, copy and paste the XML found at the IdP Saml Metadata URL in the Identity Provider section, replacing the previously set placeholder value. Note the IdP Metadata URL follows this format: `https://<tenant-name>.b2clogin.com/<tenant-name>.onmicrosoft.com/<policy-name>/Samlp/metadata`.\n\n   ![img/4-1.png](img/4-1.png)\n\n1. Click **Save**\n\n## Step 5: Test the integration \n<Tip>\n**Note**\n\n\nFor this step, we assume you have an app running locally (i.e. on localhost:3000) with the ngrok client installed.\n</Tip>\n\n1. Launch a tunnel connected to your configured Edge\n\n1. On your Edge's page, in the Routes section, click **Start a tunnel**\n\n   ![img/5-1.png](img/5-1.png)\n\n1. Copy the tunnel command\n\n   ![img/5-1b.png](img/5-1b.png)\n\n1. Launch a terminal and paste the command, replacing `http://localhost:80` with your local web app address (e.g., `http://localhost:3000`)\n\n1. Hit **Enter** to launch the tunnel\n\n1. Confirm that the tunnel is connected to your edge\n   1. Return to the ngrok dashboard\n   1. Close the **Start a tunnel** and the **Tunnel group** drawers\n   1. Refresh the Edge page\n   1. In the Routes section > Traffic section you will see the message _You have 1 tunnel online. Start additional tunnels to begin load balancing._\n\n   ![img/5-2.png](img/5-2.png)\n\n1. Copy the ngrok url on the Endpoints section\n\n1. Access your Edge application\n   1. In your browser, launch an incognito window\n   1. Access your ngrok tunnel via your copied URL\n   1. You should be prompted to log in or sign up\n\n   ![img/5-3.png](img/5-3.png) 4. After login, you should be able to see the application\n\n## Bonus: Update your Azure AD B2C custom policies to support the password reset flow \n\n1. From the test, you may notice that the `Forgot your password?` link doesn't work. You will need to embed the password reset flow as part of your sign up / sign in custom policy for local accounts, as the `LocalAccounts` starter pack did not include this flow as part of the sign up / sign in policy. Here is [sample code from Azure AD B2C](https://github.com/azure-ad-b2c/samples/tree/master/policies/embedded-password-reset) on how to configure this\n",
			  "contentTitle": "Azure Active Directory B2C SSO (SAML)"
			}
		  ],
		  "metadata": {
			"name": "azure-ad-b2c",
			"description": "",
			"excerpt": "",
			"title": "Azure AD B2C"
		  }
		},
		{
		  "name": "azure-aks",
		  "path": "/integrations/azure-aks",
		  "docs": [
			{
			  "path": "/integrations/azure-aks/k8s",
			  "frontMatter": {
				"title": "Ingress to Kubernetes apps deployed on Azure Kubernetes Service (AKS)",
				"description": "Learn how to deploy a new Kubernetes cluster and demo app via AKS, then add ingress to applications with ngrok's Kubernetes Operator."
			  },
			  "content": "\nIn this guide, you'll launch a new cluster with [Azure Kubernetes Service (AKS)](https://azure.microsoft.com/en-us/products/kubernetes-service) and a demo app. You'll then add the ngrok Kubernetes Operator to route public traffic directly to your demo app through an encrypted, feature-rich tunnel for a complete proof of concept.\n\nIn the end, you'll have learned enough to deploy your next production-ready Kubernetes app with AKS, with the ngrok Kubernetes Operator giving you access to additional features, like observability and resiliency, with no extra configuration complexity.\n\nHere is what you'll be building with:\n\n- The [ngrok Kubernetes Operator](https://ngrok.com/blog-post/ngrok-k8s): ngrok's official controller for adding secure public ingress and middleware execution to your Kubernetes apps with ngrok's cloud service. With ngrok, you can manage and secure traffic to your apps at every stage of the development lifecycle while also benefitting from simpler configurations, security, and edge acceleration.\n- Azure Kubernetes Service (AKS): A managed Kubernetes environment from Microsoft. AKS simplifies the deployment, health monitoring, and maintenance of cloud native applications, whether you deploy them in Azure, in on-premises data centers, or at the edge. With [40 regions](https://azure.microsoft.com/en-us/explore/global-infrastructure/products-by-region/?products=kubernetes-service), you should be able to deploy a cluster close to your customers.\n\n## What you'll need\n\n- An [Azure account](https://azure.microsoft.com/en-us/pricing/purchase-options/pay-as-you-go) with permissions to create new Kubernetes clusters.\n- An [ngrok account](https://ngrok.com/signup).\n- [kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl/) and [Helm\n  3.0.0+](https://helm.sh/docs/intro/install/) installed on your local\n  workstation.\n- The [ngrok Kubernetes Operator](/k8s/) installed on\n  your cluster.\n- A reserved domain, which you can get in the ngrok\n  [dashboard](https://dashboard.ngrok.com/domains) or with the [ngrok\n  API](/api/resources/reserved-domains/).\n  - You can choose from an ngrok subdomain or bring your own custom branded\n    domain, like `https://api.example.com`.\n  - We'll refer to this domain as `<NGROK_DOMAIN>`.\n\n## Create your cluster in AKS \n\nStart by creating a new managed Kubernetes cluster in AKS. If you already have one, you can skip to [Add ngrok's Kubernetes ingress to your demo app](#add-ngrok-based-ingress-to-your-demo-app).\n\n1. Go to the [Kubernetes services](https://portal.azure.com/#view/HubsExtension/BrowseResource/resourceType/Microsoft.ContainerService%2FmanagedClusters) section in your Azure console and click **Create**&rarr;**Create a Kubernetes cluster**.\n\n1. Configure your new cluster with the wizard. The default options are generally safe bets, but there are a few you might want to look at depending on your requirements and budget:\n   - Cluster present configuration: You can choose a production-ready deployment, a dev/test deployment, and others.\n   - Region: The data center where AKS will deploy your cluster—pick a region geographically close to your primary customers and/or your organization.\n   - AKS pricing tier: The **Free** tier works great with less than 10 nodes, and you can always upgrade to the production tier after deployment.\n\n1. Click **Review + create** and wait for Azure to validate your configuration. If you see a **Validation failed.** warning, check out the errors—they're likely related to [quota limits](https://learn.microsoft.com/en-us/azure/quotas/regional-quota-requests). When it's ready, click **Create**. Grab a cup of coffee—deployment will take a while.\n\n1. When AKS completes the deployment, click **Go to deployment**, then **Connect**, which will show you options for connecting to your new cluster with kubectl. Follow the instructions to use the Cloud shell or Azure CLI, then double-check AKS has successfully deployed your cluster's underlying services:\n\n   ```bash\n   kubectl get deployments --all-namespaces=true\n   NAMESPACE         NAME                      READY   UP-TO-DATE   AVAILABLE   AGE\n   calico-system     calico-kube-controllers   1/1     1            1           5m\n   calico-system     calico-typha              1/1     1            1           5m\n   kube-system       ama-metrics               1/1     1            1           5m\n   kube-system       ama-metrics-ksm           1/1     1            1           5m\n   kube-system       coredns                   2/2     2            2           5m\n   kube-system       coredns-autoscaler        1/1     1            1           5m\n   kube-system       konnectivity-agent        2/2     2            2           5m\n   kube-system       metrics-server            2/2     2            2           5m\n   tigera-operator   tigera-operator           1/1     1            1           5m\n   ```\n\n## Deploy a demo microservices app \n\nTo showcase how this integration works, you'll deploy the [AKS Store](https://github.com/Azure-Samples/azure-voting-app-redis) app, which uses a microservices architecture to connect frontend UI to API-like services, passing data to RabbitMQ and MongoDB in the backend. To showcase the features of AKS, you'll deploy this demo app directly in the Azure Portal.\n<Tip>\n**If you prefer the CLI, save the YAML below to a `.yaml` file on your local workstation and deploy with `kubectl apply -f ...`.**\n</Tip>\n\n1. Click **Create**&rarr;**Apply a YAML**.\n\n1. Copy and paste the YAML below into the editor.\n\n   ```yaml showLineNumbers collapsible\n   apiVersion: apps/v1\n   kind: Deployment\n   metadata:\n     name: rabbitmq\n   spec:\n     replicas: 1\n     selector:\n       matchLabels:\n         app: rabbitmq\n     template:\n       metadata:\n         labels:\n           app: rabbitmq\n       spec:\n         nodeSelector:\n           \"kubernetes.io/os\": linux\n         containers:\n           - name: rabbitmq\n             image: mcr.microsoft.com/mirror/docker/library/rabbitmq:3.10-management-alpine\n             ports:\n               - containerPort: 5672\n                 name: rabbitmq-amqp\n               - containerPort: 15672\n                 name: rabbitmq-http\n             env:\n               - name: RABBITMQ_DEFAULT_USER\n                 value: \"username\"\n               - name: RABBITMQ_DEFAULT_PASS\n                 value: \"password\"\n             resources:\n               requests:\n                 cpu: 10m\n                 memory: 128Mi\n               limits:\n                 cpu: 250m\n                 memory: 256Mi\n             volumeMounts:\n               - name: rabbitmq-enabled-plugins\n                 mountPath: /etc/rabbitmq/enabled_plugins\n                 subPath: enabled_plugins\n         volumes:\n           - name: rabbitmq-enabled-plugins\n             configMap:\n               name: rabbitmq-enabled-plugins\n               items:\n                 - key: rabbitmq_enabled_plugins\n                   path: enabled_plugins\n   ---\n   apiVersion: v1\n   data:\n     rabbitmq_enabled_plugins: |\n       [rabbitmq_management,rabbitmq_prometheus,rabbitmq_amqp1_0].\n   kind: ConfigMap\n   metadata:\n     name: rabbitmq-enabled-plugins\n   ---\n   apiVersion: v1\n   kind: Service\n   metadata:\n     name: rabbitmq\n   spec:\n     selector:\n       app: rabbitmq\n     ports:\n       - name: rabbitmq-amqp\n         port: 5672\n         targetPort: 5672\n       - name: rabbitmq-http\n         port: 15672\n         targetPort: 15672\n     type: ClusterIP\n   ---\n   apiVersion: apps/v1\n   kind: Deployment\n   metadata:\n     name: order-service\n   spec:\n     replicas: 1\n     selector:\n       matchLabels:\n         app: order-service\n     template:\n       metadata:\n         labels:\n           app: order-service\n       spec:\n         nodeSelector:\n           \"kubernetes.io/os\": linux\n         containers:\n           - name: order-service\n             image: ghcr.io/azure-samples/aks-store-demo/order-service:latest\n             ports:\n               - containerPort: 3000\n             env:\n               - name: ORDER_QUEUE_HOSTNAME\n                 value: \"rabbitmq\"\n               - name: ORDER_QUEUE_PORT\n                 value: \"5672\"\n               - name: ORDER_QUEUE_USERNAME\n                 value: \"username\"\n               - name: ORDER_QUEUE_PASSWORD\n                 value: \"password\"\n               - name: ORDER_QUEUE_NAME\n                 value: \"orders\"\n               - name: FASTIFY_ADDRESS\n                 value: \"0.0.0.0\"\n             resources:\n               requests:\n                 cpu: 1m\n                 memory: 50Mi\n               limits:\n                 cpu: 75m\n                 memory: 128Mi\n         initContainers:\n           - name: wait-for-rabbitmq\n             image: busybox\n             command:\n               [\n                 \"sh\",\n                 \"-c\",\n                 \"until nc -zv rabbitmq 5672; do echo waiting for rabbitmq; sleep 2; done;\",\n               ]\n             resources:\n               requests:\n                 cpu: 1m\n                 memory: 50Mi\n               limits:\n                 cpu: 75m\n                 memory: 128Mi\n   ---\n   apiVersion: v1\n   kind: Service\n   metadata:\n     name: order-service\n   spec:\n     type: ClusterIP\n     ports:\n       - name: http\n         port: 3000\n         targetPort: 3000\n     selector:\n       app: order-service\n   ---\n   apiVersion: apps/v1\n   kind: Deployment\n   metadata:\n     name: product-service\n   spec:\n     replicas: 1\n     selector:\n       matchLabels:\n         app: product-service\n     template:\n       metadata:\n         labels:\n           app: product-service\n       spec:\n         nodeSelector:\n           \"kubernetes.io/os\": linux\n         containers:\n           - name: product-service\n             image: ghcr.io/azure-samples/aks-store-demo/product-service:latest\n             ports:\n               - containerPort: 3002\n             resources:\n               requests:\n                 cpu: 1m\n                 memory: 1Mi\n               limits:\n                 cpu: 1m\n                 memory: 7Mi\n   ---\n   apiVersion: v1\n   kind: Service\n   metadata:\n     name: product-service\n   spec:\n     type: ClusterIP\n     ports:\n       - name: http\n         port: 3002\n         targetPort: 3002\n     selector:\n       app: product-service\n   ---\n   apiVersion: apps/v1\n   kind: Deployment\n   metadata:\n     name: store-front\n   spec:\n     replicas: 1\n     selector:\n       matchLabels:\n         app: store-front\n     template:\n       metadata:\n         labels:\n           app: store-front\n       spec:\n         nodeSelector:\n           \"kubernetes.io/os\": linux\n         containers:\n           - name: store-front\n             image: ghcr.io/azure-samples/aks-store-demo/store-front:latest\n             ports:\n               - containerPort: 8080\n                 name: store-front\n             env:\n               - name: VUE_APP_ORDER_SERVICE_URL\n                 value: \"http://order-service:3000/\"\n               - name: VUE_APP_PRODUCT_SERVICE_URL\n                 value: \"http://product-service:3002/\"\n             resources:\n               requests:\n                 cpu: 1m\n                 memory: 200Mi\n               limits:\n                 cpu: 1000m\n                 memory: 512Mi\n   ---\n   apiVersion: v1\n   kind: Service\n   metadata:\n     name: store-front\n   spec:\n     ports:\n       - port: 80\n         targetPort: 8080\n     selector:\n       app: store-front\n     type: LoadBalancer\n   ```\n\n1. Click **Add** to deploy the demo app. To double-check services deployed successfully, click on **Workloads** in the Azure Portal and look for `store-front`, `rabbitmq`, `product-service`, and `order-service` in the `default` namespace. If you prefer the CLI, you can run `kubectl get pods` for the same information.\n\n## Add ngrok's Kubernetes ingress to your demo app \n\nNext, you'll configure and deploy the [ngrok Kubernetes Operator](https://github.com/ngrok/ngrok-operator) to expose your demo app to the public internet through the ngrok cloud service.\n\n1. In the Azure Portal, click **Create&rarr;Apply a YAML**.\n\n1. Copy and paste the YAML below into the editor. This manifest defines how the ngrok Kubernetes Operator should route traffic arriving on `NGROK_DOMAIN` to the `store-front` service on port `80`, which you deployed in the previous step.\n<Tip>\n**Make sure you edit line `9` of the YAML below, which contains the `NGROK_DOMAIN` variable, with the ngrok subdomain you created in the second step.**\n</Tip>\n\n   ```yaml showLineNumbers\n   apiVersion: networking.k8s.io/v1\n   kind: Ingress\n   metadata:\n     name: store-ingress\n   spec:\n     ingressClassName: ngrok\n     rules:\n       - host: NGROK_DOMAIN\n         http:\n           paths:\n             - path: /\n               pathType: Prefix\n               backend:\n                 service:\n                   name: store-front\n                   port:\n                     number: 80\n   ```\n\n1. Click **Add** to deploy the ingress configuration.\n\n   You can check on the status of the ingress deployment in the Azure Portal at **Services and ingresses**&rarr;**Ingresses**. You should see the `store-ingress` name and your ngrok subdomain. If you need to edit your ingress configuration in the future, click on the ingress item and then the **YAML** tab.\n\n1. Navigate to your ngrok subdomain, e.g. `https://NGROK_DOMAIN.ngrok.app`, in your browser to see the demo app in action. Behind the scenes, ngrok's cloud service routed your request into the ngrok Kubernetes Operator, which then passed it to the `store-front` service.\n\n   ![The AKS Store demo app accessible from the public internet](img/store-front.png)\n\n## Add OAuth authentication to your demo app \n\nNow that your demo app is publicly accessible through the ngrok cloud service, you can quickly layer on [additional capabilities](/universal-gateway/http/), like authentication, without configuring and deploying complex infrastructure. Let's see how that works for restricting access to individual Google accounts or any Google account under a specific domain name.\n\nWith our [Traffic Policy system](/traffic-policy/) and the [`oauth`\naction](/traffic-policy/actions/oauth), ngrok manages OAuth protection\nentirely at the ngrok cloud service, which means you don't need to add any\nadditional services to your cluster, or alter routes, to ensure ngrok's edge\nauthenticates and authorizes all requests before allowing ingress and access to\nyour endpoint.\n\nTo enable the `oauth` action, you'll create a new `NgrokTrafficPolicy` custom\nresource and apply it to your entire `Ingress` with an annotation. You can also\napply the policy to just a specific backend or as the default backend for an\n`Ingress`—see our doc on using the [Operator with\nIngresses](/k8s/guides/using-ingresses/#using-ngroktrafficpolicy-with-ingress).\n\n1. Edit your existing ingress YAML with the following. Note the new `annotations` field and\n   the `NgrokTrafficPolicy` CR.\n\n   ```yaml\n    ...\n   ---\n   # Configuration for ngrok's Kubernetes Operator\n   apiVersion: networking.k8s.io/v1\n   kind: Ingress\n   metadata:\n     name: game-2048-ingress\n     namespace: default\n     annotations:\n       k8s.ngrok.com/traffic-policy: oauth\n   spec:\n     ingressClassName: ngrok\n     rules:\n       - host: <NGROK_DOMAIN>\n         http:\n           paths:\n             - path: /\n               pathType: Prefix\n               backend:\n                 service:\n                   name: game-2048\n                   port:\n                     number: 80\n   ---\n   # Traffic Policy configuration for OAuth\n   apiVersion: ngrok.k8s.ngrok.com/v1alpha1\n   kind: NgrokTrafficPolicy\n   metadata:\n     name: oauth\n     namespace: default\n   spec:\n     policy:\n   \t   on_http_request:\n   \t\t   - type: oauth\n   \t\t\t   config:\n   \t\t\t     provider: google\n   ```\n\n1. When you open your demo app again, you'll be asked to log in via Google.\n   That's a start, but what if you want to authenticate only yourself or colleagues?\n\n1. You can use [expressions](/traffic-policy/concepts/expressions) and [CEL\n   interpolation](/traffic-policy/concepts/cel-interpolation) to filter out\n   and reject OAuth logins that don't contain `example.com`. Update the\n   `NgrokTrafficPolicy` portion of your manifest after changing `example.com` to\n   your domain.\n\n   ```yaml\n    # Traffic Policy configuration for OAuth\n    apiVersion: ngrok.k8s.ngrok.com/v1alpha1\n    kind: NgrokTrafficPolicy\n    metadata:\n      name: oauth\n      namespace: default\n    spec:\n      policy:\n        on_http_request:\n          - type: oauth\n            config:\n              provider: google\n          - expressions:\n              - \"!actions.ngrok.oauth.identity.email.endsWith('@example.com')\"\n            actions:\n              - type: custom-response\n                config:\n                  body: Hey, no auth for you ${actions.ngrok.oauth.identity.name}!\n                  status_code: 400\n   ```\n\n1. Check out your deployed app once again. If you log in with an email that\n   doesn't match your domain, ngrok rejects your request. Authentication... done!\n\n## What's next?\n\nYou've now used the open source ngrok Kubernetes Operator to add public ingress to a demo app on a cluster managed in AKS without having to worry about complex Kubernetes networking configurations. Because ngrok abstracts ingress and middleware execution to its cloud service, you can follow a similar process to route public traffic to your next production-ready app.\n\nFor next steps, explore our [Kubernetes docs](/k8s/) for more details on\nhow the Operator works, different ways you can integrate ngrok with an existing\nproduction cluster, or use more advanced features like\n[bindings](/k8s/guides/bindings/) or [endpoint\npooling](/k8s/guides/pooling/).\n",
			  "contentTitle": "Ingress to Kubernetes apps deployed on Azure Kubernetes Service (AKS)"
			}
		  ],
		  "metadata": {
			"name": "azure-aks",
			"description": "",
			"excerpt": "",
			"title": "Azure Kubernetes Service (AKS)"
		  }
		},
		{
		  "name": "azure-logs-ingestion",
		  "path": "/integrations/azure-logs-ingestion",
		  "docs": [
			{
			  "path": "/integrations/azure-logs-ingestion/event-destination",
			  "frontMatter": {
				"title": "Integrate with the Azure Logs Ingestion API",
				"description": "Send network traffic logs from ngrok to Azure Logs Ingestion",
				"tags": [
				  "events",
				  "logs",
				  "azure",
				  "event destinations"
				]
			  },
			  "content": "\n# Azure Logs Ingestion Event Destination\n\nThis guide covers how to send ngrok events including network traffic logs into Azure via the Logs Ingestion API.\n\nThis is useful if you want to keep an audit log of configuration changes within your ngrok\naccount, record all traffic to your endpoints for active monitoring/troubleshooting, or leveraging it as a SIEM for security inspections.\n\nBy integrating ngrok with Azure, you can:\n\n- **Quickly identify application issues** in real-time using ngrok request events using Azure logs processing.\n- **Historically audit changes occurring within an account**. Be able to historically audit changes within an account.\n- **Profile usage of your service** by using logs queries and real-time data analytics.\n- **Identify security issues** by using ngrok events.\n\n## **Step 1**: Create a Log Analytics Workspace \n\nThese steps were adapted from the [Create a Logs Analytics Workspace docs from Microsoft](https://learn.microsoft.com/en-us/azure/azure-monitor/logs/quick-create-workspace).\n\n1. Using a browser, log into your [Azure portal](https://portal.azure.com).\n\n2. Navigate to the search bar and type in **Log Analytics Workspaces**\n\n3. Click on the **Services** entry (not the Marketplace entry).\n\n![search log analytics workspaces](img/search-workspaces.png)\n\n4. Click **Create** on the top bar Log Analytics Workspace page.\n\n5. Follow the wizard to create your Log Analytics Workspace, filling in the necessary region information, name, and resource group, before clicking **Review + Create**. These values can be anything you like and do not impact ngrok's ability to send logs to your Azure account.\n\n6. Click **Create** at the bottom of the review step to finally provision the Log Analytics Workspace.\n\n![create log analytics workspaces](img/create-workspace-review.png)\n\nYou now have a **Log Analytics Workspace**, which will be the home for your data collection endpoint, tables, and rules.\n\n## **Step 2**: Create a Data Collection Endpoint \n\nThese steps were adapted from the [Create a data collection endpoint](https://learn.microsoft.com/en-us/azure/azure-monitor/essentials/data-collection-endpoint-overview#create-a-data-collection-endpoint) docs from Microsoft.\n\n1. Navigate to the search bar and type in **Data Collection Endpoints**\n\n2. Click on the **Services** entry.\n\n![search data collection endpoints](img/search-dce.png)\n\n3. Click **Create** on the top bar Data Collection Endpoints page.\n\n4. Follow the wizard to create your Data Collection Endpoint, filling in the necessary region information, name, and resource group, before clicking **Review + Create**. These fields can be anything you like and to not impact ngrok's ability to send logs to your Azure account.\n\n5. Click **Create** at the bottom of the review step to provision the Data Collection Endpoint.\n\n![create dce](img/create-dce.png)\n\nYou now have a **Data Collection Endpoint**, which is the network accessible service that ngrok connects via to send events into Azure.\n\n## **Step 3**: Create a DCR-based Custom Table in the Workspace \n\nThese steps were adapted from the [Create a new table in Log Analytics workspace](https://learn.microsoft.com/en-us/azure/azure-monitor/logs/tutorial-logs-ingestion-portal?source=recommendations#create-new-table-in-log-analytics-workspace) docs from Microsoft.\n\n1. Navigate to the **Log Analytics Workspaces** list once again.\n\n2. Click the workspace you created previously in [**Step 1**](#log-analytics-workspace).\n\n3. Navigate to **Settings -> Tables** in the sidebar menu of the selected workspace.\n\n4. Click **Create** on the top bar, and select **New custom log (DCR-based)**.\n\n![create dcr-based table](img/create-dcr-table.png)\n\n5. Populate the table name with a name of your choice and the DCE field with the existing DCE you created in [**Step 2**](#data-collection-endpoint).\n\n6. Click **Create a new data collection rule** underneath the Data collection rule field, which opens a drawer. Fill out the resource group and name, before clicking **Done** on the drawer.\n\n![create dcr drawer](img/dcr-create-drawer.png)\n\n7. Click **Next** in the table creation wizard.\n\n8. Upload the following json file using the wizard. After uploading, you will notice a warning header \"TimeGenerated field is not found in the sample provided\" which is expected.\n\n```json\n{\n\t\"event_id\": \"ev_2iKcXvmLJoZojWzrCuLbstBCle0\",\n\t\"event_type\": \"test\",\n\t\"event_timestamp\": \"2024-06-24T15:25:52Z\",\n\t\"object\": {}\n}\n```\n<Tip>\n**Not to worry!**\n\n\nYou will notice a warning header \"TimeGenerated field is not found in the sample provided\"; this is expected.\n\nWe will remedy this by using the **Transformation Editor**.\n</Tip>\n\n9. Click the **Transformation editor** button on the top bar of the wizard, which will open a drawer.\n\n10. Paste in the following transformation and click **Run**.\n\n```\nsource\n| extend TimeGenerated = event_timestamp\n```\n\n![transformation editor](img/transformation.png)\n\n11. Click **Apply**.\n\n12. Click **Next**.\n\n13. Click **Create**.\n\n![create table success](img/create-table-success.png)\n\nYou now have a **Data Collection Rule** properly configured for ngrok events, alongside a table where the data will be stored.\n\n## **Step 4**: Create a Microsoft Entra Application \n\nThese steps were adapted from the [Create a Microsoft Entra Application](https://learn.microsoft.com/en-us/azure/azure-monitor/logs/tutorial-logs-ingestion-portal?source=recommendations#create-microsoft-entra-application) docs from Microsoft.\n\n1. Navigate to the search bar and type in **Microsoft Entra ID**.\n\n2. Select the **Microsoft Entra ID** under **Services**, not the Marketplace item.\n\n![search Microsoft Entra ID](img/search-entra.png)\n\n3. Navigate to **Manage -> App registrations** on the sidebar.\n\n4. Click **New registration**\n\n5. Name the application **ngrok-events** or something similar to clarify its use; this entity will be what ngrok uses to authenticate with your data collection endpoint.\n\n6. Select the first radio option, **Accounts in this organizational directory only** for the account type\n\n7. Click **Register**\n\n![register app](img/register.png)\n\nYou have now created an **Microsoft Entra ID App Registration**, which is a service user construct that grants roles/access to services like ngrok.\n\n## **Step 5**: Assign IAM permissions to the Application for the DCR \n\nThese steps were adapted from the [Assign permissions to the DCR](https://learn.microsoft.com/en-us/azure/azure-monitor/logs/tutorial-logs-ingestion-portal?source=recommendations#assign-permissions-to-the-dcr) docs from Microsoft.\n\n1. Navigate to the search bar and type in **Data collection rules**.\n\n2. Select the **Data collection rules** option under **Services**.\n\n3. Click on the Data collection rule created in [**Step 3**](#data-collection-rule).\n\n4. Click **Access control (IAM)** on the sidebar.\n\n5. Click **Add** on the top bar.\n\n6. Click **Add role assignment**.\n\n7. Search for **Monitoring** in the search bar underneath **Job function roles**.\n\n8. Click on **Monitoring Metrics Publisher**.\n\n![register app](img/role-assignment.png)\n\n9. Click **Next**, advancing to Members.\n\n10. Click **Select members**.\n\n11. Search for the app registration you created in [**Step 4**](#entra-application).\n\n12. Click on the service principal and click **Select**.\n\n13. Click **Review + assign**.\n\n14. Click **Review + assign** again, confirming the role assignment.\n\n![review app role](img/review-role.png)\n\nYou have now granted access for the ngrok application to ingest logs into the DCR, which is the final step before we can create an Event Destination.\n\n## **Step 6**: Gather necessary data for Event Destination \n\nIn order to create an event destination in your ngrok Dashboard, we will need to gather the following information from what we just created in Azure:\n\n- the Tenant ID\n- the Application's Client ID\n- the Application's Client Secret\n- the DCR immutable ID\n- the DCR stream name\n- the DCE log ingestion URI\n\n1. To gather the first three fields, we will navigate back to **Microsoft Entra ID**. Search for **Entra** in the top search bar and select the **Microsoft Entra ID** service.\n\n2. Navigate to **Manage -> App registrations** in the sidebar, and select the application you created in [**Step 4**](#entra-application).\n\n3. Copy the **Application (client) ID** and **Directory (tenant) ID** from the Overview Page.\n\n![app ids](img/app-ids.png)\n\n4. Navigate to **Manage -> Certificates & secrets** in the sidebar.\n\n5. Click **New client secret**.\n\n6. Fill in the description and expiry date with the desired values, before clicking **Add**.\n\n7. Copy the secret value provided by Azure - **this value will no longer be available once you navigate away**.\n\n![app secret](img/app-secret.png)\n\n8. To gather the DCR persistent ID and stream name, navigate to **Data collection rules** using the top search bar.\n\n9. Select the Data collection rule you created in [**Step 3**](#data-collection-rule).\n\n10. In the **Overview** tab, copy the **Immutable Id** value.\n\n![immutable id](img/immutable-id.png)\n\n11. Navigate to **Configuration -> Data sources** in the sidebar.\n\n12. Copy the **Data source** name, which should start with **Custom\\_** and end with **\\_CL**. This is the **DCR stream name**.\n\n![stream name](img/stream-name.png)\n\n13. Finally, navigate to **Data collection endpoints** in the top search bar.\n\n14. Select the Data collection endpoint you created in [**Step 2**](#data-collection-endpoint).\n\n15. In the **Overview** tab, copy the **Logs Ingestion URI**.\n\nYou now have all the required data to create an event destination with ngrok!\n\n## **Step 7**: Create the new Event Destination in ngrok \n\nAt this point, you can choose to create the event destination [through the ngrok Dashboard](#create-via-dashboard) or via [the ngrok API](#create-via-ngrok-api).\n\n### Creating through the ngrok Dashboard \n\n1. Log into the ngrok Dashboard and navigate to [**Traffic Observability > Events Stream**](https://dashboard.ngrok.com/observability/event-subscriptions).\n\n1. Create a **new Log Export** through the plus sign in the top left or open an existing one.\n\n1. After adding one or more sources, select the **Destinations** tab and **Add Destination**\n\n1. Select the **Azure Logs Ingestion API** option\n\n1. Fill in the fields based on the values you collected in **Step 6**.\n\n1. Click **Send Test Event** and look for an example event in your Azure Account. It may take a minute to show up due to propagation delays.\n\n1. Click **Done** and save the new Log Export.\n\n### Creating via the ngrok API \n\n1. Create an API key with ngrok. You can do this via the [ngrok dashboard](https://dashboard.ngrok.com/api).\n\n2. Using your Rest API tool of choice (cURL, Postman, etc.), you will run the following API calls.\n\n3. To create the Azure logs ingestion event destination, run the following call:\n\n```bash\ncurl --location 'https://api.ngrok.com/event_destinations' \\\n--header 'Accept: application/json' \\\n--header 'Ngrok-Version: 2' \\\n--header 'Content-Type: application/json' \\\n--header 'Authorization: Bearer {API_KEY}' \\\n--data '{\n    \"format\": \"json\",\n    \"target\": {\n        \"azure_logs_ingestion\": {\n            \"tenant_id\":     \"{TENANT_ID}\",\n\t\t      \"client_id\":     \"{CLIENT_ID}\",\n\t\t      \"client_secret\": \"{CLIENT_SECRET}\",\n\n\t\t      \"logs_ingestion_uri\":          \"{DCE_LOGS_INGESTION_URI}\",\n\t\t      \"data_collection_rule_id\":     \"{DCR_RULE_ID}\",\n\t\t      \"data_collection_stream_name\": \"{DCR_STREAM_NAME}\"\n         }\n    }\n}'\n```\n\nCopy the returned event destination ID (highlighted below).\n\n```json {2}\n{\n\t\"id\": \"ed_12345\",\n\t\"created_at\": \"...\",\n\t\"format\": \"json\",\n\t\"target\": {\n\t\t\"firehose\": null,\n\t\t\"kinesis\": null,\n\t\t\"cloudwatch_logs\": null,\n\t\t\"datadog\": null,\n\t\t\"azure_logs_ingestion\": {\n\t\t\t\"tenant_id\": \"...\",\n\t\t\t\"client_id\": \"...\",\n\t\t\t\"client_secret\": \"\",\n\t\t\t\"logs_ingestion_uri\": \"...\",\n\t\t\t\"data_collection_rule_id\": \"...\",\n\t\t\t\"data_collection_stream_name\": \"...\"\n\t\t}\n\t},\n\t\"uri\": \"https://api.ngrok.com.lan/event_destinations/ed_2iQktWaNCyWVNjFYWGkdzhrbvF5\"\n}\n```\n\n4. To create a log export (event subscription) using the previously created event destination, run the following call\n\n```bash\ncurl \\\n-X POST \\\n-H \"Authorization: Bearer {API_KEY}\" \\\n-H \"Content-Type: application/json\" \\\n-H \"Ngrok-Version: 2\" \\\n-d '{\n   \"description\":\"ip policy creations\",\n   \"destination_ids\":[\"{EVENT_DESTINATION_ID}\"],\n   \"sources\":[\n      {\"type\":\"ip_policy_created.v0\"},\n      {\"type\":\"{MORE_EVENT_TYPES}\"}\n   ]\n}' \\\nhttps://api.ngrok.com/event_subscriptions\n```\n\nAfter getting a 200 response, your event destination is successfully configured and subscribed to the set of events types you desire.\n",
			  "contentTitle": "Integrate with the Azure Logs Ingestion API"
			}
		  ],
		  "metadata": {
			"name": "azure-logs-ingestion",
			"description": "",
			"excerpt": "",
			"title": "Azure Logs Ingestion"
		  }
		},
		{
		  "name": "bitbucket",
		  "path": "/integrations/bitbucket",
		  "docs": [
			{
			  "path": "/integrations/bitbucket/webhooks",
			  "frontMatter": {
				"description": "Develop and test Bitbucket webhooks from localhost",
				"title": "Bitbucket Repository Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Bitbucket webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Bitbucket webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Bitbucket to allow Bitbucket to send notifications to your app anytime an event takes place in a Bitbucket repository.\n\nBy integrating ngrok with Bitbucket, you can:\n\n- **Develop and test Bitbucket webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Bitbucket** in real-time via the inspection UI and API.\n- **Modify and Replay Bitbucket Webhook requests** with a single click and without spending time reproducing events manually in your Bitbucket account.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n1. [Download the ngrok agent](https://download.ngrok.com).\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Bitbucket).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Bitbucket \n\nBitbucket can trigger webhook calls to external applications whenever events happen in a repository. To register for such events, follow the instructions below:\n\n1. Access [Bitbucket](https://bitbucket.com/) and sign in using your Bitbucket account.\n\n1. Click **Repositories** on the top menu and click the name of a repository from the repository list.\n   **Tip:** If you don't have a repository, create a new empty one.\n\n1. In the repository page, click **Repository settings** from the left menu and then click **Webhooks**.\n\n1. On the **Webhooks** page, click **Add webhook**.\n\n1. On the **Add new webhook** page, enter a **Title** for your webhook and in the **URL** field enter the URL provided by the ngrok agent to expose your application to the internet (i.e., `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![URL](img/ngrok_url_configuration_bitbucket.png)\n\n1. Mark the **Push** checkbox under the **Triggers** section and then click **Save** at the bottom of the page.\n\n### Run Webhooks with Bitbucket and ngrok\n\nBecause you've selected the **Push** event as the trigger for your webhook, Bitbucket will submit a post request to your application through ngrok whenever you push content to your repository.\n**Note:** Different messages are sent to your application depending on the trigger event you choose.\n\nFollow the instructions below to add some content to your repository:\n\n1. Click the name of your repository at the top of the left menu.\n\n1. On the project's page, click **...** and then click **Add file**.\n\n1. In the **Source** page, enter a name for the file in the **Filename** field, and enter the following content to the file in the textbox:\n   `This is my new file content`.\n\n1. Click **Commit**, and then click **Commit** in the Commit changes popup.\n\n   Confirm your localhost app receives the push event notification and logs both headers and body to the terminal.\n\nAlternatively, clone your repository locally, add some content, commit, and then push the content to your repostiory on Bitbucket:\n`bash\n    git add .; git commit -m \"my first commit\"; git push\n    `\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nTHe following are quick steps to add extra protection to your application.\n\n- If you are running Bitbucket Cloud, use ngrok IP Restrictions to allow ingress access for a list of IP addresses.\n\n  **Note:** This feature requires ngrok Pro or Enterprise plan.\n  1. You can find a list of CloudFront IP Addresses used by Bitbucket Cloud in the [Bitbucket Support documents](https://support.atlassian.com/bitbucket-cloud/docs/what-are-the-bitbucket-cloud-ip-addresses-i-should-use-to-configure-my-corporate-firewall/).\n\n  1. Go to the [ngrok dashboard](https://dashboard.ngrok.com), sign in, click **Security** in the left menu, and then click **IP Restrictions**.\n\n  1. In the **Agent** section, click **Attach IP Policies**, click **New IP Policy**, and then click **Add Rule**.\n\n  1. In the **Add Rule** section, click **Allow** and then enter the CIDR that covers the IP Address from Bitbucket (i.e `123.456.789.1/32`) in the **CIDR** field.\n\n  1. Enter a **Description** for both the rule and the policy, click **Save**, and then click **Attach IP Policy**.\n\n  1. On the **IP Restrictions** page, click **Save**.\n\n- If you are running Bitbucket Server, ngrok signature webhook verification feature to allow ngrok to assert that requests from your Bitbucket webhook are the only traffic allowed to make calls to your localhost app.\n\n  **Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n  1. Access your Bitbucket repository, navigate through the interface to the webhook page, and then edit the webhook.\n\n  1. In the **Authentication** section, select **Secret token** as the method, and then enter a value for the secret token.\n\n  1. Create a traffic policy file named `bitbucket_policy.yml` replacing `{your secret token}` with the value you entered before:\n\n  ```yaml\n  - on_http_request:\n    - actions:\n      - type: verify-webhook\n        config:\n          provider: bitbucket\n          secret: \"{your secret token}\"\n  ```\n\n  1. Restart your ngrok agent by running the command:\n\n  ```bash\n  ngrok http 3000 --traffic-policy-file bitbucket_policy.yml\n  ```\n\n  1. Access your repository, add a new file and then commit the file.\n\n  Verify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "Bitbucket Repository Webhooks"
			}
		  ],
		  "metadata": {
			"name": "bitbucket",
			"description": "",
			"excerpt": "",
			"title": "Bitbucket"
		  }
		},
		{
		  "name": "box",
		  "path": "/integrations/box",
		  "docs": [
			{
			  "path": "/integrations/box/webhooks",
			  "frontMatter": {
				"description": "Develop and test Box webhooks from localhost",
				"title": "Box Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Box webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Box webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Box by using Webhooks.\nBox webhooks can be used to notify an external application whenever specific events occur in your Box account.\n\nBy integrating ngrok with Box, you can:\n\n- **Develop and test Box webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Box** in real-time via the inspection UI and API.\n- **Modify and Replay Box Webhook requests** with a single click and without spending time reproducing events manually in your Box account.\n- **Secure your app with Box validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Box).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Box \n\nTo register a webhook on your Box account follow the instructions below:\n\n1. Access [Box](https://box.com/), sign in using your Box account, and then click **Dev Console** on the left menu.\n\n1. On the **Box Developer** console, click **Create New App**, and then click **Custom App**.\n\n1. On the **Custom App** popup, click **Server Authentication (with JWT)**, enter a name for the app in the **App name** field, and then click **Create App**.\n\n1. On the app's page, click the **Configuration** tab, mark the **Manage Webhooks** checkbox under **Developer Actions**, and then click **Save Changes**.\n\n1. Click the **Authorization** tab, click **Review and Submit**, enter `Requesting Access` in the **App Description** field, and then click **Submit**.\n\n1. Access [Box Admin Console](https://app.box.com/master), click **Apps** on the left menu, click the **Custom App Manager** tab, click **View** on your app, click **Authorize**, and then click **Authorize**.\n\n1. Back to the [Box Developer Console](https://app.box.com/developers/console), click your app name, click the **Webhook** tab, click **Create Webhook**, and then click **V2**.\n\n1. On the **Create a Webhook** page, enter the URL provided by the ngrok agent to expose your application to the internet in the **URL Address** field (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![URL to Publish](img/ngrok_url_configuration_box.png)\n\n1. Click **Choose an item** for the **Content Type** section, select a folder from your box account, and then click **Choose**.\n\n1. Click **File Triggers**, mark the **File Uploaded** checkbox, and then click **Create Webhook**.\n\n### Run Webhooks with Box and ngrok\n\nBecause you registered your webhook with the **File Uploaded** trigger, Box sends a notification to your application whenever you upload files to a folder.\n\n1. Access [Box](https://box.com/), sign in using your Box account, and then upload a file from your desktop to the folder you selected during the webhook registration. See [Integrate Box](#setup-webhook).\n\nAfter the file upload process is completed, Box sends a post request to your application.\n\nConfirm your localhost app receives the **FILE.UPLOADED** event notification and logs both headers and body in the terminal.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Box webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Access [Box Developer Console](https://app.box.com/developers/console), click your app name, click the **Webhook** tab, and then click **Manage Signature Keys**.\n\n1. On the **Manage Signature Keys** page, click **Generate Key** in the **Primary Key** section and then click **COPY** to copy the value of the generated primary key.\n\n1. Create a traffic policy file named `box_policy.yml`, replacing `{your primary key}` with the value you have copied before:\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: box\n             secret: \"{your primary key}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file box_policy.yml\n   ```\n\n1. Access [Box](https://box.com/), sign in using your Box account, and then upload a file from your desktop to the folder you selected during the webhook registration. See [Integrate Box](#setup-webhook).\n\n   Verify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "Box Webhooks"
			}
		  ],
		  "metadata": {
			"name": "box",
			"description": "",
			"excerpt": "",
			"title": "Box"
		  }
		},
		{
		  "name": "brex",
		  "path": "/integrations/brex",
		  "docs": [
			{
			  "path": "/integrations/brex/webhooks",
			  "frontMatter": {
				"description": "Develop and test Brex webhooks from localhost",
				"title": "Brex Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Brex webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Brex webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Brex by using Webhooks.\nBrex webhooks can be used to notify an external application whenever specific events occur in your Brex account.\n\nBy integrating ngrok with Brex, you can:\n\n- **Develop and test Brex webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Brex** in real-time via the inspection UI and API.\n- **Modify and Replay Brex Webhook requests** with a single click and without spending time reproducing events manually in your Brex account.\n- **Secure your app with Brex validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Brex).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Brex \n\nTo register a webhook on your Brex account follow the instructions below:\n\n1. Access the [Brex Dashboard](https://dashboard.brex.com) and sign in using your Brex account.\n\n1. On the left menu, click **Settings** and then click **Create Token**.\n\n1. On the **Create an API token** page, enter a name for your token in the **Token Name** field, select **Write** for the **Referrals** and **Users** scopes, and then click **Create Token**.\n\n1. On the next page, click **Allow access** to allow the API to access your Brex account.\n\n1. The following page shows a token value. Copy this value and then click **Done**.\n\n1. Use a desktop terminal to execute the following command:\n\n   ```bash\n   curl -i -X POST https://platform.brexapis.com/v1/webhooks -H 'Authorization: Bearer YOUR_TOKEN_HERE' -H 'Content-Type: application/json' -H 'Idempotency-Key: string' -d '{\"YOUR_NGROK_URL\": \"string\",\"event_types\": [\"USER_UPDATED\"]}'\n   ```\n\n   **Note**: Replace `YOUR_TOKEN_HERE` with the token value you copied before, and `YOUR_NGROK_URL` with the URL provided by the ngrok agent to expose your application to the internet (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n\n   ![webhook](img/ngrok_url_configuration_brex.png)\n\n1. Brex API responds with HTTP status 200 and a JSON containing the `\"status\": \"ACTIVE\"` attribute/value pair.\n\n### Run Webhooks with Brex and ngrok\n\nYou can trigger new calls from Brex to your application by following the instructions below.\n\n1. Access the [Brex Dashboard](https://dashboard.brex.com) and sign in using your Brex account.\n\n1. On the left menu, click **Team**, click **User**, and then click **Invite user**.\n\n1. On the **New user** page, enter the requested information, select the role for this user as **employee**, and then click **Send invite**.\n\n   Confirm your localhost app receives event notifications related to the workflow you started and logs both headers and body in the terminal.\n\n   **Note**: If Brex doesn't send the notification to your localhost app, access the email account of the user you created on Brex, open the Brex invitation email, and then accept the invitation by clicking **Create account**.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Brex webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Use a desktop terminal to execute the following command:\n\n   ```bash\n   curl -i -X GET https://platform.brexapis.com/v1/webhooks/secrets -H 'Authorization: Bearer YOUR_TOKEN_HERE'\n   ```\n\n   **Note**: Replace `YOUR_TOKEN_HERE` with the token value you copied before. See [Integrate ngrok and Brex](#setup-webhook).\n\n1. Brex API responds with HTTP status 200 and a JSON containing the `\"secret\": \"<webhook_secret>\"` attribute/value pair.\n\n1. Create a traffic policy file named `brex_policy.yml`:\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: brex\n             secret: {webhook_secret}\n   ```\n\n   **Note**: Replace `{webhook_secret}` with the value of the **secret** attribute you received before.\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file brex_policy.yml\n   ```\n\n1. Access the [Brex Dashboard](https://dashboard.brex.com), sign in using your Brex account, and create a new user. See [Run Webhooks with Brex and ngrok](#run-webhooks-with-brex-and-ngrok).\n\n   Verify that your local application receives the request and logs information to the terminal after you create the new user and the invitation is accepted.\n",
			  "contentTitle": "Brex Webhooks"
			}
		  ],
		  "metadata": {
			"name": "brex",
			"description": "",
			"excerpt": "",
			"title": "Brex"
		  }
		},
		{
		  "name": "buildkite",
		  "path": "/integrations/buildkite",
		  "docs": [
			{
			  "path": "/integrations/buildkite/webhooks",
			  "frontMatter": {
				"description": "Develop and test Buildkite webhooks from localhost",
				"title": "Buildkite Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Buildkite webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Buildkite webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Buildkite by using Webhooks.\nBuildkite webhooks can be used to notify an external application whenever specific events occur in your Buildkite account.\n\nBy integrating ngrok with Buildkite, you can:\n\n- **Develop and test Buildkite webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Buildkite** in real-time via the inspection UI and API.\n- **Modify and Replay Buildkite Webhook requests** with a single click and without spending time reproducing events manually in your Buildkite account.\n- **Secure your app with Buildkite validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Buildkite).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Buildkite \n\nTo register a webhook on your Buildkite account follow the instructions below:\n\n1. Access [Buildkite](https://buildkite.com/) and sign in using your Buildkite account.\n\n1. On the welcome page, click **Settings** on the top menu and click **Notification Services** on the left menu.\n\n1. On the **Notification Services** page, click **Add** for the **Webhook** line.\n\n1. On the **Add Webhook Notification** page, enter `My LocalHost App` in the **Description** field and enter the URL provided by the ngrok agent to expose your application to the internet in the **Webhook URL** field (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![Webhook URL](img/ngrok_url_configuration_buildkite.png)\n\n1. In the **Events** section, select all events.\n\n1. In the **Pipelines** section, select **All Pipelines**, and then click **Add Webhook Notification**.\n\n### Run Webhooks with Buildkite and ngrok\n\nBuildkite sends different request body contents depending on the event that is being triggered.\nYou can trigger new calls from Buildkite to your application by following the instructions below.\n\n1. On the welcome page, click **Pipelines** on the top menu and then click one of your pipelines.\n   **Note**: Create a pipeline if you don't have one by clicking **Create your first pipeline** and following the instructions on the screen.\n\n1. On your pipeline page, click **New Build**, enter a message in the **Message** field, and then click **Create Build**.\n\n   Confirm your localhost app receives event notifications and logs both headers and body in the terminal.\n\nAlternatively, you can verify the log of the webhook call in Buildkite:\n\n1. Click **Settings** on the top menu, click **Notification Services** on the left menu, click the **My LocalHost App** webhook tile, scroll down to the **Request Log** section, and then click one of the logs:\n   ![Webhook Logs](img/ngrok_logs_buildkite.png)\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Buildkite webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Access [Buildkite](https://buildkite.com/) and sign in using your Buildkite account.\n\n1. On the organization page, click **Settings** on the top menu and click **Notification Services** on the left menu.\n\n1. On the **Notification Services** page, click the **My LocalHost App** webhook tile, copy the value of the **Token** field, select **Send an HMAC signature**, and then click **Save Webhook Settings**.\n\n1. Create a traffic policy file named `buildkite_policy.yml`, replacing `{your token}` with the value you have copied before:\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: buildkite\n             secret: \"{your token}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file buildkite_policy.yml\n   ```\n\n1. Click **Pipelines** on the top menu, select one of your pipelines and create a new build.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "Buildkite Webhooks"
			}
		  ],
		  "metadata": {
			"name": "buildkite",
			"description": "",
			"excerpt": "",
			"title": "Buildkite"
		  }
		},
		{
		  "name": "calendly",
		  "path": "/integrations/calendly",
		  "docs": [
			{
			  "path": "/integrations/calendly/webhooks",
			  "frontMatter": {
				"description": "Develop and test Calendly webhooks from localhost",
				"title": "Calendly Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Calendly webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Calendly webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Calendly by using Webhooks.\nCalendly webhooks can be used to notify an external application whenever specific events occur in your Calendly account.\n\nBy integrating ngrok with Calendly, you can:\n\n- **Develop and test Calendly webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Calendly** in real-time via the inspection UI and API.\n- **Modify and Replay Calendly Webhook requests** with a single click and without spending time reproducing events manually in your Calendly account.\n- **Secure your app with Calendly validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Calendly).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Calendly \n\nTo register a webhook on your Calendly account follow the instructions below:\n\n1. Access [Calendly](https://calendly.com/) and sign in using your Calendly account.\n\n1. On the **My Calendly** page, click **Integrations** on the top menu.\n\n1. On the **All integrations** page, click the **API and webhooks** tile and then click **Get a token** under the **Personal access tokens** section.\n\n1. On the **Before you begin** popup, click **Continue**, enter a name for the token in the **Choose a name for this token** field, click **Create token**, click **Copy token**, and then click **Close**.\n   **Tip**: Make note of the token value.\n\n1. On the **Your personal access tokens** page, scroll down and click **Copy Key** in the **API Key** section.\n   **Tip**: Make note of the key value.\n\n1. Open a terminal window and run the following command to gather information about your account:\n\n   ```bash\n   curl --request GET --url https://api.calendly.com/users/me \\\n   --header 'authorization: Bearer TOKEN'\n   ```\n\n   **Note**: Replace the value TOKEN in the command with the token value you copied before.\n\n1. The terminal logs the response of the previous command. Copy the value of the **current_organization** field and the **uri** field.\n\n1. In the terminal window, run the following command to register the webhook:\n\n   ```bash\n   curl --request POST --url https://api.calendly.com/webhook_subscriptions \\\n   --header 'Authorization: Bearer TOKEN' \\\n   --header 'Content-Type: application/json' --data '{\n   \"url\": \"URL\",\n   \"events\": [\n       \"invitee.created\",\n       \"invitee.canceled\"\n   ],\n   \"organization\": \"ORGANIZATION_URL\",\n   \"user\": \"USER_URL\",\n   \"scope\": \"user\",\n   \"signing_key\": \"KEY\"\n   }'\n   ```\n\n   **Note**: Replace the following with values copied on previous steps:\n   - URL: the URL provided by the ngrok agent to expose your application to the internet (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   - TOKEN: the Calendly token.\n   - ORGANIZATION_URL: The **current_organization** field you copied before.\n   - USER_URL: The **uri** field you copied before.\n   - KEY: the key you copied before.\n\n   ![URL to Publish](img/ngrok_url_configuration_calendly.png)\n\n1. Make sure the response of the previous command contains a **resource** attribute with the information you provided.\n\n### Run Webhooks with Calendly and ngrok\n\nUse your Calendly link to schedule a meeting with you.\n**Note** If you don't know your Calendly link, access [Calendly](https://calendly.com/), click **Account** on the top right corner of the page, click **Share Your Link**, and then copy your link.\n\n1. In your Calendly link, click **30 Minutes Meeting**, select a date, and then click **Confirm**.\n\n1. In the **Enter Details** page, enter your name and email in the corresponding fields, and then click **Schedule Event**.\n\n   Confirm your localhost app receives the **invitee.created** event notification and logs both headers and body in the terminal.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Calendly webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Access [Calendly](https://calendly.com/) and sign in using your Calendly account.\n\n1. On the **My Calendly** page, click **Integrations** on the top menu.\n\n1. On the **All integrations** page, click the **API and webhooks** tile.\n\n1. On the **Your personal access tokens** page, scroll down and click **Copy Key** in the **API Key** section.\n   **Tip**: This is the same value you used to register your webhook. See [Integrate Calendly] (#setup-webhook).\n\n1. Create a traffic policy file named `calendly_policy.yml`, replacing `{your key}` with the value you have copied before:\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: calendly\n             secret: \"{your key}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file calendly_policy.yml\n   ```\n\n1. Access your Calendly link, click **30 Minutes Meeting**, select a date, and then click **Confirm**.\n\n1. In the **Enter Details** page, enter your name and email in the corresponding fields, and then click **Schedule Event**.\n\n   Confirm your localhost app receives the **invitee.created** event notification and logs both headers and body in the terminal.\n",
			  "contentTitle": "Calendly Webhooks"
			}
		  ],
		  "metadata": {
			"name": "calendly",
			"description": "",
			"excerpt": "",
			"title": "Calendly"
		  }
		},
		{
		  "name": "castle",
		  "path": "/integrations/castle",
		  "docs": [
			{
			  "path": "/integrations/castle/webhooks",
			  "frontMatter": {
				"description": "Develop and test Castle webhooks from localhost",
				"title": "Castle Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Castle webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Castle webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Castle by using Webhooks.\nCastle webhooks can be used to notify an external application whenever specific events occur in your Castle account.\n\nBy integrating ngrok with Castle, you can:\n\n- **Develop and test Castle webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Castle** in real-time via the inspection UI and API.\n- **Modify and Replay Castle Webhook requests** with a single click and without spending time reproducing events manually in your Castle account.\n- **Secure your app with Castle validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Castle).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Castle \n\nTo register a webhook on your Castle account follow the instructions below:\n\n1. Access the [Castle dashboard](https://dashboard.castle.io/) and sign in using your Castle account.\n\n1. On the left menu, click the gear icon close to your name and then click **Configuration**.\n\n1. On the **Application** page, click **Webhooks** on the top menu, and then click **Add a new Endpoint**.\n\n1. On the **Set up a new webhook endpoint** page, enter the URL provided by the ngrok agent to expose your application to the internet in the **ENDPOINT URL** field (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![Castle ENDPOINT URL](img/ngrok_url_configuration_castle.png)\n\n1. Select all events under the **EVENTS TO SUBSCRIBE** section and then click **Save**.\n\n1. On the **Webhooks** page, click the slider icon to activate the webhook.\n\n### Run Webhooks with Castle and ngrok\n\nCastle sends different request body contents depending on the event that is being triggered.\nYou can trigger new calls from Castle to your application by following the instructions below.\n\n1. On the **Application** page, click **Webhooks** on the top menu and then click **Test** for your webhook.\n\n1. On the **Test the webhook endpoint** popup, select an event in the **EVENT** field and then click **Send test webhook**.\n   **Note**: Optionally, you can create an event by using the Castle SDK.\n\n   Confirm your localhost app receives the test event notification and logs both headers and body in the terminal.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Castle webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Access the [Castle dashboard](https://dashboard.castle.io/) and sign in using your Castle account.\n\n1. On the left menu, click the gear icon close to your name and then click **Configuration**.\n\n1. On the **Application** page, copy the value of the **API SECRET** field.\n\n1. Create a traffic policy file named `castle_policy.yml`, replacing `{your api secret}` with the value you have copied before:\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: castle\n             secret: \"{your api secret}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file castle_policy.yml\n   ```\n\n1. Access the [Castle dashboard](https://dashboard.castle.io/) and test the webhook endpoint or create an event by using the Castle SDK.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "Castle Webhooks"
			}
		  ],
		  "metadata": {
			"name": "castle",
			"description": "",
			"excerpt": "",
			"title": "Castle"
		  }
		},
		{
		  "name": "chargify",
		  "path": "/integrations/chargify",
		  "docs": [
			{
			  "path": "/integrations/chargify/webhooks",
			  "frontMatter": {
				"description": "Develop and test Chargify webhooks from localhost",
				"title": "Chargify Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Chargify webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Chargify webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Chargify by using Webhooks.\nChargify webhooks can be used to notify an external application whenever specific events occur in your Chargify account.\n\nBy integrating ngrok with Chargify, you can:\n\n- **Develop and test Chargify webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Chargify** in real-time via the inspection UI and API.\n- **Modify and Replay Chargify Webhook requests** with a single click and without spending time reproducing events manually in your Chargify account.\n- **Secure your app with Chargify validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Chargify).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Chargify \n\nTo register a webhook on your Chargify account follow the instructions below:\n\n1. Access [Chargify](https://www.chargify.com/) and sign in using your Chargify account.\n\n1. On the home page, select a site from the **Site** dropdown on the top of the page.\n\n1. On the site page, click **Config**, click **Settings**, and then click **Webhooks**.\n\n1. On the **Webhooks** page, click **Add New Endpoint**.\n\n1. On the **Add New Endpoint** page, enter the URL provided by the ngrok agent to expose your application to the internet in the **Webhook URL** field (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![URL to Publish](img/ngrok_url_configuration_chargify.png)\n\n1. Select the **Events** you want to subscribe this webhook. For this tutorial, select all.\n\n1. Click **Add**.\n\n### Run Webhooks with Chargify and ngrok\n\nChargify sends different request body contents depending on the event that is being triggered.\nFollow the instructions below to test connectivity between Chargify and your local application using the webhook you created.\n\n1. Access your Chargfy's site home page, click **Tools** on the left menu and then click **Webhook Testing**.\n\n1. On the **Webhook Testing** page, select one of the events you subscribed the webhook, select the webhook, and then click **Send**.\n\n   Confirm your localhost app receives the create-project event notification and logs both headers and body in the terminal.\n\nOptionally, you can verify the log of the webhook call in Chargify:\n\n1. On the left menu, click **Tools** and then click **Webhook Panel**.\n\n1. On the **Webhooks** page, click **Details** to see details of the webhook call.\n   ![Webhook Logs](img/ngrok_logs_chargify.png)\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Chargify webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Access your Chargfy's site home page and click **Edit current Site** from the Site dropdown menu on top of the page.\n\n1. On the **Site** page, copy the value of the **Site Shared Key**.\n\n1. Create a traffic policy file named `chargify_policy.yml`:\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: chargify\n             secret: {your site shared key}\n   ```\n\n   **Note**: Replace `{your site shared key}` with the value you copied before.\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file chargify_policy.yml\n   ```\n\n1. Access the **Webhook Testing** page and send a new test notification to your webhook.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "Chargify Webhooks"
			}
		  ],
		  "metadata": {
			"name": "chargify",
			"description": "",
			"excerpt": "",
			"title": "Chargify"
		  }
		},
		{
		  "name": "circleci",
		  "path": "/integrations/circleci",
		  "docs": [
			{
			  "path": "/integrations/circleci/webhooks",
			  "frontMatter": {
				"description": "Develop and test CircleCI webhooks from localhost",
				"title": "CircleCI Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate CircleCI webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure CircleCI webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with CircleCI by using Webhooks.\nCircleCI webhooks can be used to notify an external application whenever specific events occur in your CircleCI account.\n\nBy integrating ngrok with CircleCI, you can:\n\n- **Develop and test CircleCI webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from CircleCI** in real-time via the inspection UI and API.\n- **Modify and Replay CircleCI Webhook requests** with a single click and without spending time reproducing events manually in your CircleCI account.\n- **Secure your app with CircleCI validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with CircleCI).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate CircleCI \n\nTo register a webhook on your CircleCI account follow the instructions below:\n\n1. Access [CircleCI](https://www.circleci.com/) and sign in using your CircleCI account.\n\n1. On the **All Pipelines** page, click the name of your pipeline.\n   **Tip**: If you don't have one, create a new pipeline.\n\n1. On your pipeline page, click **Project Settings** and then click **Webhooks** on the left menu.\n\n1. On the **Webhooks** page, click **Add Webhook**.\n\n1. On the **Add Webhook** page, enter a name in the **Webhook name** field, and in the **Receiver URL** field enter the URL provided by the ngrok agent to expose your application to the internet (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![URL to Publish](img/ngrok_url_configuration_circleci.png)\n\n1. Enter `MySecretToken` in the **Secret token** field, click the **Workflow Completed** and **Job Completed** checkboxes under **Events**, and then click **Add Webhook**.\n\n1. On the **Webhooks** page, click the name of your webhook, and then click **Test Ping Event**.\n\n   Confirm your localhost app receives the test-ping event notification and logs both headers and body to the terminal.\n\n### Run Webhooks with CircleCI and ngrok\n\nYou can trigger new calls from CircleCI to your application by following the instructions below.\n\n1. Access [CircleCI](https://www.circleci.com/) and sign in using your CircleCI account.\n   **Tip**: If you are at the **Project Settings** page, click **&lt;** at the top left corner to return to your pipeline page.\n\n1. On the **Pipeline** page, click **Rerun workflow from start** under the **Action** column for your pipeline.\n\n   Confirm your localhost app receives event notifications related to the workflow you started and logs both headers and body in the terminal.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your CircleCI webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Create a traffic policy file named `circleci_policy.yml`, replacing `{your secret token}` with the value you have provided to the **Secret token** field during your webhook registration (See [Integrate ngrok and CircleCI](#setup-webhook)):\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: circleci\n             secret: \"{your secret token}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file circleci_policy.yml\n   ```\n\n1. Access [CircleCI](https://www.circleci.com/) and Rerun your workflow from start.\n\n   Verify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "CircleCI Webhooks"
			}
		  ],
		  "metadata": {
			"name": "circleci",
			"description": "",
			"excerpt": "",
			"title": "CircleCI"
		  }
		},
		{
		  "name": "clearbit",
		  "path": "/integrations/clearbit",
		  "docs": [
			{
			  "path": "/integrations/clearbit/webhooks",
			  "frontMatter": {
				"description": "Develop and test Clearbit webhooks from localhost",
				"title": "Clearbit Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Clearbit webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Clearbit webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Clearbit by using Webhooks.\nClearbit webhooks can be used to notify an external application whenever specific events occur in your Clearbit account.\n\nBy integrating ngrok with Clearbit, you can:\n\n- **Develop and test Clearbit webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Clearbit** in real-time via the inspection UI and API.\n- **Modify and Replay Clearbit Webhook requests** with a single click and without spending time reproducing events manually in your Clearbit account.\n- **Secure your app with Clearbit validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Clearbit).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Clearbit \n\nTo register a webhook on your Clearbit account follow the instructions below:\n\n1. Access the [Clearbit API Dashboard](https://dashboard.clearbit.com/api) and sign in using your Clearbit account.\n\n1. On the **API Settings** section, enter the URL provided by the ngrok agent to expose your application to the internet in the **Webhook URL** field (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![Clearbit URL to Publish](img/ngrok_url_configuration_clearbit.png)\n\n1. Click **Update account**.\n\n1. Make note of the value of the **Secret API Key** that appears on the [Clearbit API Dashboard](https://dashboard.clearbit.com/api) page.\n   **Note**: Usually the secret key value starts with `sk_`.\n\n### Run Webhooks with Clearbit and ngrok\n\nClearbit sends different request body contents depending on the event that is being triggered.\nYou can trigger new calls from Clearbit to your application by following the instructions below.\n\n1. Open a terminal window and run the following command to gather information about your account:\n\n   ```\n   curl --request GET --url https://person.clearbit.com/v1/people/email/EMAIL_ADDRESS \\\n   --header 'Authorization: Bearer TOKEN'\n   ```\n\n   **Note**: Replace the following with values copied on previous steps:\n   - EMAIL_ADDRESS: An email address of a user in your Clearbit account organization.\n   - TOKEN: The Clearbit secret key you copied before.\n\n   Confirm your localhost app receives a notification and logs both headers and body in the terminal.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Clearbit webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Access the [Clearbit API Dashboard](https://dashboard.clearbit.com/api/) and sign in using your Clearbit account.\n\n1. Copy the value of the **Secret API Key** field that appears on the screen.\n   **Note**: Usually the secret key value starts with `sk_`.\n\n1. Create a traffic policy file named `clearbit_policy.yml`, replacing `{your api key}` with the value you copied before:\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: clearbit\n             secret: \"{your api key}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file clearbit_policy.yml\n   ```\n\n1. Repeat the command to gather information about your account.\n\nVerify that your local application receives the request and logs the information to the terminal.\n",
			  "contentTitle": "Clearbit Webhooks"
			}
		  ],
		  "metadata": {
			"name": "clearbit",
			"description": "",
			"excerpt": "",
			"title": "Clearbit"
		  }
		},
		{
		  "name": "clerk",
		  "path": "/integrations/clerk",
		  "docs": [
			{
			  "path": "/integrations/clerk/webhooks",
			  "frontMatter": {
				"description": "Develop and test Clerk webhooks from localhost",
				"title": "Clerk Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Clerk webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Clerk webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Clerk by using Webhooks.\nClerk webhooks can be used to notify an external application whenever specific events occur in your Clerk account.\n\nBy integrating ngrok with Clerk, you can:\n\n- **Develop and test Clerk webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Clerk** in real-time via the inspection UI and API.\n- **Modify and Replay Clerk Webhook requests** with a single click and without spending time reproducing events manually in your Clerk account.\n- **Secure your app with Clerk validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Clerk).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Clerk \n\nTo register a webhook on your Clerk account follow the instructions below:\n\n1. Access the [Clerk Dashboard](https://dashboard.clerk.com/sign-in) and sign in using your Clerk account.\n\n1. On the **Applications** page, click your application and then click **Webhook** on the left menu.\n   **Tip**: If you don`t have an application click **Add application** to create one.\n\n1. On the **Webhooks** page, click **Add Endpoint** and then enter the URL provided by the ngrok agent to expose your application to the internet in the **Endpoint URL** field (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![Clerk Endpoint URL](img/ngrok_url_configuration_clerk.png)\n\n1. In the **Message Filtering** section, select **user.created**, **user.deleted**, and **user.updated** under **Filter events**.\n\n1. Click **Create**.\n\n1. On the **Endpoints** page, click the **Testing** tab, select **user.created** in the **Send event** field, and then click **Send Example**.\n\n   Confirm your localhost app receives the event notification and logs both headers and body in the terminal.\n\n### Run Webhooks with Clerk and ngrok\n\nClerk sends different request body contents depending on the event that is being triggered.\nYou can trigger new calls from Clerk to your application by following the instructions below.\n\n1. On the left menu of the [Clerk Dashboard](https://dashboard.clerk.com/sign-in), click **+Users** and then click **CREATE**.\n\n1. On the **Create User** popup, enter an email and a password for the user and then click **CREATE**.\n\n   Confirm your localhost app receives the event notification and logs both headers and body in the terminal.\n\nAlternatively, you can verify the log of the webhook call in Clerk:\n\n1. On the left menu of the [Clerk Dashboard](https://dashboard.clerk.com/sign-in), click **+Webhooks** and then click the **Logs** tab.\n   ![Webhook Logs](img/ngrok_logs_clerk.png)\n\n1. Click one of the messages to see its details.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Clerk webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Access the [Clerk Dashboard](https://dashboard.clerk.com/sign-in), click **Webhooks** on the left menu, and then click your endpoint in the list of endpoints.\n\n1. On the **Endpoint** page, click the eye icon under **Signing Secret** and copy the value that appears.\n\n1. Create a traffic policy file named `clerk_policy.yml`, replacing `{endpoint signing secret}` with the value you copied before:\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: clerk\n             secret: \"{endpoint signing secret}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file clerk_policy.yml\n   ```\n\n1. Click **Users** on the left menu and then create a new user.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "Clerk Webhooks"
			}
		  ],
		  "metadata": {
			"name": "clerk",
			"description": "",
			"excerpt": "",
			"title": "Clerk"
		  }
		},
		{
		  "name": "coinbase",
		  "path": "/integrations/coinbase",
		  "docs": [
			{
			  "path": "/integrations/coinbase/webhooks",
			  "frontMatter": {
				"description": "Develop and test Coinbase webhooks from localhost",
				"title": "Coinbase Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Coinbase webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Coinbase webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Coinbase by using Webhooks.\nCoinbase webhooks can be used to notify an external application whenever specific events occur in your Coinbase account.\n\nBy integrating ngrok with Coinbase, you can:\n\n- **Develop and test Coinbase webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Coinbase** in real-time via the inspection UI and API.\n- **Modify and Replay Coinbase Webhook requests** with a single click and without spending time reproducing events manually in your Coinbase account.\n- **Secure your app with Coinbase validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Coinbase).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Coinbase \n\nTo register a webhook on your Coinbase account follow the instructions below:\n\n1. Access the [Coinbase homepage](https://www.coinbase.com/) and sign in using your Coinbase account.\n\n1. On the **Home** page, click your avatar icon on the top right corner of the page and then click **Settings**.\n\n1. On the **Settings** page, click the **API** tab and then click **New API Key**.\n\n1. On the **New API Key** popup, click **all** under the **Accounts** section, click **Select all** under the **Permissions** section, and enter the URL provided by the ngrok agent to expose your application to the internet in the **Notification URL** field (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![coinbase URL to Publish](img/ngrok_url_configuration_coinbase.png)\n\n1. Cilck **Create**, and then copy the value of the **API Key** and **API Secret** that appear on the **API Key details** popup.\n\n### Run Webhooks with Coinbase and ngrok\n\nCoinbase sends different request body contents depending on the event that is being triggered.\nYou can trigger new calls from Coinbase to your application by following the instructions below.\n\n1. Access the [Coinbase homepage](https://www.coinbase.com/), sign in using your Coinbase account, and then click **Trade** on the left menu.\n\n1. On the **Trade** page, click **Simple** on the top menu, and then click **Buy** to buy one of the assets that appear on the screen.\n\n1. On the **Buy** popup, enter the monetary amount, click **Preview Buy**, and then click **Buy now**.\n\n   Confirm your localhost app receives the create-project event notification and logs both headers and body in the terminal.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Coinbase webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Create a traffic policy file named `coinbase_policy.yml`:\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: coinbase\n             secret: {your api secret}\n   ```\n\n   **Note**: Replace `{your api secret}` with the value you copied during the webhook registration.\n\n1. Restart your ngrok agent by running the following command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file coinbase_policy.yml\n   ```\n\n1. Access [Coinbase](https://www.coinbase.com/) and buy an asset.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "Coinbase Webhooks"
			}
		  ],
		  "metadata": {
			"name": "coinbase",
			"description": "",
			"excerpt": "",
			"title": "Coinbase"
		  }
		},
		{
		  "name": "consul",
		  "path": "/integrations/consul",
		  "docs": [
			{
			  "path": "/integrations/consul/k8s",
			  "frontMatter": {
				"title": "Kubernetes ingress to services in a Consul service mesh",
				"description": "Setup a local Consul Service mesh to demonstrate how to use the ngrok Kubernetes Operator with Consul."
			  },
			  "content": "\nThe [ngrok Kubernetes Operator](https://github.com/ngrok/ngrok-operator) is our official open-source controller for adding public and secure ingress traffic to your k8s services. It works on any cloud, local, or on-prem Kubernetes cluster to provide ingress to your services no matter the network configuration, as long as it has outbound access to the ngrok service. This allows ngrok to be portable and work seamlessly across any type of infrastructure.\n\n[Consul](https://www.consul.io/) is a secure and resilient service mesh that provides service discovery, configuration, and segmentation functionality. Consul Connect provides service-to-service connection authorization and encryption using mutual TLS, automatically enabling TLS for all Connect services. Consul can be used with Kubernetes to provide a service mesh for your Kubernetes cluster.\n\nTogether, Consul provides a robust and secure way for Services within a cluster to communicate, while ngrok can seamlessly and securely provide public ingress to those services. This guide will walk you through setting up a Consul Service Mesh on Kubernetes and then using the ngrok Kubernetes Operator to provide ingress to your services to illustrate how they can work together.\n\n## What you'll need\n\n- A remote or local Kubernetes cluster with Consul installed _OR_ [minikube](https://minikube.sigs.k8s.io/docs/start/) to set up a demo cluster locally.\n- An [ngrok account](https://ngrok.com/signup).\n- [kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl/) and [Helm\n  3.0.0+](https://helm.sh/docs/intro/install/) installed on your local\n  workstation.\n- A reserved domain, which you can get in the ngrok\n  [dashboard](https://dashboard.ngrok.com/domains) or with the [ngrok\n  API](/api/resources/reserved-domains/).\n  - You can choose from an ngrok subdomain or bring your own custom branded\n    domain, like `https://api.example.com`.\n  - We'll refer to this domain as `<NGROK_DOMAIN>`.\n\n## Set up a local Consul Service Mesh on Kubernetes \n\nFor this guide, we'll need access to a remote or local Kubernetes cluster with Consul installed. If you have an existing cluster with Consul set up, you can skip this step and proceed to [Step 2: Install the ngrok Kubernetes Operator](#install-the-ngrok-ingress-controller).\n\nIf you don't have one set up, we'll set up a local Minikube cluster and install Consul now.\n\n1. Create a local cluster with minikube\n\n```bash\nminikube start --profile dc1 --memory 4096 --kubernetes-version=v1.22.0\n```\n\n1. Create a file called `values.yaml` with the following contents:\n\n```yaml\n# Contains values that affect multiple components of the chart.\nglobal:\n  # The main enabled/disabled setting.\n  # If true, servers, clients, Consul DNS and the Consul UI will be enabled.\n  enabled: true\n  # The prefix used for all resources created in the Helm chart.\n  name: consul\n  # The name of the data center that the agents should register as.\n  data center: dc1\n  # Enables TLS across the cluster to verify authenticity of the Consul servers and clients.\n  tls:\n    enabled: true\n  # Enables ACLs across the cluster to secure access to data and APIs.\n  acls:\n    # If true, automatically manage ACL tokens and policies for all Consul components.\n    manageSystemACLs: true\n# Configures values that configure the Consul server cluster.\nserver:\n  enabled: true\n  # The number of server agents to run. This determines the fault tolerance of the cluster.\n  replicas: 1\n# Contains values that configure the Consul UI.\nui:\n  enabled: true\n  # Registers a Kubernetes Service for the Consul UI as a NodePort.\n  service:\n    type: NodePort\n# Configures and installs the automatic Consul Connect sidecar injector.\nconnectInject:\n  enabled: true\n```\n\n1. Install the Consul Helm chart\n\n```bash\nhelm repo add hashicorp https://helm.releases.hashicorp.com\n\nhelm install --values values.yaml consul hashicorp/consul --create-namespace --namespace consul --version \"1.0.0\"\n```\n<Tip>\n**Depending on your computer, this can take some time for the pods to become healthy. You can watch the status of the pods with `kubectl get pods --namespace consul -w`**\n</Tip>\n\n1. Verify Consul is installed and all its pods are healthy\n\n```bash\nkubectl get pods --namespace consul\nNAME                                           READY   STATUS    RESTARTS        AGE\nconsul-connect-injector-6f67d58f8d-2lw6l       1/1     Running   0               17m\nconsul-server-0                                1/1     Running   0               17m\nconsul-webhook-cert-manager-5bb6f965c8-pjqms   1/1     Running   0               17m\n```\n\nWe now have a Kubernetes cluster with a Consul service mesh installed.\n<Note>\n**These steps are based on Consul's Tutorial [Consul Service Discovery and Service Mesh on Minikube](https://developer.hashicorp.com/consul/tutorials/kubernetes/kubernetes-minikube)**\n</Note>\n\n## Configure the ngrok Kubernetes Operator \n\nConsul requires a bit of extra configruation to work with ngrok's Operator for\nKubernetes ingress. You'll need to use a pod annotation to enable the Consul\nConnect sidecar injector. This will allow us to use Consul Connect to secure the\ntraffic between the ngrok Kubernetes Operator and our services.\n\n1.  First, create a Kubernetes Service for the ngrok Kubernetes Operator. Consul relies on this to name our services to declare Service Intention `source` and `destination` values. We'll create a Kubernetes Service for the ngrok Kubernetes Operator in the `consul` namespace.\n\n    ```yaml\n    apiVersion: v1\n    kind: Service\n    metadata:\n      name: ngrok-operator\n      namespace: consul\n    spec:\n      ports:\n        - name: http\n          port: 80\n          protocol: TCP\n          targetPort: 80\n      selector:\n        app.kubernetes.io/name: ngrok-operator\n    ```\n\n1.  Install the ngrok Kubernetes Operator\n\n    Next, install the ngrok Kubernetes Operator into our cluster. We want the controller pods to be in the Consul service mesh in order to proxy traffic to our other services. We'll use pod annotations to enable the Consul Connect sidecar injector and allow outbound traffic to use the Consul mesh. Consul documents how to set these 2 annotations in the [Configure Operators for Consul on Kubernetes](https://developer.hashicorp.com/consul/docs/k8s/connect/ingress-controllers) doc.\n\n    ```yaml\n    # This annotation is required to enable the Consul Connect sidecar injector\n    consul.hashicorp.com/connect-inject: \"true\"\n    # This is the CIDR of your Kubernetes API: `kubectl get svc kubernetes --output jsonpath='{.spec.clusterIP}'\n    consul.hashicorp.com/transparent-proxy-exclude-outbound-cidrs: \"10.96.0.1/32\"\n    ```\n\n    Check out our [Operator installation doc](/k8s/installation/helm/) for details on how to use Helm to install with your ngrok credentials. Once you've done that, you can run the command below to set the appropriate annotations.\n\n    ```bash\n    helm install ngrok-operator ngrok/ngrok-operator \\\n      --reuse-values\n      --set-string podAnnotations.consul\\\\.hashicorp\\\\.com/connect-inject=true \\\n    \t--set podAnnotations.\"consul\\.hashicorp\\.com/transparent-proxy-exclude-outbound-cidrs\"=\"YOUR KUBERNETES API CIDR\"\n    ```\n<Note>\n**- HashiCorp's docs also mention the annotation `consul.hashicorp.com/transparent-proxy-exclude-inbound-ports`. This is not applicable to the ngrok Kubernetes Operator as we create an outbound connection for Ingress rather than exposing ports.**\n\n\n- The `--set-string` flag allows the pod annotation to escape the `.` character in the annotation name while ensuring the value `true` is a boolean and not a string.\n- In a production environment, or anywhere you wish to use Infrastructure as Code and source control your Helm configurations, you can set up your credentials following this [guide](https://github.com/ngrok/ngrok-operator/blob/main/docs/deployment-guide/credentials.md).\n</Note>\n\n## Install a Sample Application \n\nNow let's install a sample application to try out our service mesh and Operator combination. We'll use the [HashiCups Demo Application](https://github.com/hashicorp-demoapp) HashiCorp uses for demos and guides such as in their [Getting Started with Consul Service Mesh for Kubernetes](https://developer.hashicorp.com/consul/tutorials/kubernetes-features/service-mesh-deploy) guide. This application is a simple e-commerce application that allows users to order coffee cups.\nThe application has a `frontend` and public API services that are also backed by a private API and database. These communicate with each other through the Consul service mesh. This comes with nginx installed as a proxy for the `frontend` and Public API services. We'll replace this with ngrok to provide public access and other features.\n<Tip>\n**For this demo, everything will be installed in the `consul` namespace.**\n\n\n\nThe ngrok Kubernetes Operator can send traffic to services across different namespaces, but [Consul Service Intentions](https://developer.hashicorp.com/consul/docs/connect/config-entries/service-intentions) across namespaces [require an enterprise account](https://developer.hashicorp.com/consul/docs/connect/config-entries/service-intentions#sources-namespace). For now, we'll keep everything in the same namespace.\n</Tip>\n\n1. Clone the [HashiCorp Learning Consul repo](https://github.com/hashicorp/learn-consul-kubernetes). This has multiple great example applications for learning about Consul and Kubernetes. We'll use the HashiCups application for this guide.\n\n```bash\ngit clone https://github.com/hashicorp/learn-consul-kubernetes\n```\n\n1. Install the HashiCups sample app in the `consul` namespace. This app consists of multiple Services and Deployments that make a tiered application. We'll install all of them from this folder and then modify things from there.\n\n```bash\nkubectl apply -f learn-consul-kubernetes/service-mesh/deploy/hashicups -n consul\n```\n\n1. Remove the existing [Service Intentions](https://developer.hashicorp.com/consul/docs/connect/config-entries/service-intentions) for the `public-api` and `frontend` services and add our own.\n\nConsul has the concept of [Service Intentions](https://developer.hashicorp.com/consul/docs/connect/config-entries/service-intentions). In short, they are a programmatic way to configure the Consul Service mesh to allow or deny traffic between services.\n\nHashiCups comes with `nginx` installed with intentions to the `frontend` and `public-api` services. We'll remove these and add our own intentions to allow traffic from the ngrok Kubernetes Operator to the `frontend` and `public-api` services.\n\n```bash\nkubectl delete serviceintentions public-api -n consul\nkubectl delete serviceintentions frontend -n consul\n```\n\n1. Create Service Intention from ngrok to HashiCups and the public-api\n\n```yaml\napiVersion: consul.hashicorp.com/v1alpha1\nkind: ServiceIntentions\nmetadata:\n  name: ngrok-consul-frontend\n  namespace: consul\nspec:\n  destination:\n    name: frontend\n  sources:\n    - action: allow\n      name: ngrok-operator\n```\n\n```yaml\napiVersion: consul.hashicorp.com/v1alpha1\nkind: ServiceIntentions\nmetadata:\n  name: ngrok-consul-api\n  namespace: consul\nspec:\n  sources:\n    - name: frontend\n      action: allow\n    - name: ngrok-operator\n      action: allow\n  destination:\n    name: public-api\n```\n\n## Configure Public Ingress for the sample application \n\nNow that the ngrok Kubernetes Operator can communicate with the `frontend` service and `public-api` service through the Consul Service Mesh via Service Intentions, we can create an ingress to route traffic to the app. We'll create ingress objects to route traffic to the `frontend` service and the `public-api` service.\n\n```yaml\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: ingress-consul\n  namespace: consul\nspec:\n  ingressClassName: ngrok\n  rules:\n    - host: <NGROK_DOMAIN>\n      http:\n        paths:\n          - path: /\n            pathType: Prefix\n            backend:\n              service:\n                name: frontend\n                port:\n                  number: 3000\n          - path: /api\n            pathType: Prefix\n            backend:\n              service:\n                name: public-api\n                port:\n                  number: 8080\n```\n<Tip>\n**This ingress object:**\n\n\n\n- Uses the `ngrok` ingress class\n- The host is the ngrok domain name you selected that is static\n- There is a route for `/` that routes to the `frontend` service on port `3000`\n- There is a route for `/api` that routes to the `public-api` service on port `8080`\n</Tip>\n\nOpen your `<NGROK_DOMAIN>` domain in your browser and see the HashiCups application!\n\n![HashiCups App](./img/hashicups.png)\n\n## Add OAuth Protection to the App \n\nLet's take your ingress needs a little further by assuming you want to add edge security, in the form of Google OAuth,\nto the endpoint where your 2048 application is humming along.\n\nWith our [Traffic Policy system](/traffic-policy/) and the [`oauth`\naction](/traffic-policy/actions/oauth), ngrok manages OAuth protection\nentirely at the ngrok cloud service, which means you don't need to add any\nadditional services to your cluster, or alter routes, to ensure ngrok's edge\nauthenticates and authorizes all requests before allowing ingress and access to\nyour endpoint.\n\nTo enable the `oauth` action, you'll create a new `NgrokTrafficPolicy` custom\nresource and apply it to your entire `Ingress` with an annotation. You can also\napply the policy to just a specific backend or as the default backend for an\n`Ingress`—see our doc on using the [Operator with\nIngresses](/k8s/guides/using-ingresses/#using-ngroktrafficpolicy-with-ingress).\n\n1. Edit your existing ingress configuration with the following—note the new `annotations` field and\n   the `NgrokTrafficPolicy` CR.\n\n   ```yaml\n    apiVersion: networking.k8s.io/v1\n    kind: Ingress\n    metadata:\n      name: ingress-consul\n      namespace: consul\n   \t annotations:\n       k8s.ngrok.com/traffic-policy: oauth\n    spec:\n      ingressClassName: ngrok\n      rules:\n        - host: <NGROK_DOMAIN>\n          http:\n            paths:\n              - path: /\n                pathType: Prefix\n                backend:\n                  service:\n                    name: frontend\n                    port:\n                      number: 3000\n              - path: /api\n                pathType: Prefix\n                backend:\n                  service:\n                   name: public-api\n                    port:\n                      number: 8080\n   ---\n   # Traffic Policy configuration for OAuth\n   apiVersion: ngrok.k8s.ngrok.com/v1alpha1\n   kind: NgrokTrafficPolicy\n   metadata:\n     name: oauth\n     namespace: default\n   spec:\n     policy:\n   \t   on_http_request:\n   \t\t   - type: oauth\n   \t\t\t   config:\n   \t\t\t     provider: google\n   ```\n\n1. Re-apply your configuration.\n\n1. When you open your demo app again, you'll be asked to log in via Google.\n   That's a start, but what if you want to authenticate only yourself or colleagues?\n\n1. You can use [expressions](/traffic-policy/concepts/expressions) and [CEL\n   interpolation](/traffic-policy/concepts/cel-interpolation) to filter out\n   and reject OAuth logins that don't contain `example.com`. Update the\n   `NgrokTrafficPolicy` portion of your manifest after changing `example.com` to\n   your domain.\n\n   ```yaml\n    # Traffic Policy configuration for OAuth\n    apiVersion: ngrok.k8s.ngrok.com/v1alpha1\n    kind: NgrokTrafficPolicy\n    metadata:\n      name: oauth\n      namespace: default\n    spec:\n      policy:\n        on_http_request:\n          - type: oauth\n            config:\n              provider: google\n          - expressions:\n              - \"!actions.ngrok.oauth.identity.email.endsWith('@example.com')\"\n            actions:\n              - type: custom-response\n                config:\n                  body: Hey, no auth for you ${actions.ngrok.oauth.identity.name}!\n                  status_code: 400\n   ```\n\n1. Check out your deployed HashiCups app once again. If you log in with an email that\n   doesn't match your domain, ngrok rejects your request. Authentication... done!\n\nNow only you can order from HashiCups from anywhere!\n",
			  "contentTitle": "Kubernetes ingress to services in a Consul service mesh"
			}
		  ],
		  "metadata": {
			"name": "consul",
			"description": "",
			"excerpt": "",
			"title": "Consul"
		  }
		},
		{
		  "name": "contentful",
		  "path": "/integrations/contentful",
		  "docs": [
			{
			  "path": "/integrations/contentful/webhooks",
			  "frontMatter": {
				"title": "Contentful Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Contentful webhooks with ngrok:\n\n1. [Launch your local app that will process Contentful webhook requests](#start-your-app) `npm start`\n1. [Launch ngrok](#start-ngrok) `ngrok http 3000`\n1. [Configure Contentful webhooks with your ngrok URL](#setup-webhook)\n</Tip>\n\nThis guide covers how to use ngrok to route Contentful Webhooks to your localhost app for development and integration testing.\nContentful webhooks can be used to notify an external application whenever specific events occur in your Contentful account.\n\nBy integrating ngrok with Contentful, you can:\n\n- **Develop and test Contentful webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Contentful** in real-time via the inspection UI and API.\n- **Modify and Replay Contentful webhook requests** with a single click and without spending time reproducing events manually in your Contentful account.\n- **Verify signed Contentful webhook requests** at the edge using ngrok's traffic policy with webhook verification\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n   Or with Contentful [Webhook Request Verification](https://www.contentful.com/developers/docs/webhooks/request-verification/) enabled:\n   1. Create a traffic policy file named `contentful_policy.yml`:\n\n      ```yaml\n      on_http_request:\n        - actions:\n            - type: verify-webhook\n              config:\n                provider: contentful\n                secret: \"<webhook signing secret>\"\n      ```\n\n   1. Start ngrok with traffic policy:\n\n      ```bash\n      ngrok http 3000 --traffic-policy-file contentful_policy.yml\n      ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Contentful).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Contentful \n\nTo register a webhook on your Contentful account follow the instructions below:\n\n1. Access the [Contentful site](https://contentful.com/) and sign in using your Contentful account.\n\n1. On the home page, click **Settings** on the top meu, click **Webhooks**, and then click **Add Webhook**.\n\n1. On the **Webhook** page, enter a name in the **Name** field and enter the URL provided by the ngrok agent to expose your application to the internet in the **URL** field (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![URL to Publish](img/ngrok_url_configuration_contentful.png)\n\n1. Make sure the **Active** switch is selected and **Trigger for all events** is selected under the **Triggers** section.\n\n1. Select **application/json** as the **Content type** value and then click **Save**.\n\n### Run Webhooks with Contentful and ngrok\n\nContentful sends different request body contents depending on the event that is being triggered.\nYou can select specific triggering events during the webhook configuration.\n\nTo trigger Contentful calls to your application follow the instructions below:\n\n1. Access the [Contentful site](https://contentful.com/) and sign in using your Contentful account.\n\n1. On the home page, click **Media** on the top meu, click **Add Asset**, and then click **Single asset**.\n\n1. On the **Asset** page, drag and drop an image from your desktop to the **File** area, and then click **Publish**.\n\n   Confirm your localhost app receives two event notifications and logs both headers and body in the terminal.\n\nOptionally, you can verify the log of the webhook call in Contentful:\n\n1. On the home page the [Contentful site](https://contentful.com/), click **Settings** on the top meu, click **Webhooks**, click the name of your webhook, and then click the **Activity log** tab.\n\n   ![Webhook Logs](img/ngrok_logs_contentful.png)\n\n<InspectingRequests />\n\n<ReplayingRequests />\n",
			  "contentTitle": "Contentful Webhooks"
			}
		  ],
		  "metadata": {
			"name": "contentful",
			"description": "",
			"excerpt": "",
			"title": "Contentful"
		  }
		},
		{
		  "name": "curity",
		  "path": "/integrations/curity",
		  "docs": [
			{
			  "path": "/integrations/curity/sso-oidc",
			  "frontMatter": {
				"description": "Use Curity Identity Server to secure access to ngrok endpoints",
				"title": "Curity Identity Server (OpenID Connect)"
			  },
			  "content": "import Disclaimer from \"/snippets/integrations/_endpoint-sso-disclaimer.mdx\";\n\n<Disclaimer />\n<Tip>\n**TL;DR**\n\n\n\nTo secure access to ngrok with Curity Identity Server using OpenID Connect:\n\n1. [Configure Curity Identity Server](#configure-Curity-auth)\n1. [Configure ngrok](#configure-ngrok)\n1. [Test access to ngrok with Curity Identity Server](#test-sso)\n</Tip>\n\nThis article details how to configure Curity as the primary Identity Provider for ngrok tunnels.\nBy integrating Curity Identity Server with ngrok, you can:\n\n- **Restrict access to ngrok tunnels** to only users who authenticated via Curity\n- **Use Curity security policies, MFA authenticators** — including BankId, SITHS, and WebAuthn — **to control access to ngrok tunnels**.\n- **Use Curity's Dashboard to facilitate access to ngrok apps**.\n\n## Requirements\n\nTo configure ngrok tunnels with Curity, you must have:\n\n- an Curity account with administrative rights to create clients\n- an [ngrok Enterprise Account](https://ngrok.com/pricing) with an authtoken or admin access to configure edges with OpenID Connect.\n\n## Configuration Steps\n\nTo integrate ngrok with Curity Identity Server, you will need to:\n\n1. Configure Curity with the ngrok app\n1. Configure ngrok with the SSO settings provided by Curity\n\n## **Step 1**: Configure Curity Authentication \n\nThe Curity Identity Server provides an authenticator called `html-form` that is suitable for setting up a login with username and password. It uses a Credential Manager to verify the credentials, which in turn uses a data-source. There any many options for stronger authentication than username and password. A list of possible authentication methods is available [here](https://curity.io/product/authentication-service/ways-to-authenticate/).\n\n### Add Authentication\n\n1. #### Add an Authenticator\n   1. Navigate to Profiles > Authentication Service > Authenticators.\n   1. Click **New Authenticator** on the authenticator page and give it a name.\n   1. Select the `HTML-Form` Authenticator type in the grid of authenticators and click **Next**.\n   1. Under **HTML Form Settings**, select the `default-account-manager` as account manager and `default-credential-manager` as credential manager.\n      ![img/username-03.jpg](img/username-03.jpg)\n\n2. #### Commit the changes\n   1. Commit the changes via the **Changes** menu.\n\n      ![img/username-04.jpg](img/username-04.jpg)\n\n## **Step 2**: Configure Curity for OIDC \n\n### Add an openid client in Curity\n\n1. #### Add New Client\n   1. Navigate to **Profiles** > **Token Service** > **Clients** and click **+ New Client**.\n   1. Give the client an ID (eg. `www` for a website client) and click **Create**.\n\n2. #### Add Capabilities\n   1. Scroll down to the **Capabilities** section and click **Add capabilities**.\n   1. Select the **Code Flow** capability and click **Next**.\n\n      ![create-client-03.jpg](img/create-client-03.jpg)\n\n   1. Enter `http://localhost/callback` as a **Redirect URI** and click **Add**.\n      ![config-callback.jpg](img/config-callback.jpg)\n   1. Click **Next**.\n   1. On the **Client Authentication** screen, select **secret**.\n   1. Click **Generate** to generate a new secret.\n      ![config-client-authentication.jpg](img/config-client-authentication.jpg)\n      1. Copy the **secret** since it cannot be retrieved later again (but can be reset).\n   1. On the **User Authentication** screen, select the `HTML-form` authenticator created in **[Step 1](#configure-Curity-auth)**.\n   1. Click **Done**.\n   1. Scroll down on the newly created client page to **Scopes and Claims**.\n   1. Select `openid` from the list of scopes in the dropdown menu.\n      ![config-openid-scope.jpg](img/config-openid-scope.jpg)\n\n3. #### Expose the metadata url\n\n   ngrok makes a call to the `/.well-known/openid-configuration` endpoint at Curity to pull configuration data specific to your Authorization Server.\n   1. Navigate to **Profiles** > **Token Service** > **General** page.\n   1. Scroll down to the **OpenID Connect** section and enable the `Expose Metadata` toggle.\n      ![expose-metadata.png](img/expose-metadata.png)\n\n4. #### Commit the changes\n   1. Commit the changes via the **Changes** menu.\n\n      ![img/username-04.jpg](img/username-04.jpg)\n\n## **Step 3**: Configure ngrok \n\nngrok can leverage Curity Identity Server in two ways:\n\n- From the ngrok CLI (using the `--oidc` parameter)\n- From the ngrok dashboard\n\n### **Option 1**: ngrok CLI\n\n> **Note:** For this tutorial, we assume you have an app running locally (i.e., on localhost:3000) with the ngrok client installed.\n\n1. Launch a terminal\n1. Enter the following command to launch an ngrok tunnel with Curity Identity Server. Replace `<curity_url>` with your Curity issuer address (i.e., https://acme.com/oauth/v2/oauth-anonymous) and the `<curity_client_id>` and `<curity_client_secret>` with the respective values copied from the ngrok app registered at Curity:\n\n   ```bash\n   ngrok http 3000 --oidc <curity_url> \\\n   --oidc-client-id <curity_client_id> \\\n   --oidc-client-secret <curity_client_secret> \\\n   --url curity-sso-test.ngrok.dev\n   ```\n\n1. [Skip to **Step 4**: ](#test-sso) Test the integration\n\n### **Option 2**: ngrok Edge\n\nTo configure an edge with Curity:\n\n1. Go to dashboard.ngrok.com.\n1. Click **Universal Gateway** > **Edges**\n1. If you don't have an edge already set to add Curity Identity Server, create a test edge:\n   - Click **New Edge**\n   - Click **HTTPS Edge**\n   - Click the **pencil icon** next to \"no description\". Enter _Edge with Curity Identity Server_ as the edge name and click **Save**.\n1. On the edge settings, click **OIDC**.\n1. Click **Begin setup** and enter the following:\n\n   ![Curity config in ngrok](img/curity-1.png)\n   - **Issuer URL**: Your Curity issuer url (i.e. https://acme.com/oauth/v2/oauth-anonymous).\n   - **Client ID**: The name of the client from Curity\n   - **Client Secret**: The client secret copied from Curity\n\n1. Click **Save**.\n\n1. Launch a tunnel connected to your Curity edge:\n<Tip>\n**Note**\n\n\nFor this step, we assume you have an app running locally (i.e. on localhost:3000) with the ngrok client installed.\n</Tip>\n\n1.  Click **Start a tunnel**.\n1.  Click the **copy icon** next to the tunnel command.\n\n    ![tunnel config](img/curity-2.png)\n\n1.  Launch a tunnel:\n    - Launch a terminal\n    - Paste the command. Replace http://localhost:80 with your local web app address (i.e., http://localhost:3000)\n    - hit **Enter**. an ngrok tunnel associated to your edge configuration is launched.\n1.  To confirm that the tunnel is connected to your edge:\n    - Return to the ngrok dashboard\n    - Close the **Start a tunnel** and the **Tunnel group** tabs\n    - Refresh the test edge page. Under traffic, You will see the message _You have 1 tunnel online. Start additional tunnels to begin load balancing_\n\n    ![tunnel confirmed](img/curity-3.png)\n\n1.  In the test edge, copy the **endpoint URL**. (you will use this url to test the Curity Authentication)\n    ![tunnel url](img/curity-4.png)\n\n## **Step 4**: Test the integration \n\n1. In your browser, launch an incognito window.\n1. Access your ngrok tunnel (i.e., https://curity-sso-test.ngrok.app or using a copied URL).\n1. You should be prompted to log in with your Curity credentials.\n1. After login, you should be able to see your web app.\n",
			  "contentTitle": "Curity Identity Server (OpenID Connect)"
			}
		  ],
		  "metadata": {
			"name": "curity",
			"description": "",
			"excerpt": "",
			"title": "Curity"
		  }
		},
		{
		  "name": "datadog",
		  "path": "/integrations/datadog",
		  "docs": [
			{
			  "path": "/integrations/datadog/event-destination",
			  "frontMatter": {
				"title": "Send Network Logs from ngrok to Datadog",
				"description": "Send network traffic logs from ngrok to Datadog",
				"tags": [
				  "events",
				  "logs",
				  "datadog",
				  "event destinations"
				]
			  },
			  "content": "\n# Datadog Event Destination\n<Tip>\n**TL;DR**\n\n\n\nTo send ngrok events to Datadog:\n\n1. [Get prerequisite information](#prerequisites)\n1. [Create Log Export](#create-log-export)\n1. [Create Event Destination](#create-destination)\n</Tip>\n\nThis guide covers how to send ngrok events including network traffic logs into Datadog.\nYou may want to keep an audit log of configuration changes within your ngrok\naccount, record all traffic to your endpoints for active monitoring/troubleshooting, or\nyou may use Datadog as a SIEM and want to use it for security inspections.\n\nBy integrating ngrok with Datadog, you can:\n\n- **Quickly identify application issues** in real-time using ngrok Traffic Events in conjunction with Datadog ML based monitoring.\n- **Historically audit changes occurring within an account**. Be able to historically audit changes within an account.\n- **Visualize usage of your service** by using Datadog queries and analytic charts.\n- **Identify security issues** by using ngrok events and Datadog SIEM.\n\nngrok will send logs to the [Datadog Logs\nAPI](https://docs.datadoghq.com/api/latest/logs/#send-logs) and automatically compress\nthem with gzip. ngrok does not support the events or metrics APIs at this time.\n\n## **Step 1**: Get prequisite information: \n\n- Familiarize yourself with the ngrok [events](/obs/events/reference) and select the ones you want to send to Datadog\n- Verify which [Datadog site](https://docs.datadoghq.com/getting_started/site/#access-the-datadog-site) you are using\n- Accquire a Datadog API key. To either create or retrieve the API key, reference the following link [Datadog API documentation](https://docs.datadoghq.com/account_management/api-app-keys/#add-an-api-key-or-client-token).\n\n## **Step 2**: Create a Log Export \n\n1. Using a browser, go to the [ngrok dashboard](https://dashboard.ngrok.com) and navigate\n   to **Events Streams** under the **Traffic Observability** section on the left hand navigation and select **Create Subscription**.\n\n   ![ngrok log export](img/event_sub.png)\n\n2. Within the Log Exporting configuration, provide a description for the export and within the sources tab select **Add Source** to choose which events you would like to send to Datadog.\n\nOnce complete, select **Add Event Sources** to confirm your selections.\n\n![ngrok event sources](img/event_sources.png)\n\n## **Step 3**: Create Event Destination \n\nTo send the events to Datadog we'll need to assign an Event Destination to the Log Export.\n\n1. Within the Log Exporting configuration Destination Tab, select **Add Destination.**\n\n1. Choose Datadog as the target and fill in the correct information being mindful of **which Datadog site your data resides in**. Target, Region and API Key values are required, all other values are optional.\n   - **Service Name** will be added as a key-value pair to the event payload as **service:value**.<br></br>\n   - **DD Tags** values will be added as tags to the event data being sent to be utilized within Datadog.\n\n![ngrok event destination](img/event_destination.png)\n\n3. Once all required inputs have values, select **Send Test Event** and you should be presented with a Success message. Select **Done** and the Datadog Event Destination setup is complete.\n\n![ngrok event destination success](img/success.png)\n<Note>\n**TROUBLESHOOTING**\n\n\n\nIf instead of a Success message you receive a 403 error, double-check your API key and\nvalidate that you have selected the correct Datadog site.\n</Note>\n",
			  "contentTitle": "Send Network Logs from ngrok to Datadog"
			}
		  ],
		  "metadata": {
			"name": "datadog",
			"description": "",
			"excerpt": "",
			"title": "Datadog"
		  }
		},
		{
		  "name": "descope",
		  "path": "/integrations/descope",
		  "docs": [
			{
			  "path": "/integrations/descope/sso-oidc",
			  "frontMatter": {
				"title": "Descope Endpoint SSO (OpenID Connect)",
				"description": "Use Descope OIDC to secure access to ngrok endpoints"
			  },
			  "content": "\nimport Disclaimer from \"/snippets/integrations/_endpoint-sso-disclaimer.mdx\";\n\n<Disclaimer />\n<Tip>\n**TL;DR**\n\n\n\nTo secure access to your ngrok endpoints with Descope Single Sign-On (SSO) using OpenID Connect (OIDC):\n\n1. [Configure Descope SSO](#configure-Descope)\n1. [Configure ngrok](#configure-ngrok)\n1. [Test access to ngrok with Descope SSO](#test-sso)\n</Tip>\n\nThis article details how to configure Descope as the primary Identity Provider for your ngrok endpoints.\nBy integrating Descope SSO with ngrok, you can:\n\n- **Restrict access to ngrok endpoints** only to users authenticated via Descope\n- **Use Descope security policies and MFA authenticators**.\n- **Use the Descope Console to facilitate access to ngrok apps**.\n\n## Supported Features\n\nThe ngrok integration with Descope supports:\n\n- **SP-Initiated SSO**: In this mode, users access ngrok endpoints and are redirected to Descope for authentication.\n\n## Requirements\n\nTo configure ngrok endpoints with Descope, you must have:\n\n- A Descope account with administrative rights to a Descope Project\n- An ngrok enterprise account with an access token or admin access to configure edges with OpenID Connect.\n\n## Configuration Steps\n\nTo integrate ngrok with Descope SSO, you will need to:\n\n1. Configure Descope with the ngrok app\n1. Configure ngrok with the SSO settings provided by Descope\n\n## **Step 1**: Configure Descope \n\n### Add the ngrok App in Descope\n\n1. Open the [Descope Console](https://app.descope.com).\n\n1. On the left menu, click **Applications**, and then click **+ Application** in the top right corner.\n\n1. In the popup window, enter `ngrok` in the **Name** field, make sure that `OIDC` is selected under **Authentication protocol**, and then click **Create**.\n\n1. On the **ngrok** application page, make a note of the **Issuer** URL.\n\n1. **Optional** if you wish to change the [Auth Hosting URL](https://docs.descope.com/knowledgebase/general/authhostingapp/#usage), to use a different flow for ngrok SSO you can change that on this page, and click **Save**.\n\n### Create a Client Secret in Descope\n\n1. Go to [Access Keys](https://app.descope.com/accesskeys) in the Descope Console.\n\n1. Click **+ Access Key** in the top right corner.\n\n1. In the popup window, enter `ngrok` in the **Name** field, change the **Expiration** time to whatever you prefer, and then click **Generate Key**.\n\n1. Once the **Access Key** has been created, make a note of it for later.\n\n## **Step 2**: Configure ngrok \n\nngrok can leverage Descope SSO in two ways:\n\n- From the ngrok CLI (using the `--oidc` parameter)\n- From the ngrok dashboard\n\n### **Option 1**: ngrok CLI\n\n> **Note:** For this tutorial, we assume you have an app running locally (i.e., on localhost:3000) with the ngrok client installed.\n\n1. Launch a terminal\n\n1. Enter the following command to launch an ngrok tunnel with Descope SSO:\n\n   ```bash\n   ngrok http 3000 --oidc=DESCOPE_ISSUER_URL \\\n   --oidc-client-id=DESCOPE_CLIENT_ID \\\n   --oidc-client-secret=DESCOPE_CLIENT_SECRET \\\n   ```\n\n   **Note**: Replace the following with values:\n   - `DESCOPE_ISSUER_URL`: This is your Issuer URL that you copied from the **Applications** page earlier.\n   - `DESCOPE_CLIENT_ID`: This is your Descope Project ID, which can be found under [Project Settings](https://app.descope.com/settings/project).\n   - `DESCOPE_CLIENT_SECRET`: The is the Descope Access Key that you created from earlier.\n\n   Alternatively, add the `--url YOUR_DOMAIN` argument to get your custom URL, replacing `YOUR_DOMAIN` with your URL of preference.\n\n1. Copy the URL available next to **Forwarding** (for example, `https://descope-sso-test.ngrok.app`).\n\n1. Skip to **Step 3**\n\n### **Option 2**: ngrok Edge\n\nTo configure an edge with Descope:\n\n1. Access the [ngrok Dashboard](https://dashboard.ngrok.com/) and sign in using your ngrok account.\n\n1. On the left menu, click **Universal Gateway** and then click **Edges**.\n\n1. If you don't have an edge already set to add Descope SSO, create a test edge:\n   - Click **+ New Edge**.\n   - Click **Create HTTPS Edge**.\n   - Click the **pencil icon** next to \"no description\", enter `Edge with Descope SSO OIDC` as the edge name, and click **Save**.\n\n1. On the edge settings menu, click **OIDC**.\n\n1. Click **Begin setup** and enter the following values into the fields:\n   ![Descope config in ngrok](img/descope-1.png)\n   - **Issuer URL**: This is your Issuer URL that you copied from the **Applications** page earlier.\n   - **Client ID**: The client id you copied from Descope.\n   - **Client Secret**: The client secret you copied from Descope.\n\n1. Click **Save** at the top, and then click the left arrow to go back to the **Edges** page.\n\n1. Launch a tunnel connected to your Descope edge:\n<Tip>\n**Note**\n\n\nFor this step, we assume you have an app running locally (i.e. on localhost:3000) with the ngrok client installed.\n</Tip>\n\n1.  Click **Start a tunnel**.\n\n1.  Click the **copy icon** next to the tunnel command.\n    ![tunnel config](img/descope-2.png)\n\n1.  Launch a tunnel:\n    - Launch a terminal.\n    - Paste the command but replace `http://localhost:80` with your localhost app address (i.e., `http://localhost:3000`).\n    - Click **Enter** and an ngrok tunnel associated with your edge configuration will launch.\n\n1.  To confirm that the tunnel is connected to your edge:\n    - Return to the ngrok dashboard\n    - Close the **Start a tunnel** and the **Tunnel group** tabs\n    - Refresh the test edge page. Under traffic, you will see the message _You have 1 tunnel online. Start additional tunnels to begin load balancing._\n      ![tunnel confirmed](img/descope-3.png)\n\n1.  In the test edge, copy the **endpoint URL**. (You use this URL to test the Descope Authentication)\n    ![tunnel url](img/descope-4.png)\n\n## Step 3: Test the integration \n\n1. In your browser, launch an incognito window.\n\n1. Access your ngrok endpoint (i.e., `https://descope-sso-test.ngrok.app` or using the copied URL).\n\n1. You should be prompted to log in with Descope.\n\n1. After logging in, you should be able to see your web app.\n",
			  "contentTitle": "Descope Endpoint SSO (OpenID Connect)"
			},
			{
			  "path": "/integrations/descope/sso-saml",
			  "frontMatter": {
				"description": "Use Descope SAML to secure access to ngrok endpoints",
				"title": "Descope SSO (SAML)"
			  },
			  "content": "import Disclaimer from \"/snippets/integrations/_endpoint-sso-disclaimer.mdx\";\n\n<Disclaimer />\n<Tip>\n**TL;DR**\n\n\n\nTo secure access to ngrok with Descope Single Sign-On using SAML:\n\n1. [Configure Descope SSO](#configure-descope)\n1. [Configure ngrok](#configure-ngrok)\n1. [Test access to ngrok with Descope SSO](#test-sso)\n</Tip>\n\nThis article details how to configure Descope as the primary Identity Provider for ngrok endpoints.\nBy integrating Descope SSO with ngrok, you can:\n\n- **Restrict access to ngrok endpoints** only to users authenticated via Descope\n- **Use Descope security policies and MFA authenticators**.\n- **Use the Descope Console to facilitate access to ngrok apps**.\n\n## Supported Features\n\nThe ngrok integration with Descope supports:\n\n- **SP-Initiated SSO**: In this mode, users access ngrok edges and tunnels and are redirected to Descope for authentication.\n\n## Requirements\n\nTo configure ngrok tunnels with Descope, you must have:\n\n- A Descope project with administrative rights and an Enterprise license to be able to create [SAML Applications](https://docs.descope.com/manage/idpapplications/saml/)\n- An [ngrok Enterprise Account](https://ngrok.com/pricing) with an authtoken or admin access to configure edges with SAML.\n\n## Configuration Steps\n\nTo integrate ngrok with Descope SSO, you will need to:\n\n1. Configure Descope with the ngrok app\n1. Configure ngrok with the SSO settings provided by Descope\n\n## **Step 1**: Fetch IdP Metadata \n\n### Add the ngrok App in Descope\n\n1. Open the [Descope Console](https://app.descope.com).\n\n1. On the left menu, click **Applications**, and then click **+ Application** in the top right corner.\n\n1. In the popup window, enter `ngrok` in the **Name** field, make sure that `SAML` is selected under **Authentication protocol**, and then click **Create**.\n\n1. On the **ngrok** application page, click on the download button next to **Descope Metadata (XML)** to download the Metadata file that you'll need later on. Make sure to leave this page open.\n\n1. **Optional**: if you wish to change the [Auth Hosting URL](https://docs.descope.com/knowledgebase/general/authhostingapp/#usage), to use a different flow for ngrok SSO you can change that on this page, and click **Save**.\n\n### **Step 2**: Configure ngrok \n\nTo configure an edge with Descope:\n\n1. Access the [ngrok Dashboard](https://dashboard.ngrok.com/) and sign in using your ngrok account.\n\n1. On the left menu, click **Universal Gateway** and then click **Edges**.\n\n1. If you don't have an edge already set to add Descope SSO, create a test edge:\n   - Click **+ New Edge**.\n   - Click **Create HTTPS Edge**.\n   - Click the **pencil icon** next to \"no description\", enter `Descope SSO SAML` as the edge name, and click **Save**.\n\n1. On the edge settings menu, click **SAML**.\n\n1. On the **SAML** page, click **Begin setup**, click **Upload XML**, and then open the XML metadata file you downloaded from Descope (See [Fetch IdP Metadata](#idp-metadata)).\n   ![Descope config in ngrok](img/descope-5.png)\n\n1. **Optional**: If you wish to enable IdP-initiated SSO, so that you can sign in directly from the Descope IdP-initiated SSO URL instead of from ngrok, you can check this box.\n   ![IdP initiated sso enabled](img/descope-6.png)\n\n1. Click **Save** at the top.\n\n1. Copy both the **Entity ID** and the **ACS URL** values for later use.\n\n### **Step 3**: Configure Descope \n\n1. Back in the Descope Console, under your **ngrok** application, select **Enter the connection details manually** under **Service Provider (SP)**.\n\n1. Enter the following values in the input fields and save the configuration.\n   ![SP configuration in Descope](img/descope-7.png)\n\n   **Note**: Replace the following with the values copied on previous steps:\n   - `NGROK_ACS_URL`: The value of the ngrok **Entity ID** copied from the edge SAML configuration.\n   - `NGROK_ENTITY_ID_URL`: The value of the ngrok **ACS URL** copied from the edge SAML configuration.\n\n### **Step 5**: Start a Tunnel \n\n1. Access the [ngrok edges page](https://dashboard.ngrok.com/edges), click your edge, and then click **Start a tunnel**.\n<Tip>\n**Note**\n\n\nFor this step, we assume you have an app running locally (i.e. on `localhost:3000`) with the ngrok client installed.\n</Tip>\n\n1. Click the **copy icon** next to the tunnel command.\n   ![tunnel config](img/descope-2.png)\n\n1. Launch a tunnel:\n   - Launch a terminal.\n   - Paste the command but replace `http://localhost:80` with your localhost app address (i.e., `http://localhost:3000`).\n   - Click **Enter** and an ngrok tunnel associated with your edge configuration will launch.\n\n1. To confirm that the tunnel is connected to your edge:\n   - Return to the ngrok dashboard\n   - Close the **Start a tunnel** and the **Tunnel group** tabs\n   - Refresh the test edge page. Under traffic, You will see the message _You have 1 tunnel online. Start additional tunnels to begin load balancing._\n     ![tunnel confirmed](img/descope-3.png)\n\n1. In the test edge, copy the **endpoint URL**. (you use this URL to test the Descope Authentication)\n   ![tunnel url](img/descope-4.png)\n\n## Test the integration \n\n1. In your browser, launch an incognito window.\n\n1. Access your ngrok endpoint (i.e., `https://descope-sso-test.ngrok.app` or use the copied URL).\n\n1. You should be prompted to log in with Descope.\n\n1. After logging in, you should be able to see your web app.\n",
			  "contentTitle": "Descope SSO (SAML)"
			}
		  ],
		  "metadata": {
			"name": "Descope",
			"description": "",
			"excerpt": "",
			"title": "Descope"
		  }
		},
		{
		  "name": "digitalocean",
		  "path": "/integrations/digitalocean",
		  "docs": [
			{
			  "path": "/integrations/digitalocean/gslb",
			  "frontMatter": {
				"description": "In this guide, you'll learn how to layer load balancing between three or more globally-distributed, cloud-based virtual machines in DigitalOcean.",
				"title": "Use ngrok's Global Server Load Balancing with DigitalOcean"
			  },
			  "content": "<Tip>\n**TL;DR**\n\n\n\nTo use ngrok's [Global Server Load Balancing](/universal-gateway/global-load-balancer/) with DigitalOcean:\n\n1. [Reserve your ngrok domain](#reserve-domain)\n2. [Create your ngrok Edge](#create-edge)\n3. [Create Tunnel Group backends for your VMs](#create-tunnel-group-backends)\n4. [Create a Weighted Backend and Route on your Edge](#create-weighted-backend)\n5. [Install the ngrok agent and an example workload on each VM](#install-ngrok-agent)\n6. [Test out ngrok's Global Server Load Balancing](#test-gslb)\n7. [(optional) Enable the Traffic Policy module for API gateway features](#enable-traffic-policy)\n</Tip>\n\nIn this guide, you'll learn how to layer ngrok's [Global Server Load Balancing](/universal-gateway/global-load-balancer/) (GSLB) on top of a VM-based deployment on DigitalOcean.\n\nGLSB improves the performance and resiliency for your apps by distributing traffic to the nearest Point of Prescence (PoP) and the upstream service. Unlike a traditional GSLB deployment, ngrok automatically routes traffic without requiring you to deploy new infrastructure, provision IPs, or change DNS records. All you have to do is configure your ngrok agents for a simple path to high availability, horizontal scaling, A/B testing, and more.\n\nngrok's GSLB even works on top of DigitalOcean's internal load balancers to provicde additional global resiliency and latency improvements.\n<Warning>\n**This how-to guide requires:**\n\n\n\n1. An [ngrok account](https://ngrok.com/signup).\n1. An account with [DigitalOcean](https://cloud.digitalocean.com/registrations/new).\n1. Three Ubuntu 24.04 virtual machines (VMs) in three globally-distributed regions (e.g. New York, Sydney, and Frankfurt):\n   - Hostnames should be unique, ideally using the location of the datacenter (e.g. `nyc`, `sydney`, and `frankfurt`).\n   - [Docker](https://docs.docker.com/engine/install/) and [Docker Compose](https://docs.docker.com/compose/install/) installed on each VM.\n</Warning>\n\n## **Step 1**: Reserve your ngrok domain \n\nYour first task is to [generate a new API key](https://dashboard.ngrok.com/api) in the ngrok dashboard. Make sure you save the API key before you close the modal, because it won't be displayed again.\n\nTo simplify authenticating your account with the ngrok API, export the API key on your local workstation.\n\n```bash\nexport NGROK_API_KEY=<YOUR-API-KEY>\n```\n\nNext, create a domain that is a subdomain of an [ngrok-managed domain](/universal-gateway/domains/). For an example deployment like this, `YOUR_COMPANY-digitalocean-gslb.ngrok.app` would work great.\n\nYou can reserve your domain in one of two ways: with the [ngrok API](/api/), or in the [ngrok dashboard](https://dashboard.ngrok.com/domains).\n\nWith the ngrok API, reserve your domain on the [`/reserved_domains` endpoint](/api/resources/reserved-domains/) using the `NGROK_API_KEY` and `NGROK_DOMAIN` variables you exported.\n\nExport a variable for your new domain, which will be used in following API calls.\n\n```bash\nexport NGROK_DOMAIN=<YOUR-NGROK-DOMAIN>\n```\n\n```bash\ncurl \\\n  -X POST https://api.ngrok.com/reserved_domains \\\n  -H \"Authorization: Bearer ${NGROK_API_KEY}\" \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Ngrok-Version: 2\" \\\n  -d '{\"description\":\"DigitalOcean Load Balancing\",\"domain\":\"'${NGROK_DOMAIN}'\"}'\n```\n<Tip>\n**Custom domains within ngrok**\n\n\n\nUsing CNAMEs, ngrok can host an endpoint on your domain while also managing the complete TLS certificate lifecycle on your behalf. If you'd prefer to use a custom domain rather than an ngrok-managed one, [follow our guide](/universal-gateway/custom-domains/) to set up your DNS and replace your custom domain in the `export` command above.\n</Tip>\n\n## **Step 2**: Create your ngrok Edge \n\nWith ngrok, you can manage multiple endpoints, such as domains or routes, using a single [Edge](/universal-gateway/edges/) configuration in the cloud. Edges let you update endpoints without taking them offline, connect multiple ngrok agents to a single endpoint, apply modules like [OAuth](/traffic-policy/actions/oauth/) or [IP restrictions](/traffic-policy/actions/restrict-ips/), and balance the load between your upstream services.\n\nSend a `POST` request to the [`/edges/https` endpoint](/api/resources/edges-https/), replacing the `description` field below as needed.\n\n```bash\ncurl \\\n  -X POST https://api.ngrok.com/edges/https \\\n  -H \"Authorization: Bearer ${NGROK_API_KEY}\" \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Ngrok-Version: 2\" \\\n  -d '{\"description\":\"DigitalOcean HTTPS Edge\",\"hostports\":[\"'${NGROK_DOMAIN}':443\"]}'\n```\n\nExport the `id` in this response, which begins with `edghts_...`, for future use.\n\n```bash\nexport EDGE_ID=edghts_...\n```\n\n## **Step 3**: Create Tunnel Group backends for your VMs \n\nNext, create a Tunnel Group for each of your globally-distributed VMs. A Tunnel Group uses one or more labels to identify which agent-created tunnels it should attach to a given Edge and route, which you'll create in a moment.\n\nYou'll need to run the API request to the [`/backends/tunnel_group` endpoint](/api/resources/tunnel-group-backends/) for **each** of your VMs, changing the `<LOCATION_NAME>` with the name of the city or region of the data center where they're deployed (e.g. `nyc`, `sydney`, and `frankfurt`).\n\n```bash\ncurl \\\n  -X POST https://api.ngrok.com/backends/tunnel_group \\\n  -H \"Authorization: Bearer ${NGROK_API_KEY}\" \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Ngrok-Version: 2\" \\\n  -d '{\"labels\":{\"dc\":\"<LOCATION_NAME>\"}}'\n```\n\nExport the `id`, beginning with `bkdtg_...`, returned from the ngrok API for each Tunnel Group you create.\n\n```bash\nexport BACKEND_ID_01=bkdtg_...\nexport BACKEND_ID_02=bkdtg_...\nexport BACKEND_ID_03=bkdtg_...\n```\n\n## **Step 4**: Create a Weighted Backend and Route on your Edge \n\nWith a [Weighted Backend](/universal-gateway/edges/#weighted), you can specify custom weights for Tunnel Group backends, shaping precisely how to load-balance traffic across the infrastructure you've distributed around the globe. Without a Weighted Backend, the ngrok Edge and [GSLB](/universal-gateway/global-load-balancer/) will always favor the Point of Presence (PoP) and VM nearest the user making requests.\n\nCreate a Weighted Backend at the [`/backends/weighted` endpoint](/api/resources/weighted-backends/) using your Tunnel Group backend `id`s exported from the previous step. The `curl` command below creates equal weighting for your backends, but you can use integers between `0-10000` to configure precise proportional weights.\n\n```bash\ncurl \\\n\t-X POST https://api.ngrok.com/backends/weighted \\\n\t-H \"Authorization: Bearer ${NGROK_API_KEY}\" \\\n\t-H \"Content-Type: application/json\" \\\n\t-H \"Ngrok-Version: 2\" \\\n\t-d '{\"backends\":{\"'${BACKEND_ID_01}'\":1,\"'${BACKEND_ID_02}'\":1,\"'${BACKEND_ID_03}'\":1}}'\n```\n\nExport the `id` of your new Weighted Backend.\n\n```bash\nexport WEIGHTED_BACKEND_ID=bkdwd_...\n```\n\nYou can now create a catch-all Edge Route at `/` using your Weighted Backend using the [`/edges/https/{EDGE_ID}/routes` endpoint](/api/resources/edges-https-routes/).\n\n```bash\ncurl \\\n  -X POST \"https://api.ngrok.com/edges/https/${EDGE_ID}/routes\" \\\n  -H \"Authorization: Bearer ${NGROK_API_KEY}\" \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Ngrok-Version: 2\" \\\n  -d '{\"match\":\"/\",\"match_type\":\"path_prefix\",\"backend\":{\"enabled\":true,\"backend_id\":\"'${WEIGHTED_BACKEND_ID}'\"}}'\n```\n\nIf you'd like to do optional step #7, you will need to export a variable for the route you just created:.\n\n```bash\nexport ROUTE_ID=edghtsrt_...\n```\n<Tip>\n**Make sure you grab the right id**\n\n\nThe command starts with two ID values (`edge_id` and `id`), be sure to use `id` with the value that starts with `edghtsrt`.\n</Tip>\n\nYou now have an active domain, Edge, Tunnel Group backends, a Weighted Backend, and a route. If you open a new tab and navigate to `https://<YOUR_NGROK_DOMAIN>` right now, you'll see an error message from ngrok. You've successfully reserved a domain and created an edge, but you don't yet have ngrok agents or active tunnels.\n\n![An example of an ngrok domain and Edge with no matching tunnels](img/edge-no-tunnels.png)\n\nYou can also navigate to the [Edges dashboard](https://dashboard.ngrok.com/edges) to see your Edge configuration on the domain you reserved with no online tunnels.\n\n![alt text](img/edge-dashboard-no-tunnels.png)\n\n## **Step 5**: Install the ngrok agent and an example workload on each VM \n\nTo get some tunnels online and quickly see how ngrok's GSLB works, you'll use an [example API deployment](https://github.com/joelhans/ngrok-vps-gslb-demo). This demo deployment has four parts:\n\n1. A straightforward Go-based API with a single endpoint at `/api`, which returns a randomly generated UUID and the machine's `hostname`, which should reflect the regions of your VMs.\n2. A `Dockerfile` for containerizing said Go-based API.\n3. A `docker-compose.yml` file for starting the API container and a containerized edition of the ngrok agent on the same network.\n4. A `ngrok.yml` [agent configuration file](/agent/config/v3/) to connect the agent to your ngrok account and one of the Tunnel Group backends you previously created.\n\nRepeat the following steps on **each** VM:\n\n1. Clone the demo repository.\n\n   ```bash\n   git clone https://github.com/joelhans/ngrok-vps-gslb-demo\n   cd ngrok-vps-gslb-demo\n   ```\n\n2. Edit the `ngrok.yml` [ngrok agent configuration file](/agent/config/) with your `<YOUR_NGROK_AUTHTOKEN>`, which you can find in the [ngrok dashboard](https://dashboard.ngrok.com/get-started/your-authtoken)&mdash;note that it's different from the API key you created in the first step. Next, edit the `<LOCATION_NAME>` for that VM, matching the labels you created in [step 3](#create-tunnel-group-backends) (e.g. `nyc`, `sydney`, and `frankfurt`).\n\n   ```yaml\n   version: 2\n   authtoken: <YOUR_NGROK_AUTHTOKEN>\n   log_level: debug\n   log: stdout\n   tunnels:\n     vps-demo:\n       addr: 5000\n       labels:\n         - dc=<LOCATION_NAME>\n   ```\n\n3. Build and start the containerized API deployment, passing the hostname of the VM to the hostname of the Docker container.\n\n   ```bash\n   HOSTNAME=$(hostname -f) docker compose up -d\n   ```\n\n## **Step 6**: Test out ngrok's Global Server Load Balancing \n\nngrok is now load-balancing your single API endpoint across all three distributed VMs.\n\nYou can now ping your demo API at `<YOUR_NGROK_DOMAIN>/api` to see which backend responds.\n\n```bash\ncurl ${NGROK_DOMAIN}/api\n[{\"id\":\"1cf26269-ce8b-4f16-91f1-fdf7bc6d9e80\",\"dc\":\"nyc\"}]\n```\n\nTo see the weighting in action, try a batch of `curl` requests.\n\n```bash\nfor i in `seq 1 20`; do \\\n  curl  \\\n    -X GET \"${NGROK_DOMAIN}/api\" ; \\\n  done\n```\n\nYou should see each VM respond with similar frequency:\n\n```json skip-validation\n[{\"id\":\"c46bdbd9-b588-4ffa-8018-d299d0918bbc\",\"dc\":\"sydney\"}]\n[{\"id\":\"dce5a46e-15af-4479-a073-8fbc7f0097c5\",\"dc\":\"nyc\"}]\n[{\"id\":\"ecc6451c-bc25-43bd-8cb6-a162f019adf3\",\"dc\":\"frankfurt\"}]\n[{\"id\":\"ecc6451c-bc25-43bd-8cb6-a162f019adf3\",\"dc\":\"frankfurt\"}]\n[{\"id\":\"ecc6451c-bc25-43bd-8cb6-a162f019adf3\",\"dc\":\"frankfurt\"}]\n[{\"id\":\"c46bdbd9-b588-4ffa-8018-d299d0918bbc\",\"dc\":\"sydney\"}]\n[{\"id\":\"c46bdbd9-b588-4ffa-8018-d299d0918bbc\",\"dc\":\"sydney\"}]\n[{\"id\":\"ecc6451c-bc25-43bd-8cb6-a162f019adf3\",\"dc\":\"frankfurt\"}]\n[{\"id\":\"ecc6451c-bc25-43bd-8cb6-a162f019adf3\",\"dc\":\"frankfurt\"}]\n[{\"id\":\"dce5a46e-15af-4479-a073-8fbc7f0097c5\",\"dc\":\"nyc\"}]\n[{\"id\":\"ecc6451c-bc25-43bd-8cb6-a162f019adf3\",\"dc\":\"frankfurt\"}]\n[{\"id\":\"dce5a46e-15af-4479-a073-8fbc7f0097c5\",\"dc\":\"nyc\"}]\n[{\"id\":\"dce5a46e-15af-4479-a073-8fbc7f0097c5\",\"dc\":\"nyc\"}]\n[{\"id\":\"c46bdbd9-b588-4ffa-8018-d299d0918bbc\",\"dc\":\"sydney\"}]\n[{\"id\":\"ecc6451c-bc25-43bd-8cb6-a162f019adf3\",\"dc\":\"frankfurt\"}]\n[{\"id\":\"c46bdbd9-b588-4ffa-8018-d299d0918bbc\",\"dc\":\"sydney\"}]\n[{\"id\":\"c46bdbd9-b588-4ffa-8018-d299d0918bbc\",\"dc\":\"sydney\"}]\n[{\"id\":\"dce5a46e-15af-4479-a073-8fbc7f0097c5\",\"dc\":\"nyc\"}]\n[{\"id\":\"ecc6451c-bc25-43bd-8cb6-a162f019adf3\",\"dc\":\"frankfurt\"}]\n[{\"id\":\"dce5a46e-15af-4479-a073-8fbc7f0097c5\",\"dc\":\"nyc\"}]\n```\n\nTo confirm your global load balancing, head over to the [Edges dashboard](https://dashboard.ngrok.com/edges) once again to confirm your tunnels are online and weighted equally at 33.33%.\n\n![The ngrok dashboard showing online, weighted tunnels](img/edge-weighted-active.png)\n\n## **Step 7** (optional): Enable the Traffic Policy module for API gateway features \n\nYour demo API is already globally load-balanced, but if you want to extend your ngrok usage even further, you can enable one or more [Traffic Policy modules](/traffic-policy/) on your Edge to control traffic or establish standards for how your upstream services are accessed.\n\nYou have two options:\n\n- Using `curl` with the ngrok API's [`/edges/https/{edge_id}/routes/{id}/policy` endpoint](/api/resources/edge-route-traffic-policy-module/). For this step, you will need to have exported the `ROUTE_ID` environment variable in step #4.\n\n  ```bash\n  curl \\\n    -X PUT \"https://api.ngrok.com/edges/https/${EDGE_ID}/routes/${ROUTE_ID}/policy\" \\\n    -H \"Authorization: Bearer ${NGROK_API_KEY}\" \\\n    -H \"Content-Type: application/json\" \\\n    -H \"Ngrok-Version: 2\" \\\n    -d '{\"enabled\":true,\"on_http_response\":[{\"actions\":[{\"type\":\"add-headers\",\"config\":{\"headers\": {\"is-ngrok\": \"1\",\"country\": \"${conn.client_ip.geo.location.country_code}\"}}}],\"name\":\"Add ngrok headers\"}]}'\n  ```\n\n- In the Traffic Policy module section of your [Edge](https://dashboard.ngrok.com/edges) in the ngrok dashboard, click the **Edit Traffic Policy** button and then the **YAML** button and add the YAML below.\n\n  ```yaml\n  on_http_request: []\n  on_http_response:\n    - expressions: []\n      name: Add ngrok headers\n      actions:\n        - type: add-headers\n          config:\n            headers:\n              country: ${conn.client_ip.geo.location.country_code}\n              is-ngrok: \"1\"\n  ```\n\nWhen you request your API again, the response includes the `country` (with the appropriate code for where you're generating said request) and `is-ngrok` headers.\n\n```bash\ncurl -s -I -X GET https://<YOUR_NGROK_DOMAIN>/api\n\nHTTP/2 200\ncontent-type: application/json\ncountry: US\ndate: Wed, 22 May 2024 14:53:42 GMT\nis-ngrok: 1\ncontent-length: 63\n```\n\n## What's next?\n\nYou now have a globally load-balanced API deployment using three DigitalOcean VMs, three ngrok agents, three secure tunnels, one ngrok Edge, and a single convenient endpoint for your users.\n\nFrom here, you have many options for extending your use of ngrok's GSLB:\n\n- Spread the load from user requests further by creating additional deployments in more regions, adding a new Tunnel Group backend for each, and [patching](/api/resources/weighted-backends/#update-weighted-backend) your Weighted Backend configuration.\n- Add more VMs to a region with existing deployments and add them to the relevant Tunnel Group backend. ngrok will then load-balance between those specific VMs equally _after_ weighting requests on the Backend level.\n- Provision a Kubernetes cluster with the same workload and the ngrok [Kubernetes Operator](/k8s/) to load-balance between VM- and Kubernetes-based deployments of the same API or application.\n- Use your Weighted Backend for A/B tests by changing your deployments between different regions and VMs.\n\nIf you're eager to learn more about ngrok's GSLB, give the following a read:\n\n- [Introducing Always-On Global Server Load Balancing](https://ngrok.com/blog-post/what-is-gslb-global-server-load-balancing)\n- [What is global server load balancing (GSLB)?](https://ngrok.com/blog-post/what-is-gslb-global-server-load-balancing)\n",
			  "contentTitle": "Use ngrok's Global Server Load Balancing with DigitalOcean"
			},
			{
			  "path": "/integrations/digitalocean/k8s",
			  "frontMatter": {
				"title": "Ingress to Kubernetes apps on clusters managed by DigitalOcean",
				"description": "Add Kubernetes ingress to any app running in a cluster managed by DigitalOcean using the ngrok Kubernetes Operator."
			  },
			  "content": "\nUsing this guide, you'll launch a new cluster on [DigitalOcean](https://digitalocean.com) and use the DigitalOcean Marketplace to provision the [ngrok Kubernetes Operator](https://marketplace.digitalocean.com/apps/ngrok-ingress-controller) to securely ingress public traffic to a demo app.\n\nIn the end, you'll have learned enough to deploy your next production-ready Kubernetes app with Rafay, with the ngrok Kubernetes Operator giving you access to additional features, like observability and resiliency, with no extra configuration complexity.\n\nHere is what you'll be building with:\n\n- **The [ngrok Kubernetes Operator](https://ngrok.com/blog-post/ngrok-k8s)**: ngrok's official controller for adding secure public ingress and middleware execution to your Kubernetes apps with ngrok's cloud service. With ngrok, you can manage and secure app traffic at every stage of the development lifecycle while benefiting from simpler configurations, security, and edge acceleration.\n- **DigitalOcean**: DigitalOcean is a cloud service provider focused on developers, startups, and small-to-midsize businesses. With reliable monthly rates for less than hyperscalers like AWS, DigitalOcean's Kubernetes solution is a great fit for internal development teams building or scaling up new platforms without massive infrastructure build-out or expense.\n\n## What you'll need\n\n- A [DigitalOcean account](https://cloud.digitalocean.com/registrations/new).\n- An [ngrok account](https://ngrok.com/signup).\n- [kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl/) and [Helm\n  3.0.0+](https://helm.sh/docs/intro/install/) installed on your local\n  workstation.\n- The [ngrok Kubernetes Operator](/k8s/) installed on\n  your cluster.\n- A reserved domain, which you can get in the ngrok\n  [dashboard](https://dashboard.ngrok.com/domains) or with the [ngrok\n  API](/api/resources/reserved-domains/).\n  - You can choose from an ngrok subdomain or bring your own custom branded\n    domain, like `https://api.example.com`.\n  - We'll refer to this domain as `<NGROK_DOMAIN>`.\n\n## Provision a new cluster on DigitalOcean with `doctl` \n\nIn this guide, we'll stick with the CLI as much as possible to showcase how tightly the ngrok Kubernetes Operator can integrate with DigitalOcean and how you might automate these steps in the future.\n\n1. With `doctl` installed remotely, scope out the node sizes/specs, which will directly affect your [monthly pricing](https://www.digitalocean.com/pricing/kubernetes), with the following:\n\n   ```bash\n   doctl kubernetes options sizes\n   ```\n\n1. Provision your cluster with the command below, replacing `NODE_SIZE` and `CLUSTER_NAME` with your chosen size and a relevant name.\n\n   ```bash\n   doctl kubernetes clusters create --size NODE_SIZE CLUSTER_NAME\n   ```\n\n   ```bash\n   ...\n   Notice: Successfully kicked off addon job.\n   ID                                      Name        Region    Version        Auto Upgrade    Status     Node Pools\n   d62a17ca-32e0-4d8b-9260-2d0d1c582939    ngrokker    nyc1      1.29.1-do.0    false           running    ngrokker-default-pool\n   ```\n\n1. Now you can install the ngrok Kubernetes Operator to provide ingress to our services.\n\n   Check out our [Operator installation doc](/k8s/installation/helm/) for details on how to use Helm to install with your ngrok credentials.\n\n   Your new Kubernetes cluster, managed by DigitalOcean, is all set up—and with the ngrok Kubernetes Operator installed with a single option on the CLI.\n\n## Deploy an example app on your DigitalOcean-managed cluster \n\nLet's explore how you can add apps or services to your DigitalOcean-managed Kubernetes cluster. DigitalOcean has a repository of [sample Kubernetes apps](https://github.com/digitalocean/kubernetes-sample-apps/tree/master/bookinfo-example), including the [Bookinfo](https://github.com/digitalocean/kubernetes-sample-apps/tree/master/bookinfo-example) app, which we'll use.\n\n1. Clone the repository to your local workstation and `cd` into the new directory:\n\n   ```bash\n   git clone https://github.com/digitalocean/kubernetes-sample-apps.git\n   cd kubernetes-sample-apps\n   ```\n\n1. Deploy the Bookinfo app to your cluster:\n\n   ```bash\n   kubectl apply -k bookinfo-example/kustomize\n   ```\n\n   You should see your cluster create a handful of new services, then verify everything is running correctly with `kubectl get all -n bookinfo`.\n\n## Configure the ngrok Kubernetes Operator \n\nYour Bookinfo app is running, but you have no means of accessing it from your local workstation—or anywhere else, for that matter. You _could_ use `kubectl port-forward...`, but that's a fragile method of accessing your new app, and isn't appropriate for production use.\n\nInstead, finish configuring the ngrok Kubernetes Operator to direct incoming requests directly to the container running the user-facing Bookinfo container. The [Bookinfo docs](https://github.com/digitalocean/kubernetes-sample-apps/tree/master/bookinfo-example) recommend port-forwarding to the `productpage` service, which runs on port `9080`—you can use that information to configure the ngrok Kubernetes Operator.\n\n1. Create a new file called `bookinfo-ingress.yaml` on your local workstation. This configuration defines how the ngrok Kubernetes Operator will route traffic arriving on `NGROK_DOMAIN` to the `store-front` service on port `80` as defined in the manifest.\n\n   <Tip>\n\n   Make sure you edit line `10` of the YAML below, which contains the `NGROK_DOMAIN` variable, with the ngrok domain you created earlier.\n\n   </Tip>\n\n   ```yaml showLineNumbers\n   ---\n   apiVersion: networking.k8s.io/v1\n   kind: Ingress\n   metadata:\n     name: bookinfo-ingress\n     namespace: bookinfo\n   spec:\n     ingressClassName: ngrok\n     rules:\n       - host: <NGROK_DOMAIN>\n         http:\n           paths:\n             - path: /\n               pathType: Prefix\n               backend:\n                 service:\n                   name: productpage\n                   port:\n                     number: 9080\n   ```\n\n1. Apply the new configuration to your cluster:\n\n   ```bash\n   kubectl apply -f ngrok_ingress.yaml\n   ```\n\n   <Tip>\n\n   **Note:** If you get an error when applying the manifest, double check that you've updated the `<NGROK_DOMAIN>` value and try again.\n\n   </Tip>\n\n1. Navigate to `https://<NGROK_DOMAIN>` in your browser to see your example Bookinfo app as managed, deployed, and publicly networked via DigitalOcean, Kubernetes, and ngrok! Click **Normal user** to see a little more—it's not much to look at, but it's a working Kubernetes app with functional, secure, and simple ingress with the ngrok Kubernetes Operator.\n\n   ![Successfully deployed Booklist app on DigitalOcean, Kubernetes, and ngrok](img/bookinfo-deployed.png)\n\n## Enable extra features of ngrok's cloud service \n\nTo demonstrate how ingress configuration and [OAuth support](/traffic-policy/actions/oauth/) work, you can quickly launch an open-source observability stack including [Prometheus](https://github.com/prometheus), [Grafana](https://github.com/grafana/grafana), and [Alertmanager](https://github.com/prometheus/alertmanager/) on your cluster.\n\n1. Head over to the [Kubernetes Clusters](https://cloud.digitalocean.com/kubernetes/clusters/) dashboard on the DigitalOcean console and click on the cluster you created previously.\n\n1. Click the **Marketplace** tab, find or search for **Kubernetes Monitoring Stack**, and click **Install**. Confirm your choice.\n\n   In the background, DigitalOcean uses Helm to create a new integrated deployment for Prometheus, Grafana, and Alertmanager.\n\n1. Create a new domain in the [ngrok dashboard](https://dashboard.ngrok.com/domains) at `monitoring.<NGROK_DOMAIN>`.\n\n1. Edit your `ngrok_ingress.yaml` file you created in the previous step to include the highlighted configuration at the bottom, which will route all traffic arriving on `https://monitoring.NGROK_DOMAIN/` to the `kube-prometheus-stack-prometheus` service running on port `9090` in your cluster.\n\n   ```yaml showLineNumbers\n   ---\n   apiVersion: networking.k8s.io/v1\n   kind: Ingress\n   metadata:\n     name: monitoring-ingress\n     namespace: kube-prometheus-stack\n   spec:\n     ingressClassName: ngrok\n     rules:\n       - host: monitoring.<NGROK_DOMAIN>\n         http:\n           paths:\n             - path: /\n               pathType: Prefix\n               backend:\n                 service:\n                   name: kube-prometheus-stack-grafana\n                   port:\n                     number: 9090\n   ```\n\n1. Visit a URL like `https://monitoring.NGROK_DOMAIN/alerts` to see data from Alertmanager:\n\n   ![Looking at the deployed Prometheus and Alertmanager dashboard](img/monitoring-deployed.png)\n\n   Having comprehensive observability for your Kubernetes app is paramount, but so is security—you don't want just anyone snooping around your metrics and alerts.\n\n1. Edit your `ngrok_ingress.yaml` file once again to add OAuth, leaving the\n   previous configurations untouched. Note the new `annotations` field and the\n   `NgrokTrafficPolicy` CR.\n\n   ```yaml showLineNumbers\n   ---\n   apiVersion: networking.k8s.io/v1\n   kind: Ingress\n   metadata:\n     name: monitoring-ingress\n     namespace: kube-prometheus-stack\n   \t annotations:\n       k8s.ngrok.com/traffic-policy: oauth\n   spec:\n     ingressClassName: ngrok\n     rules:\n       - host: monitoring.<NGROK_DOMAIN>\n         http:\n           paths:\n             - path: /\n               pathType: Prefix\n               backend:\n                 service:\n                   name: kube-prometheus-stack-grafana\n                   port:\n                     number: 9090\n    ---\n   # Traffic Policy configuration for OAuth\n   apiVersion: ngrok.k8s.ngrok.com/v1alpha1\n   kind: NgrokTrafficPolicy\n   metadata:\n     name: oauth\n     namespace: default\n   spec:\n     policy:\n   \t   on_http_request:\n   \t\t   - type: oauth\n   \t\t\t   config:\n   \t\t\t     provider: google\n   ```\n\n1. Re-apply your `2048.yaml` configuration.\n\n   ```bash\n   kubectl apply -f ngrok-ingress.yaml\n   ```\n\n1. When you open your demo app again, you'll be asked to log in via Google.\n   That's a start, but what if you want to authenticate only yourself or colleagues?\n\n1. You can use [expressions](/traffic-policy/concepts/expressions) and [CEL\n   interpolation](/traffic-policy/concepts/cel-interpolation) to filter out\n   and reject OAuth logins that don't contain `example.com`. Update the\n   `NgrokTrafficPolicy` portion of your manifest after changing `example.com` to\n   your domain.\n\n   ```yaml\n   # Traffic Policy configuration for OAuth\n   apiVersion: ngrok.k8s.ngrok.com/v1alpha1\n   kind: NgrokTrafficPolicy\n   metadata:\n     name: oauth\n     namespace: default\n   spec:\n     policy:\n       on_http_request:\n         - type: oauth\n           config:\n             provider: google\n         - expressions:\n             - \"!actions.ngrok.oauth.identity.email.endsWith('@example.com')\"\n           actions:\n             - type: custom-response\n               config:\n                 body: Hey, no auth for you ${actions.ngrok.oauth.identity.name}!\n                 status_code: 400\n   ```\n\n1. Check out your deployed 2048 app once again. If you log in with an email that\n   doesn't match your domain, ngrok rejects your request. Authentication... done!\n\n## What's next?\n\nYou've now used the open-source ngrok Kubernetes Operator to add public ingress to an example app on a Kubernetes cluster managed by DigitalOcean. Because ngrok abstracts ingress and middleware execution to its cloud service, and thanks to DigitalOcean's `doctl` tool, you can quickly deploy new clusters, apps, and helpful services without leaving your CLI.\n\nLearn more about the ngrok Kubernetes Operator, or contribute to its ongoing development, by checking out the [GitHub repository](https://github.com/ngrok/ngrok-operator). We also have an extensive explainer for [how the Operator works](/k8s/how-it-works/), plus additional [documentation](/k8s/), which also includes details on leveraging the new Kubernetes Gateway API.\n",
			  "contentTitle": "Ingress to Kubernetes apps on clusters managed by DigitalOcean"
			}
		  ],
		  "metadata": {
			"name": "digitalocean",
			"description": "",
			"excerpt": "",
			"title": "DigitalOcean"
		  }
		},
		{
		  "name": "docusign",
		  "path": "/integrations/docusign",
		  "docs": [
			{
			  "path": "/integrations/docusign/webhooks",
			  "frontMatter": {
				"description": "Develop and test DocuSign webhooks from localhost",
				"title": "DocuSign Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate DocuSign webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure DocuSign webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with DocuSign by using Webhooks.\nDocuSign webhooks can be used to notify an external application whenever specific events occur in your DocuSign account.\n\nBy integrating ngrok with DocuSign, you can:\n\n- **Develop and test DocuSign webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from DocuSign** in real-time via the inspection UI and API.\n- **Modify and Replay DocuSign Webhook requests** with a single click and without spending time reproducing events manually in your DocuSign account.\n- **Secure your app with DocuSign validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with DocuSign).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate DocuSign \n\nTo register a webhook on your DocuSign account follow the instructions below:\n\n1. Access [DocuSign](https://docusign.com/) and sign in using your DocuSign account.\n\n1. In the top menu, click **Settings** and then click **Connect** under the **INTEGRATIONS** section of the left menu.\n\n1. In the **Connect** page, click **ADD CONFIGURATION** and then click **Custom**.\n\n1. On the **Add Custom Configuration** page, enter a name in the **Name** field, and in the **URL to Publish** field enter the URL provided by the ngrok agent to expose your application to the internet (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![URL to Publish](img/ngrok_url_configuration_docusign.png)\n\n1. In the **Trigger Events** sections, expand **Envelope and Recipients**, click **Envelope Sent**, and then click **ADD CONFIGURATION** at the bottom of the page.\n\n### Run Webhooks with DocuSign and ngrok\n\nDocuSign sends different request body contents depending on the event that is being triggered.\nYou can trigger new calls from DocuSign to your application by following the instructions below.\n\n1. In the same browser, access your DocuSign inbox by clicking **Manage** on the top menu and then clicking **START NOW**.\n\n1. In the **Upload a Document and Add Envelope Recipients** page, click **UPLOAD** and then click **Desktop**.\n\n1. Select a document from your desktop, expand the **Add recipients** section and then click **I'm the only signer**.\n   **Tip**: Optionally, you can select a user from the **Name** list.\n\n1. Click **SIGN** at the bottom right of the page.\n\n   Confirm your localhost app receives the create-envelop event notification and logs both headers and body in the terminal.\n\nOptionally, you can verify the log of the webhook call in DocuSign:\n\n1. Access your DocuSign account home page, and click **Settings** on the top menu.\n\n1. On the left menu, click **Connect**, click the **LOGS** tab, and then click the most recent entry in the log list.\n   ![Logs](img/ngrok_logs_docusign.png)\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your DocuSign webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Access your DocuSign account home page and click **Settings** on the top menu.\n\n1. On the left menu, click **Connect**, click the **CONNECT KEYS** tab, click **ADD SECRET KEY**, and then copy the key value generated by DocuSign.\n\n1. In the **Connect** page, click the **APPLICATIONS** tab, click your webhook, and then in the **Integration and Security Settings** section click **Include HMAC Signature**.\n\n1. Create a traffic policy file named `docusign_policy.yml`, replacing `{your connect key}` with the value you copied before:\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: docusign\n             secret: \"{your connect key}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file docusign_policy.yml\n   ```\n\n1. Access [DocuSign](https://app.docusign.com/home) and create a new envelope.\n\n   Verify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "DocuSign Webhooks"
			}
		  ],
		  "metadata": {
			"name": "docusign",
			"description": "",
			"excerpt": "",
			"title": "DocuSign"
		  }
		},
		{
		  "name": "dropbox",
		  "path": "/integrations/dropbox",
		  "docs": [
			{
			  "path": "/integrations/dropbox/webhooks",
			  "frontMatter": {
				"description": "Develop and test Dropbox webhooks from localhost",
				"title": "Dropbox Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Dropbox webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Dropbox webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Dropbox by using Webhooks.\nDropbox webhooks can be used to notify an external application whenever specific events occur in your Dropbox account.\n\nBy integrating ngrok with Dropbox, you can:\n\n- **Develop and test Dropbox webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Dropbox** in real-time via the inspection UI and API.\n- **Modify and Replay Dropbox Webhook requests** with a single click and without spending time reproducing events manually in your Dropbox account.\n- **Secure your app with Dropbox validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm startDropbox\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Dropbox).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Dropbox \n\nTo register a webhook on your Dropbox account follow the instructions below:\n\n1. Access the [Dropbox site](https://dropbox.com/), sign in using your Dropbox account, and then access the [Dropbox developer site](https://www.dropbox.com/developers/apps).\n\n1. On the **My apps** page, click **Create app**.\n\n1. On the **Create a new app** page, click **Scoped access**, click **App folder** under the **Choose the type of access you need** section, enter a name for your app in the **App name** field, click the **terms and condition** checkbox, and then click **Create app**.\n\n1. On your app page, enter the URL provided by the ngrok agent to expose your application to the internet in the **Webhook URIs** field (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`) and click **Add** in the **Webhooks** section.\n\n   ![URL to Publish](img/ngrok_url_configuration_dropbox.png)\n\n   Confirm your localhost app receives a one-time call from Dropbox and logs the query challenge parameter in the terminal.\n\n1. Confirm your webhook appears in the **Webhooks** section of the app page with the **Enabled** status.\n\n### Run Webhooks with Dropbox and ngrok\n\nBecause you registered your app with the **App folder** type of access, Dropbox creates a new folder with the name of your app under the **Apps** folder.\n\n**Tip**: You can create a new app with **Scoped access** as **Full Dropbox** which will trigger notifications on any folder on your dropbox account.\n\nEvery time you upload a file to the app folder or modify a file inside this folder, Dropbox sends a notification to your application whenever you upload files to a folder. To upload a file follow the steps below:\n\n1. Access the [Dropbox site](https://dropbox.com/), sign in using your Dropbox account, and click **Apps** under the **All files** section on the left menu.\n\n1. The name of your app appears as a folder in the list, click this folder and then upload a file from your desktop by dragging and dropping it into the folder area of the browser.\n\nAfter the file upload process is completed, Dropbox sends a post request to your application.\n\n**Note**: The payload of this post request doesn't include any actual file/folder changes. It only informs your app of which users have changes. To gather information about the file uploaded your app will need to call Dropbox API to get the latest changes for each user in the notification.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Dropbox webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Access the [Dropbox developer site](https://www.dropbox.com/developers/apps), click the name of the app you created in the [Integrate Dropbox](#setup-webhook) step, click **Show** for the **App secret** field of the **Settings** tab, and then copy the value that appears on the page.\n\n1. Create a traffic policy file named `dropbox_policy.yml`, replacing `{your app secret}` with the value you have copied before:\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: dropbox\n             secret: \"{your app secret}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file dropbox_policy.yml\n   ```\n\n1. Access the [Dropbox site](https://dropbox.com/), sign in using your Dropbox account, and then upload a new file to the app folder.\n\n   Verify that your local application receives the post request and logs information to the terminal.\n",
			  "contentTitle": "Dropbox Webhooks"
			}
		  ],
		  "metadata": {
			"name": "dropbox",
			"description": "",
			"excerpt": "",
			"title": "Dropbox"
		  }
		},
		{
		  "name": "facebook",
		  "path": "/integrations/facebook",
		  "docs": [
			{
			  "path": "/integrations/facebook/oauth",
			  "frontMatter": {
				"description": "Authenticate users via Facebook OAuth",
				"title": "Facebook OAuth"
			  },
			  "content": "import Facebook from \"/snippets/traffic-policy/actions/oauth/examples/custom-facebook-example.mdx\";\nimport UpdatePolicyInstructions from \"/snippets/traffic-policy/actions/oauth/update-policy/update-policy-instructions.mdx\";\n\n\n\n## Creating a custom Facebook application\n\n### Register an application\n\nFor additional assistance, see the [Facebook app registration](https://developers.facebook.com/docs/apps#register) documentation.\n\n1.  Visit the [App Dashboard](https://developers.facebook.com/apps/), log in, and convert your account into a developer account if necessary.\n2.  Select \"Add a New App\" or \"Create App.\"\n3.  Choose a user-visible name and contact email.\n4.  Submit the form. A valid example app: ![](/img/howto/oauth/1-facebook-register.png)\n\n### Configure your application\n\n1.  After creation, you should see a list of products to add. If you don't, view your application from the dashboard and scroll down to \"Add a product.\" ![](/img/howto/oauth/2-facebook-add_product.png)\n2.  Select \"Set Up\" for Facebook Login.\n3.  On the left hand navigation, select Facebook Login then choose \"Settings\" below it.\n4.  Add to \"Valid OAuth Redirect URI\" `https://idp.ngrok.com/oauth2/callback`\n5.  Save the Facebook Login settings page. Final configuration should match: ![](/img/howto/oauth/3-facebook-login_settings.png)\n6.  Select Settings on the left hand navigation, then choose advanced.\n7.  Fill out additional settings for your application.\n    - ngrok does not support Server IP allowlisting.\n8.  Enable \"Require App Secret\". See [documentation](https://developers.facebook.com/docs/facebook-login/security/#appsecret) for how to call Facebook Graph API with this feature.\n9.  Save settings. A minimally complete security section of advanced settings: ![](/img/howto/oauth/4-facebook-security.png)\n10. Visit basic settings on the left hand navigation.\n11. At the top, save your App ID and App Secret for later.\n12. Fill out the privacy policy URL. This URL must accessible when entered for verification.\n13. Select a category for your application.\n14. Hit save changes. A minimally complete basic settings: ![](/img/howto/oauth/5-facebook-basic_settings.png)\n15. Select the toggle for \"In development\" at the top of the page and confirm switching to live mode.\n16. Your application should now show as live: ![](/img/howto/oauth/6-facebook-live.png)\n\n### Update your ngrok Endpoint Traffic Policy\n\n<UpdatePolicyInstructions showScopesTip={true} policySnippet={<Facebook />} />\n\n### Additional application setup information\n\n- [Handling declined permissions](https://developers.facebook.com/docs/facebook-login/handling-declined-permissions)\n- [App review](https://developers.facebook.com/docs/apps/review)\n- [App secret proof](https://developers.facebook.com/docs/graph-api/securing-requests/#appsecret_proof)\n\n## User permission revocation\n\nFacebook allows revocation of any permission as part of the authorization flow. ngrok will enforce that users initially grant all configured permissions. However, at any time after endpoint authorization, users may selectively revoke permissions. If your application requires more than the `default` or `email` scope, you must follow [Facebook's rules](https://developers.facebook.com/docs/facebook-login/handling-declined-permissions#reprompt) for handling revoked permissions without violating terms of use.\n",
			  "contentTitle": "Facebook OAuth"
			},
			{
			  "path": "/integrations/facebook/webhooks",
			  "frontMatter": {
				"description": "Develop and test Facebook webhooks from localhost",
				"title": "Facebook Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Facebook webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm run startFacebook`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000 --url myexample.ngrok.app`\n1. [Configure Facebook webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Facebook by using Webhooks.\nFacebook webhooks can be used to notify an external application whenever page or account events occur in your Facebook account.\n\nBy integrating ngrok with Facebook, you can:\n\n- **Develop and test Facebook webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Facebook** in real-time via the inspection UI and API.\n- **Modify and Replay Facebook Webhook requests** with a single click and without spending time reproducing events manually in your Facebook account.\n- **Secure your app with Facebook validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm run startFacebook\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n**Note:** This integration requires an ngrok Pro or Enterprise license because Facebook validates your ngrok domain and certificate.\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com), click **Your Authtoken**, and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n\n1. On the left menu, expand **Universal Gateway** and then click **Domains**.\n   **Tip:** If you don't have an ngrok Pro or Enterprise license, sign up for one by clicking **Update Subscription** and follow the subscribe procedure.\n\n1. On the **Domains** page, click **+ Create Domain** or **+ New Domain**.\n\n1. In the **Domain** pane, provide a value for the **Domain** field (i.e. `myexample.ngrok.app`), and then click **Continue**.\n   ![ngrok New Domain](/img/integrations/ngrok_new_domain.png)\n   **Tip**: Make sure your domain is available.\n\n1. Close the **Start a Tunnel** pane and then close the **Domain** pane.\n\n1. Start ngrok by running the following command in a terminal on your local desktop:\n\n   ```bash\n   ngrok http 3000 --url myexample.ngrok.app\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Facebook).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel_domain.png)\n\n## **Step 3**: Integrate Facebook \n\nTo register a webhook on your Facebook account follow the instructions below:\n\n**Requirements**: You'll need a Facebook page and a Facebook app associated with your Facebook page. Create one before following the rest of these steps.\n\n1. Access the [Meta for Developers](https://developers.facebook.com/) page, and Log in using your Facebook account.\n\n1. On the Developers page, click **My Apps** and then click your app.\n1. On the app dashboard, click **Add Product** on the left menu, and then click **Set up** inside the **Webhooks** tile.\n\n1. On the **Webhooks** page, select **Page** from the combo box and then click **Subscribe to this object**.\n\n1. In the **Edit User subscription** popup, enter the URL provided by the ngrok agent to expose your application to the internet in the **Callback URL** field, with `/webhooks` at the end (i.e. `https://myexample.ngrok.app/webhooks`).\n   ![Callback URL](img/ngrok_url_configuration_facebook.png)\n\n1. Enter `12345` in the **Verify token** field, click **No** on the **Include values** slider to turn it to **Yes**, and then click **Verify and save**.\n\n1. After you add a webhook to Facebook, Facebook will submit a validation post request to your application through ngrok. Confirm your localhost app receives the validation get request and logs `WEBHOOK_VERIFIED` in the terminal.\n\n1. Back to the **Webhooks** page, click **Subscribe** for the **feed** field.\n   **Tip**: You can subscribe to multiple fields within the **Page** object, as well as select other objects to subscribe to. For each of them, you provide the same URL.\n\n1. Click **Test** for the **feed** field, click **Send to My Server**, and confirm your localhost app receives the test post request.\n\n1. On the top of your app's page, make sure **App Mode** is **Live**.\n\n### Run Webhooks with Facebook and ngrok\n\nDepending on the object and the field you subscribe to, Facebook sends different request body contents.\n\nBecause you selected the **feed** action, you can test the integration by creating a post on your page or by clicking \"like\" on a post of your page:\n\n1. Access your Facebook account and then under **Your Pages and profiles** click your page.\n\n1. On the **Manage Page** for your page, click **Create post**, write something and then click **Post**.\n\nConfirm your localhost app receives the feed message and logs both headers and body in the terminal.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Facebook webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Access the [Meta for Developers](https://developers.facebook.com/) page, log in using your Facebook account, and then click **My Apps** in the top right corner.\n\n1. On the Developers page, expand **Settings** on the left menu and then click **Basic**.\n\n1. In the **Basic Settings** page, click **Show** to reveal the **App secret** value and copy this value.\n\n1. Create a traffic policy file named `facebook_policy.yml`, replacing `{your app secret}` with the value you have copied before:\n\n   ```yaml\n   on_http_request:\n     - name: \"Facebook Webhooks\"\n       actions:\n         - type: \"webhook-validation\"\n           config:\n             provider: \"facebook_graph_api\"\n             secret: \"{your app secret}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file facebook_policy.yml\n   ```\n\n1. Access the Facebook page you have assigned to your webhook and send a message to another Facebook user.\n\n   Verify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "Facebook Webhooks"
			}
		  ],
		  "metadata": {
			"name": "facebook",
			"description": "",
			"excerpt": "",
			"title": "Facebook"
		  }
		},
		{
		  "name": "facebook-messenger",
		  "path": "/integrations/facebook-messenger",
		  "docs": [
			{
			  "path": "/integrations/facebook-messenger/webhooks",
			  "frontMatter": {
				"description": "Develop and test Facebook Messenger webhooks from localhost",
				"title": "Facebook Messenger Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Facebook Messenger webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `node appFB`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000 --url myexample.ngrok.app`\n1. [Configure Facebook webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Facebook by using Webhooks.\nFacebook webhooks can be used to notify an external application whenever specific events occur in your Facebook account.\n\nBy integrating ngrok with Facebook, you can:\n\n- **Develop and test Facebook Messenger webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Facebook Messenger** in real-time via the inspection UI and API.\n- **Modify and Replay Facebook Messenger Webhook requests** with a single click and without spending time reproducing events manually in your Facebook Messenger account.\n- **Secure your app with Facebook Messenger validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm run startFacebook\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n**Note:** This integration requires a ngrok Pro or Enterprise license because Facebook validates your ngrok domain.\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com), click **Your Authtoken**, and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n\n1. On the left menu, expand **Universal Gateway** and then click **Domains**.\n   **Tip:** If you don't have a ngrok Pro or Enterprise license, subscribe for one by clicking **Update Subscription** and following the subscribe procedure.\n\n1. In the **Domains** page, click **+ Create Domain** or **+ New Domain**.\n\n1. In the **Domain** pane, provide a value for the **Domain** field (i.e. `myexample.ngrok.app`), and then click **Continue**.\n   ![ngrok New Domain](img/ngrok_new_domain.png)\n   **Tip**: Make sure your domain is available.\n\n1. Close the **Start a Tunnel** pane and then close the **Domain** pane.\n\n1. Start ngrok by running the following command in a terminal on your local desktop:\n\n   ```bash\n   ngrok http 3000 --url myexample.ngrok.app\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Facebook).\n   ![ngrok agent running](img/launch_ngrok_tunnel_domain.png)\n\n## **Step 3**: Integrate Facebook Messenger \n\nTo register a webhook on your Facebook account follow the instructions below:\n\n**Note**: You'll need a Facebook page associated with your Facebook account. Create one before continuing this procedure.\n\n1. Access the [Meta for Developers](https://developers.facebook.com/) page, and Log in using your Facebook account.\n\n1. On the Developers page, click **My Apps**.\n1. On the **Apps** page, click **Create App**.\n\n1. On the **Create an App** page, click **Business** for the **Select an app type** section and then click **Next**.\n\n1. On the **Provide basic information** page, provide the **Display name** as `My Example App`, make sure your email appears in the **App contact email** field otherwise enter your email, and then click **Create App**.\n   **Tip:** Facebook may request your Facebook account password. Provide your password in the **Please Re-enter Your Password** popup.\n\n1. On the app page, click **Add Product** on the left menu.\n\n1. On the **Add a product** page, click **Set up** inside the **Messenger** tile.\n\n1. On the **Messenger Settings** page, click **Add Callback URL** in the **Webhooks** section.\n\n1. In the **Edit Callback URL** popup, for the **Callback URL** field enter the URL provided by the ngrok agent to expose your application to the internet, with `/webhook` at the end (i.e. `https://myexample.ngrok.app/webhook`).\n   ![Callback URL](img/ngrok_url_configuration_facebookmessenger.png)\n\n1. Enter `12345` for the **Verify token** field and then click **Verify and save**.\n\n1. After you add a webhook to Facebook Messenger, Facebook will submit a validation post request to your application through ngrok. Confirm your localhost app receives the validation post request in the terminal.\n\n1. Back to the **Messenger Settings** page, in the **Webhooks** section, click **Add or remove Pages**.\n\n1. In the new browser page that follows, sign in to Facebook, select a page, click **Next**, and then click **Done**. The message **You've now linked MyExampleApp to Facebook** appears. Click **OK**.\n\n1. The new browser window shows your Facebook page. Close this window.\n\n1. In the **Meta for Developers** page, click **Settings** under **Messenger** on the left menu, and then scroll down to the **Webhooks** section.\n\n1. In the **Webhooks** section, click **Add subscription** for your page, select all subscription fields, and then click **Save**.\n\n1. Scroll down to the **Built-in NLP** section, select your page in the **Select a Page** combo box, and then click the slider button at the right of the combo box to turn it on.\n\n1. On the top of the **MyExampleApp** page, click the **App Mode** slider to turn the app to **Live** mode.\n\n### Run Webhooks with Facebook and ngrok\n\nYou can test the integration by following the procedure below:\n\n1. On the **Meta for Developers** page, click the **Webhooks** under the **Products** section in the left menu.\n\n1. In the **Webhooks** page, select **Page** in the combo box, find one of the subscription fields you have subscribed to during the webhook registration and then click **Test**.\n\n1. In the **Field Sample** popup, click **Send to My Server**.\n\nConfirm your localhost app receives the test message and logs both headers and body in the terminal.\n\n    **Tip:** Facebook sends different request body contents depending on the event you select during the webhook registration.\n\nNow that you have successfully registered your webhook and tested it, access the Facebook page you have assigned to your webhook and send a message to another Facebook user. Alternatively, you can sign in to Facebook using another Facebook account, access your page, and then send a message through the Messenger feature.\n\nVerify that your local application receives the request and logs information to the terminal.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Facebook webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Access the [Meta for Developers](https://developers.facebook.com/) page, log in using your Facebook account, and then click **My Apps** on the top right corner.\n\n1. On the Developers page, expand **Settings** on the left menu and then click **Basic**.\n\n1. In the **Basic Settings** page, click **Show** to reveal the **App secret** value and copy this value.\n\n1. Create a traffic policy file named `messenger_policy.yml`, replacing `{your app secret}` with the value you have copied before:\n\n   ```yaml\n   on_http_request:\n     - name: \"Facebook Messenger Webhooks\"\n       actions:\n         - type: \"webhook-validation\"\n           config:\n             provider: \"facebook_messenger\"\n             secret: \"{your app secret}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file messenger_policy.yml\n   ```\n\n1. Access the Facebook page you have assigned to your webhook and send a message to another Facebook user.\n\n   Verify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "Facebook Messenger Webhooks"
			}
		  ],
		  "metadata": {
			"name": "facebook-messenger",
			"description": "",
			"excerpt": "",
			"title": "Facebook Messenger"
		  }
		},
		{
		  "name": "frameio",
		  "path": "/integrations/frameio",
		  "docs": [
			{
			  "path": "/integrations/frameio/webhooks",
			  "frontMatter": {
				"description": "Develop and test Frame.io webhooks from localhost",
				"title": "Frame.io Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Frame.io webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Frame.io webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Frame.io by using Webhooks.\nFrame.io webhooks can be used to notify an external application whenever specific events occur in your Frame.io account.\n\nBy integrating ngrok with Frame.io, you can:\n\n- **Develop and test Frame.io webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Frame.io** in real-time via the inspection UI and API.\n- **Modify and Replay Frame.io Webhook requests** with a single click and without spending time reproducing events manually in your Frame.io account.\n- **Secure your app with Frame.io validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Frame.io).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Frame.io \n\nTo register a webhook on your Frame.io account follow the instructions below:\n\n1. Access [Frame.io](https://frame.io/) and sign in using your Frame.io account.\n\n1. In the same browser, access [Frame.io Developer](https://developer.frame.io/).\n\n1. On the top menu of the developer site, click **DEVELOPER TOOLS** and then click **Webhooks**.\n\n1. On the **Webhooks** page, click **Create a Webhook**.\n\n1. On the **Create a new webhook** page, enter a name in the **NAME** field, and in the **URL** field enter the URL provided by the ngrok agent to expose your application to the internet (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![Frameio URL to Publish](img/ngrok_url_configuration_frameio.png)\n\n1. Select your team for the **TEAM** field, click the **created** checkbox for **Projects** under the **EVENTS** section, and then click **Submit**.\n\n### Run Webhooks with Frame.io and ngrok\n\nFrame.io sends different request body contents depending on the event that is being triggered.\nYou can trigger new calls from Frame.io to your application by following the instructions below.\n\n1. In the same browser, access [Frame.io](https://frame.io/), and then click **+** close to your team name on the left menu.\n\n1. On the **New Project** popup, enter a project name and then click **Create Project**.\n\n   Confirm your localhost app receives the create-project event notification and logs both headers and body in the terminal.\n\nOptionally, you can verify the log of the webhook call in Frame.io:\n\n1. In the same browser, access [Frame.io Developer](https://developer.frame.io/).\n\n1. On the top menu of the developer site, click **DEVELOPER TOOLS** and then click **Webhooks**.\n\n1. On the **Webhooks** page, click **View logs** close to your webhook.\n\n1. On the **Webhook Logs** page, click **View details** and confirm\n   ![Webhook Logs](img/ngrok_logs_frameio.png)\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Frame.io webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Access [Frame.io Developer](https://developer.frame.io/).\n\n1. On the top menu of the developer site, click **DEVELOPER TOOLS** and then click **Webhooks**.\n\n1. On the **Webhooks** page, click **Copy** to copy the **Secret** value.\n\n1. Create a traffic policy file named `frameio_policy.yml`, replacing `{your webhook secret}` with the value you have copied before (See [Integrate ngrok and Frame.io.](#setup-webhook)):\n\n   ```yaml\n   on_http_request:\n     - name: \"Verify Frame.io requests\"\n       actions:\n         - type: verify-webhook\n           config:\n             provider: \"frameio\"\n             secret: \"{your webhook secret}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file frameio_policy.yml\n   ```\n\n1. Access [Frame.io](https://frame.io/) and create a new project.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "Frame.io Webhooks"
			}
		  ],
		  "metadata": {
			"name": "frameio",
			"description": "",
			"excerpt": "",
			"title": "Frame.io"
		  }
		},
		{
		  "name": "frontegg",
		  "path": "/integrations/frontegg",
		  "docs": [
			{
			  "path": "/integrations/frontegg/sso-oidc",
			  "frontMatter": {
				"title": "Frontegg Endpoint SSO (OpenID Connect)",
				"description": "Use Frontegg OIDC to secure access to ngrok endpoints"
			  },
			  "content": "\nimport Disclaimer from \"/snippets/integrations/_endpoint-sso-disclaimer.mdx\";\n\n<Disclaimer />\n<Tip>\n**TL;DR**\n\n\n\nTo secure access to ngrok with Frontegg Single Sign-On (SSO) using OpenID Connect:\n\n1. [Configure Frontegg SSO](#configure-frontegg)\n1. [Configure ngrok](#configure-ngrok)\n1. [Test access to ngrok with Frontegg SSO](#test-sso)\n</Tip>\n\nThis article details how to configure Frontegg as the primary Identity Provider (IDP) for ngrok endpoints.\nBy integrating Frontegg SSO with ngrok, you can:\n\n- **Restrict access to ngrok endpoints** only to users authenticated via Frontegg\n- **Use Frontegg security policies and MFA authenticators**.\n- **Use Frontegg's Dashboard to facilitate access to ngrok apps**.\n\n## Supported Features\n\nThe ngrok integration with Frontegg supports:\n\n- **SP-Initiated SSO**: In this mode, users access ngrok endpoints and are redirected to Frontegg for authentication.\n\n## Requirements\n\nTo configure an ngrok edge with Frontegg, you must have:\n\n- A Frontegg account with administrative rights to create apps\n- An [ngrok Enterprise Account](https://ngrok.com/pricing) with an authtoken or admin access to configure edges with OpenID Connect.\n\n## Configuration Steps\n\nTo integrate ngrok with Frontegg SSO, you will need to:\n\n1. Configure Frontegg with the ngrok app\n1. Configure ngrok with the SSO settings provided by Frontegg\n\n## **Step 1**: Configure Frontegg \n\n### Add the ngrok App in Frontegg\n\n1. Access the [Frontegg Portal](https://portal.frontegg.com/), and sign in using your Frontegg administrator account.\n\n1. On the left menu, click the environment you want to integrate with ngrok. In this example click the **Development** environment.\n\n1. On the left menu, click **Authentication**, click **Login method**, enter the URL `https://idp.ngrok.com/oauth2/callback` under the **Hosted login** field, and then click **Save**.\n   ![Frontegg configuration](img/ngrok_url_configuration_frontegg.png)\n\n1. On the left menu, click **Env settings**, and copy the value of both the **Client ID** and the **API key** fields.\n\n1. Click the **Domains** tab, and copy the value of the **Domain name**.\n\n### Grant access to Frontegg users\n\nCreate a Frontegg user:\n\n1. On the left menu of the [Frontegg Portal](https://portal.frontegg.com/), click your environment, click **Backoffice**, click **Accounts**, and then click **Add New**.\n\n1. On the **Add new account** popup, enter a name for the account, `ngrok.com` in the **Domain** field, and then click **Save**.\n\n1. On the left menu, click **Backoffice**, click **Users**, and then click **Add New**.\n\n1. On the **Add new user** popup, enter a name, email, select the account you have created, and then click **Save**.\n   **Note**: by default, the user is assigned the **Admin** role.\n\n## **Step 2**: Configure ngrok \n\nngrok can leverage Frontegg SSO in two ways:\n\n- From the ngrok CLI (using the `--oidc` parameter)\n- From the ngrok dashboard\n\n### **Option 1**: ngrok CLI\n\n> **Note:** For this tutorial, we assume you have an app running locally (i.e., on localhost:3000) with the ngrok client installed.\n\n1. Launch a terminal\n\n1. Enter the following command to launch an ngrok tunnel with Frontegg SSO:\n\n   ```bash\n   ngrok http 3000 --oidc=FRONTEGG_OAUTH_URL \\\n   --oidc-client-id=FRONTEGG_CLIENT_ID \\\n   --oidc-client-secret=FRONTEGG_CLIENT_SECRET \\\n   ```\n\n   **Note**: Replace the following with the values:\n   - FRONTEGG_OAUTH_URL: Your Frontegg **Domain name** URL (i.e. `https://app-123456.frontegg.com`).\n   - FRONTEGG_CLIENT_ID: The client id you copied from Frontegg.\n   - FRONTEGG_CLIENT_SECRET: The API key you copied from Frontegg.\n\n   Alternatively, add the `--url YOUR_DOMAIN` argument to get your custom URL, replacing `YOUR_DOMAIN` with your URL of preference.\n\n1. Copy the URL available next to **Forwarding** (for example, `https://frontegg-sso-test.ngrok.app`).\n\n1. Skip to **Step 3**\n\n### **Option 2**: ngrok Edge\n\nTo configure an edge with Frontegg:\n\n1. Access the [ngrok Dashboard](https://dashboard.ngrok.com/) and sign in using your ngrok account.\n\n1. On the left menu, click **Universal Gateway** and then click **Edges**.\n\n1. If you don't have an edge already set to add Frontegg SSO, create a test edge:\n   - Click **+ New Edge**.\n   - Click **Create HTTPS Edge**.\n   - Click the **pencil icon** next to \"no description\", enter `Frontegg SSO OIDC` as the edge name and click **Save**.\n\n1. On the edge settings menu, click **OIDC**.\n\n1. Click **Begin setup** and enter the following values into the fields:\n   ![Frontegg config in ngrok](img/frontegg-1.png)\n   - **Issuer URL**: Your Frontegg **Domain name** URL (i.e. `https://app-123456.frontegg.com`).\n   - **Client ID**: The client id you copied from Frontegg.\n   - **Client Secret**: The API key you copied from Frontegg.\n\n1. Click **Save** at the top, and then click the left arrow to go back to the **Edges** page.\n\n1. Launch a tunnel connected to your Frontegg edge:\n<Tip>\n**Note**\n\n\nFor this step, we assume you have an app running locally (i.e. on localhost:3000) with the ngrok client installed.\n</Tip>\n\n1. Click **Start a tunnel**.\n\n1. Click the **copy icon** next to the tunnel command.\n   ![tunnel config](img/frontegg-2.png)\n\n1. Launch a tunnel:\n   - Launch a terminal.\n   - Paste the command but replace `http://localhost:80` with your localhost app address (i.e., `http://localhost:3000`).\n   - Click **Enter** and an ngrok tunnel associated with your edge configuration will launch.\n\n1. To confirm that the tunnel is connected to your edge:\n   - Return to the ngrok dashboard\n   - Close the **Start a tunnel** and the **Tunnel group** tabs\n   - Refresh the test edge page. Under traffic, you will see the message _You have 1 tunnel online. Start additional tunnels to begin load balancing._\n     ![tunnel confirmed](img/frontegg-3.png)\n\n1. In the test edge, copy the **endpoint URL** (you use this URL to test the Frontegg Authentication).\n   ![tunnel url](img/frontegg-4.png)\n\n## Step 3: Test the integration \n\n1. In your browser, launch an incognito window.\n\n1. Access your ngrok tunnel (i.e., `https://frontegg-sso-test.ngrok.app`). Use the copied endpoint URL.\n\n1. You should be prompted to log in with your Frontegg credentials.\n\n1. After logging in, you should be able to see your web app.\n",
			  "contentTitle": "Frontegg Endpoint SSO (OpenID Connect)"
			},
			{
			  "path": "/integrations/frontegg/sso-saml",
			  "frontMatter": {
				"description": "Use Frontegg SAML to secure access to ngrok endpoints",
				"title": "Frontegg SSO (SAML)"
			  },
			  "content": "import Disclaimer from \"/snippets/integrations/_endpoint-sso-disclaimer.mdx\";\n\n<Disclaimer />\n<Tip>\n**TL;DR**\n\n\n\nTo secure access to ngrok with Frontegg Single Sign-On using SAML:\n\n1. [Download the IDP metadata](#idp-metadata)\n1. [Configure ngrok](#configure-ngrok)\n1. [Configure Frontegg](#configure-frontegg)\n1. [Update Frontegg Login Method](#frontegg-login)\n1. [Test access to ngrok with Frontegg SSO](#test-sso)\n</Tip>\n\nThis article details how to configure Frontegg as the primary Identity Provider for ngrok endpoints.\nBy integrating Frontegg SSO with ngrok, you can:\n\n- **Restrict access to ngrok endpoints** only to users authenticated via Frontegg\n- **Use Frontegg security policies and MFA authenticators**.\n- **Use Frontegg's Dashboard to facilitate access to ngrok apps**.\n\n## Requirements\n\nTo configure ngrok tunnels with Frontegg, you must have:\n\n- A Frontegg account with administrative rights to create apps\n- An [ngrok Enterprise Account](https://ngrok.com/pricing) with an authtoken or admin access to configure edges with SAML.\n\n## Configuration Steps\n\nTo integrate ngrok with Frontegg SSO, you will need to:\n\n1. Configure Frontegg with the ngrok app\n1. Configure ngrok with the SSO settings provided by Frontegg\n\n### **Step 1**: Download the IDP metadata \n\n1. Access the [Frontegg Portal](https://portal.Frontegg.com/) and sign in using your Frontegg administrator account.\n\n1. On the left menu, click your environment under **Environments** and then click **Env settings**.\n\n1. On the **General Settings** page, copy both the **Client ID** and **API Key** values.\n\n1. Open a terminal window and run the following command to get an access token:\n\n   ```bash\n   curl --request POST \\\n     --url https://api.frontegg.com/auth/vendor/ \\\n     --header 'accept: application/json' \\\n     --header 'content-type: application/json' \\\n     --data '{\"clientId\": \"CLIENT_ID\",\"secret\": \"API_KEY\"}'\n   ```\n\n   **Note**: Replace the following with values:\n   - CLIENT_ID: The client ID value you copied before.\n   - API_KEY: The API key value you copied before.\n\n1. Copy the value of the **token** attribute from the response.\n\n1. In the same terminal window, run the following command to download the metadata XML file from Frontegg:\n\n   ```bash\n   curl --location --request POST 'https://api.frontegg.com/oauth/resources/configurations/saml/v1/https%3A%2F%2Ftemporary' \\\n   --header 'frontegg-vendor-host: YOUR_FRONTEGG_HOST_URL' \\\n   --header 'Authorization: Bearer TOKEN' \\\n   --header 'Content-Type: application/json' \\\n   --data-raw '{\n      \"acsUrl\": \"https://temporary\",\n      \"entityId\": \"https://temporary\"\n   }'\n   ```\n\n   **Note**: Replace the following with values copied on previous steps:\n   - YOUR_FRONTEGG_HOST_URL: The value of the **Domain name** from the **Env settings** > **Domains** tab.\n   - TOKEN: The token you copied before.\n\n1. Copy the response and save it as the `idp_metadata.xml` file locally on your desktop.\n   **Note**: The response starts with `<EntityDescriptor` and ends with `</EntityDescriptor>`. Anything different may be an error.\n\n### **Step 2**: Configure ngrok \n\nTo configure an edge with Frontegg:\n\n1. Access the [ngrok Dashboard](https://dashboard.ngrok.com/) and sign in using your ngrok account.\n\n1. On the left menu, click **Universal Gateway** and then click **Edges**.\n\n1. If you don't have an edge already set to add Frontegg SSO, create a test edge:\n   - Click **+ New Edge**.\n   - Click **Create HTTPS Edge**.\n   - Click the **pencil icon** next to \"no description\", enter `Frontegg SSO SAML` as the edge name, and click **Save**.\n\n1. On the edge settings menu, click **SAML**.\n\n1. On the **SAML** page, click **Begin setup**, click **Upload XML**, and then open the XML metadata file you downloaded from Frontegg (See [Download the IdP metadata](#idp-metadata)).\n   ![Frontegg config in ngrok](img/frontegg-5.png)\n\n1. Click **Save** at the top.\n\n1. Copy both the **Entity ID** and the **ACS URL** values for later use.\n\n### **Step 3**: Configure Frontegg \n\n1. In the same terminal window in which you ran the previous commands, run the following command to create a SAML configuration related to your ngrok SAML edge:\n\n   ```bash\n   curl --location --request POST 'https://api.frontegg.com/oauth/resources/configurations/saml/v1/URL-ENCODED-NGROK-ENTITY-ID' \\\n   --header 'frontegg-vendor-host: YOUR_FRONTEGG_HOST_URL' \\\n   --header 'Authorization: Bearer TOKEN' \\\n   --header 'Content-Type: application/json' \\\n   --data-raw '{\n      \"acsUrl\": \"NGROK_ACS_URL\",\n      \"entityId\": \"NGROK_ENTITY_ID_URL\"\n   }'\n   ```\n\n   **Note**: Replace the following with the values copied on previous steps:\n   - URL_ENCODED_NGROK_ENTITY_ID: URL-Encoded value of the ngrok **Entity ID\\*** copied from the edge SAML configuration.\n   - YOUR_FRONTEGG_HOST_URL: The value of the **Domain name** from the **Env settings** > **Domains** tab.\n   - TOKEN: The Frontegg token you copied before.\n   - NGROK_ACS_URL: The value of the ngrok **Entity ID** copied from the edge SAML configuration.\n   - NGROK_ENTITY_ID_URL: The value of the ngrok **ACS URL** copied from the edge SAML configuration.\n\n### **Step 4**: Update Frontegg Login Method \n\n1. Access the [Frontegg Portal](https://portal.Frontegg.com/) and sign in using your Frontegg administrator account.\n\n1. On the left menu, click your environment under **Environments**, click **Authentication**, and then click **Login method**.\n\n1. On the **Select your login method** page, make sure **Hosted login** is selected, and click **Add new** twice.\n\n1. In the first empty field, enter the endpoint URL from your ngrok edge (i.e., `https://123456789.ngrok.app/`). In the second field, enter the **ACS URL** from your Edge SAML configuration.\n   ![Frontegg config in ngrok](img/frontegg-6.png)\n\n1. Click **Save**.\n\n### **Step 5**: Start a Tunnel \n\n1. Access the [ngrok edges page](https://dashboard.ngrok.com/edges), click your edge, and then click **Start a tunnel**.\n<Tip>\n**Note**\n\n\nFor this step, we assume you have an app running locally (i.e. on localhost:3000) with the ngrok client installed.\n</Tip>\n\n1. Click the **copy icon** next to the tunnel command.\n   ![tunnel config](img/frontegg-2.png)\n\n1. Launch a tunnel:\n   - Launch a terminal.\n   - Paste the command but replace `http://localhost:80` with your localhost app address (i.e., `http://localhost:3000`).\n   - Click **Enter** and an ngrok tunnel associated with your edge configuration will launch.\n\n1. To confirm that the tunnel is connected to your edge:\n   - Return to the ngrok dashboard\n   - Close the **Start a tunnel** and the **Tunnel group** tabs\n   - Refresh the test edge page. Under traffic, You will see the message _You have 1 tunnel online. Start additional tunnels to begin load balancing._\n     ![tunnel confirmed](img/frontegg-3.png)\n\n1. In the test edge, copy the **endpoint URL**. (you use this URL to test the Frontegg Authentication)\n   ![tunnel url](img/frontegg-7.png)\n\n## Grant access to Frontegg users\n\nCreate a Frontegg user:\n\n1. On the left menu of the [Frontegg Portal](https://portal.frontegg.com/), click your environment, click **Backoffice**, click **Accounts**, and then click **Add New**.\n\n1. On the **Add new account** popup, enter a name for the account, `ngrok.com` in the **Domain** field, and then click **Save**.\n\n1. On the left menu, click **Backoffice**, click **Users**, and then click **Add New**.\n\n1. On the **Add new user** popup, enter a name and email, select the account you have created, and then click **Save**.\n   **Note**: by default value to assign the **Admin** role to the user\n\n## Test the integration \n\n1. In your browser, launch an incognito window.\n\n1. Access your ngrok tunnel (i.e., `https://frontegg-sso-test.ngrok.app`. Use the copied endpoint URL).\n\n1. You should be prompted to log in with your Frontegg credentials.\n\n1. After logging in, you should be able to see your web app.\n",
			  "contentTitle": "Frontegg SSO (SAML)"
			}
		  ],
		  "metadata": {
			"name": "frontegg",
			"description": "",
			"excerpt": "",
			"title": "Frontegg"
		  }
		},
		{
		  "name": "fusionauth",
		  "path": "/integrations/fusionauth",
		  "docs": [
			{
			  "path": "/integrations/fusionauth/sso-oidc",
			  "frontMatter": {
				"title": "FusionAuth Endpoint SSO (OpenID Connect)",
				"description": "Use FusionAuth SSO to secure access to ngrok endpoints"
			  },
			  "content": "\nimport Disclaimer from \"/snippets/integrations/_endpoint-sso-disclaimer.mdx\";\n\n<Disclaimer />\n<Tip>\n**TL;DR**\n\n\n\nTo secure access to ngrok with FusionAuth Single Sign-On using OpenID Connect:\n\n1. [Configure FusionAuth SSO](#configure-FusionAuth)\n1. [Configure ngrok](#configure-ngrok)\n1. [Test access to ngrok with FusionAuth SSO](#test-sso)\n</Tip>\n\nThis article details how to configure FusionAuth as the primary Identity Provider for ngrok tunnels.\nBy integrating FusionAuth SSO with ngrok, you can:\n\n- **Restrict access to ngrok tunnels** only to users authenticated via FusionAuth\n- **Use FusionAuth Premium Features and Login Methods** — including Advanced Registration Forms, Passwordless Login, WebAuthn, **and Advanced Threat Detection to control access to ngrok tunnels**.\n\n## Supported Features\n\nThe ngrok integration with FusionAuth supports:\n\n- **OIDC based SSO**: In this mode, users access ngrok edges and tunnels and are redirected to FusionAuth for authentication.\n\n## Requirements\n\nTo configure ngrok tunnels with FusionAuth, you must have:\n\n- A public facing FusionAuth instance. You can spin up a basic [FusionAuth Cloud instance](https://fusionauth.io/pricing) or [install it on any server](https://fusionauth.io/docs/v1/tech/installation-guide/).\n- An [ngrok Enterprise Account](https://ngrok.com/pricing) with an authtoken or admin access to configure edges with OpenID Connect.\n- A local web app or application that needs to be protected by Fusion Auth.\n\n## Configuration Steps\n\nTo integrate ngrok with FusionAuth SSO, you will need to:\n\n1. Configure FusionAuth with the ngrok app\n1. Configure ngrok with the SSO settings provided by FusionAuth\n\n## **Step 1**: Configure FusionAuth \n\n### Add the ngrok App in FusionAuth\n\n1. Navigate to your FusionAuth instance.\n1. Navigate to **Tenants** > **Your Tenant** and change the issuer to the URL of your FusionAuth instance. For example, https://acme.fusionauth.io.\n1. Navigate to **Applications** and then create a new Application. Fill out the **Name** field, then click the **OAuth** tab.\n1. Make sure that the **Enabled grants** checkboxes have the **Authorization Code** and **Refresh Token** grants enabled.\n1. In the **Authorized redirect URLs** field add `https://idp.ngrok.com/oauth2/callback`\n1. Click the `Save` button.\n1. You should see values in the **Client Id** and **Client secret** fields. Copy them; ou’ll use them in the [Configure ngrok](#configure-ngrok) step.\n1. Your Application should look like this:\n   ![Application Configuration](img/application-configuration.png)\n\n## **Step 2**: Configure ngrok \n\nngrok can leverage FusionAuth SSO in two ways:\n\n- From the ngrok CLI (using the `--oidc` parameter)\n- From the ngrok dashboard\n\n### **Option 1**: ngrok CLI\n\n> **Note:** For this tutorial, we assume you have an app running locally (i.e., on localhost:3000) with the ngrok client installed.\n\n1. Launch a terminal\n1. Enter the following command to launch an ngrok tunnel with FusionAuth SSO. Replace `<FusionAuth_url>` with your FusionAuth org address (i.e., https://acme.fusionauth.com) and the `<FusionAuth_client_id>` and `<FusionAuth_client_secret>` with the respective values copied from the ngrok app registered at FusionAuth:\n\n   ```bash\n   ngrok http 3000 --oidc <FusionAuth_url> \\\n   --oidc-client-id <FusionAuth_client_id> \\\n   --oidc-client-secret <FusionAuth_client_secret> \\\n   --url fusionauth-sso-test.ngrok.dev\n   ```\n\n1. Skip to **Step 3**\n\n### **Option 2**: ngrok Edge\n\nTo configure an edge with FusionAuth:\n\n1. Go to dashboard.ngrok.com.\n1. Click **Universal Gateway** > **Edges**\n1. If you don't have an edge already set to add FusionAuth SSO, create a test edge:\n   - Click **New Edge**\n   - Click **HTTPS Edge**\n   - Click the **pencil icon** next to \"no description\". Enter _Edge with FusionAuth SSO_ as the edge name and click **Save**.\n1. On the edge settings, click **OIDC**.\n1. Click **Begin setup** and enter the following:\n\n   ![FusionAuth config in ngrok](img/ngrok-edge.png)\n   - **Issuer URL**: Your FusionAuth tenant url (i.e. https://acme.fusionauth.com).\n   - **Client ID**: The client id copied from FusionAuth\n   - **Client Secret**: The client secret copied from FusionAuth\n\n1. Click **Save**.\n\n1. Launch a tunnel connected to your FusionAuth edge:\n<Tip>\n**Note**\n\n\nFor this step, we assume you have an app running locally (i.e. on localhost:3000) with the ngrok client installed.\n</Tip>\n\n1.  Click **Start a tunnel**.\n1.  Click the **copy icon** next to the tunnel command.\n\n    ![tunnel config](img/fa-2.png)\n\n1.  Launch a tunnel:\n    - Launch a terminal\n    - Paste the command. Replace http://localhost:80 with your local web app addess (i.e., http://localhost:3000)\n    - hit **Enter**. an ngrok tunnel associated to your edge configuration is launched.\n1.  To confirm that the tunnel is connected to your edge:\n    - Return to the ngrok dashboard\n    - Close the **Start a tunnel** and the **Tunnel group** tabs\n    - Refresh the test edge page. Under traffic, You will see the message _You have 1 tunnel online. Start additional tunnels to begin load balancing_\n\n    ![tunnel confirmed](img/fa-3.png)\n\n1.  In the **Endpoints** section, copy the **endpoint URL**. (you will use this url to test the FusionAuth Authentication)\n    ![tunnel url](img/ngrok-url.png)\n\n## Step 3: Test the integration \n\n1. In your browser, launch an incognito window.\n1. Access your ngrok tunnel (i.e., https://fusionauth-sso-test.ngrok.app or using a copied URL).\n1. You should be prompted to log in with your FusionAuth credentials.\n1. After login, you should be able to see your web app.\n",
			  "contentTitle": "FusionAuth Endpoint SSO (OpenID Connect)"
			}
		  ],
		  "metadata": {
			"name": "fusionauth",
			"description": "",
			"excerpt": "",
			"title": "FusionAuth"
		  }
		},
		{
		  "name": "github",
		  "path": "/integrations/github",
		  "docs": [
			{
			  "path": "/integrations/github/oauth",
			  "frontMatter": {
				"description": "Authenticate users via GitHub OAuth",
				"title": "GitHub OAuth"
			  },
			  "content": "import Github from \"/snippets/traffic-policy/actions/oauth/examples/custom-github-example.mdx\";\nimport UpdatePolicyInstructions from \"/snippets/traffic-policy/actions/oauth/update-policy/update-policy-instructions.mdx\";\n\n\n\n## Creating a custom GitHub OAuth application\n\n1.  Follow [GitHub's documentation](https://developer.github.com/apps/building-oauth-apps/creating-an-oauth-app/) until the final step of submitting the registration form.\n2.  Set the Authorization callback URL to `https://idp.ngrok.com/oauth2/callback`.\n3.  Submit the form. A working example registration: ![](/img/howto/oauth/1-github-register.png)\n4.  Save the client ID and client secret from the application overview: ![](/img/howto/oauth/2-github-client_id_and_secret.png)\n\n### Update your ngrok endpoint traffic policy\n\n<UpdatePolicyInstructions policySnippet={<Github />} showNameSnippet={true} />\n\n## Known Limitations\n\n- Users who utilize GitHub's [private email setting](https://docs.github.com/en/account-and-profile/setting-up-and-managing-your-personal-account-on-github/managing-email-preferences/setting-your-commit-email-address#:~:text=If%20you%27d%20like%20to%20keep%20your%20personal,to%20Keep%20my%20email%20address%20private) are not able to sign in.\n",
			  "contentTitle": "GitHub OAuth"
			},
			{
			  "path": "/integrations/github/webhooks",
			  "frontMatter": {
				"description": "Develop and test GitHub webhooks from localhost",
				"title": "GitHub Repository Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate GitHub webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure GitHub webhook with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with GitHub to allow GitHub to send notifications to your localhost app anytime an event takes place in a GitHub repository.\n\nBy integrating ngrok with GitHub, you can:\n\n- **Develop and test GitHub webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from GitHub** in real-time via the inspection UI and API\n- **Modify and Replay GitHub Webhook requests** with a single click and without spending time reproducing events manually in GitHub\n- **Secure your app with GitHub webhook validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with GitHub).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate GitHub \n\nGitHub can trigger webhook calls to external applications whenever events happen in a repository. To register for such events, follow the instructions below:\n\n1. Sign in to [GitHub](https://github.com).\n\n1. Select a repository from **Your Repository** list.\n   **Tip:** If you don't have a repository, create a new empty one.\n\n1. In the repository page, click **Settings** and then select **Webhooks** from the left menu.\n\n1. Add a new webhook by clicking **Add webhook**.\n\n1. In the **Payload URL**, use the URL provided by the ngrok agent to expose your application to the internet (i.e., `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![Payload URL](img/ngrok_url_configuration_github.png)\n\n1. Select the **Content type** of the data submitted from GitHub to your application as `application/json`.\n\n1. Choose which events you would like to trigger this webhook. For this example, select **Just the push event**.\n\n1. Make sure your webhook is active, and then click **Add webhook**.\n\n### Run Webhooks with GitHub and ngrok\n\nAfter you add a webhook to your GitHub repository, GitHub will submit a post request to your application through ngrok.\n\nTo review the content of this request on GitHub:\n\n1. Select the webhook you've just created.\n\n1. Click the **Recent Deliveries** tab.\n\n1. Select the ID of the delivery.\n\nCompare the headers and the body of this delivery with the information received by your application, and then confirm they contain the same data.\n\n**Note:** Different messages are sent to your application depending on the trigger event you choose.\n\nBecause you've selected **Just the push event** in this example, to trigger new calls from GitHub to your application, you need to push content to your GitHub repository.\nTo resend any request, click **Redeliver** in the **Recent Deliveries**' tab of your GitHub **Manage webhook** page.\n\n![GitHub Recent Deliveries](img/review_github_recent_deliveries.png)\n\n<InspectingRequests />\n\n<ReplayingRequests />\n\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your GitHub webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Create a traffic policy file named `github_policy.yml`, replacing `{your secret}` with your **Secret** from GitHub:\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: github\n             secret: \"{your secret}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file github_policy.yml\n   ```\n\n1. Resend one of the messages from your GitHub webhook.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "GitHub Repository Webhooks"
			}
		  ],
		  "metadata": {
			"name": "github",
			"description": "",
			"excerpt": "",
			"title": "GitHub"
		  }
		},
		{
		  "name": "gitlab",
		  "path": "/integrations/gitlab",
		  "docs": [
			{
			  "path": "/integrations/gitlab/oauth",
			  "frontMatter": {
				"description": "Authenticate users via GitLab OAuth",
				"title": "GitLab"
			  },
			  "content": "import Gitlab from \"/snippets/traffic-policy/actions/oauth/examples/custom-gitlab-example.mdx\";\nimport UpdatePolicyInstructions from \"/snippets/traffic-policy/actions/oauth/update-policy/update-policy-instructions.mdx\";\n\n\n\n## Configure GitLab OAuth with ngrok\n\nThe step-by-step instructions below follow GitLab's documentation on [setting up OAuth 2.0](https://docs.gitlab.com/ee/integration/oauth_provider.html) for a web application.\n\n### Create an Application\n\n1.  Access your [GitLab profile page](https://gitlab.com/-/profile) and select **Applications** on the left menu.\n\n    **Note**: If you want to restrict the list of users able to log in with GitLab, either create an application under one of your groups or an instance-wide application. See [Additional application setup information](#additional-application-setup-information).\n\n2.  Provide a **Name** for your application and enter `https://idp.ngrok.com/oauth2/callback` in the **Redirect URI** field.\n\n    ![](/img/howto/oauth/1-gitlab-register.png)\n\n3.  In the **Scopes** section, select all the fields appropriate for your app and then click **Save application**. In this example, mark the **openid**, **profile**, and **email** fields.\n\n    ![](/img/howto/oauth/2-gitlab-scopes.png)\n\n### Update your ngrok endpoint traffic policy\n\n<UpdatePolicyInstructions policySnippet={<Gitlab />} />\n\n### Additional application setup information\n\n- [Configure GitLab as an OAuth 2.0 authentication identity provider](https://docs.gitlab.com/ee/integration/oauth_provider.html)\n- [OAuth 2.0 identity provider API](https://docs.gitlab.com/ee/api/oauth2.html)\n",
			  "contentTitle": "GitLab"
			},
			{
			  "path": "/integrations/gitlab/webhooks",
			  "frontMatter": {
				"description": "Develop and test GitLab webhooks from localhost",
				"title": "GitLab Repository Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate GitLab webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure GitLab webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with GitLab to allow GitLab to send notifications to your app anytime an event takes place in a GitLab repository.\n\nBy integrating ngrok with GitLab, you can:\n\n- **Develop and test GitLab webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from GitLab** in real-time via the inspection UI and API.\n- **Modify and Replay GitLab Webhook requests** with a single click and without spending time reproducing events manually in your GitLab account.\n- **Secure your app with GitLab validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with GitLab).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate GitLab \n\nGitLab can trigger webhook calls to external applications whenever events happen in a repository. To register for such events, follow the instructions below:\n\n1. Sign in to [GitLab](https://gitlab.com).\n\n1. Select a repository from the **Your Repository** list.\n   **Tip:** If you don't have a repository, create a new empty one.\n\n1. In the repository page, click **Settings** from the left menu and then click **Webhooks**.\n\n1. On the **Webhooks** page, in the **URL** field enter the URL provided by the ngrok agent to expose your application to the internet (i.e., `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![URL](img/ngrok_url_configuration_gitlab.png)\n\n1. Mark the **Push events** checkbox under the **Trigger** section and then click **Add webhook**.\n\n1. On the **Webhooks** page, scroll down until the **Project Hooks** section appears.\n\n1. In the webhook list for the **Project Hooks** section, click **Test** for the webhook you've just created and then click **Push events**.\n\n   Confirm your localhost app receives the test event notification and logs both headers and body to the terminal.\n\n1. Optionally, in the webhook list, click the **Edit** button for your webhook entry, scroll down the webhook page until the **Recent events** section appears, and then click **View details** for the **Push Hook** trigger line to verify information about the post request GitLab has sent to your localhost application.\n   ![GitLab Recent events](img/review_gitlab_recent_events.png)\n\n   Verify the content of the request is the same as the content received by your localhost app.\n\n### Run Webhooks with GitLab and ngrok\n\nBecause you've selected the **Push event** as the trigger for your webhook, GitLab will submit a post request to your application through ngrok whenever you push content to your repository.\n**Note:** Different messages are sent to your application depending on the trigger event you choose.\n\nFollow the instructions below to add some content to your repository:\n\n1. Click the name of your repository at the top of the left menu.\n\n1. On the project's page, click **+** and then click **New file**.\n\n1. In the **New file** page, enter a name for the file in the **File name** field, and enter the following content to the file in the textbox:\n   `This is my file content`.\n\n1. Click **Commit changes**.\n\n   Confirm your localhost app receives the push event notification and logs both headers and body to the terminal.\n\nAlternatively, clone your repository locally, add some content, commit, and then push the content to your repostiory on GitLab:\n`git add .; git commit -m \"my first commit\"; git push`\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Gitlab webhooks are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. In the repository page, click **Settings** from the left menu and then click **Webhooks**.\n\n1. In the **Webhooks** page, scroll down until the **Project Hooks** section appears, and then click **Edit** for your webhook.\n\n1. Enter a text for the **Secret token** field and click **Save changes**.\n\n1. Create a traffic policy file named `gitlab_policy.yml`, replacing `{your secret token}` with the value you have provided to the **Secret token** field (See [Integrate GitLab](#setup-webhook)):\n\n   ```yaml\n   - on_http_request:\n       - actions:\n           - type: verify-webhook\n         config:\n           provider: gitlab\n           secret: \"{your secret token}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file gitlab_policy.yml\n   ```\n\n1. In the **Project Hooks** section, click **Test** for your webhook, and then click **Push events**. Alternatively, push content to your repository.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "GitLab Repository Webhooks"
			}
		  ],
		  "metadata": {
			"name": "gitlab",
			"description": "",
			"excerpt": "",
			"title": "GitLab"
		  }
		},
		{
		  "name": "google",
		  "path": "/integrations/google",
		  "docs": [
			{
			  "path": "/integrations/google/oauth",
			  "frontMatter": {
				"description": "Authenticate users with Google OAuth",
				"title": "Google OAuth"
			  },
			  "content": "import Google from \"/snippets/traffic-policy/actions/oauth/examples/custom-google-example.mdx\";\nimport UpdatePolicyInstructions from \"/snippets/traffic-policy/actions/oauth/update-policy/update-policy-instructions.mdx\";\n\n\n\nBy default, if you use `\"google\"` for OAuth in your traffic policies without specifying a Google OAuth application, visitors to your endpoint will be authenticated using an ngrok managed Google OAuth instance.\n\nSetting up your own Google OAuth application will allow you to customize how authentication works with fine-grained detail. This guide walks you through setting up a Google OAuth 2.0 application to use with your ngrok endpoints.\n\n## 1. Build the consent screen\n\n1.  Create or select a project on the [Google Cloud Platform Console](https://console.cloud.google.com).\n2.  Navigate to the project's [OAuth consent screen](https://console.developers.google.com/apis/credentials/consent).\n3.  Select whether your application is an [internal or external app](https://support.google.com/cloud/answer/6158849?hl=en#public-and-internal).\n4.  Fill out the application name and support email.\n5.  Add additional scopes required by your application, saving the full scope URI for later.\n    - [Possible scope URIs](https://developers.google.com/identity/protocols/oauth2/scopes)\n      .\n6.  Ensure that the `email` and `profile` scopes are still selected.\n7.  Under Authorized domains, add `ngrok.com` and your application homepage domain.\n8.  Add links to your application homepage and privacy policy. The final consent screen should resemble: ![](/img/howto/oauth/1-google-consent_screen_complete.png)\n9.  Save the application.\n    - Applications that require verification cannot complete the consent screen and are not supported by ngrok.\n\n## 2. Create credentials for ngrok\n\n1.  Navigate to [Credentials](https://console.cloud.google.com/apis/credentials) for your project.\n2.  Select \"Create credentials\" from the top menu and select \"OAuth Client ID\".\n3.  Choose \"Web application\" from the list of application types.\n4.  Name your secret, then set \"Authorized Redirect URIs\" to `https://idp.ngrok.com/oauth2/callback`. The final credentials form should resemble: ![](/img/howto/oauth/2-google-create_client_id.png)\n5.  Securely store the client ID and secret from the final screen: ![](/img/howto/oauth/3-google-client_id_and_secret.png)\n\n## 3. Update your ngrok endpoint traffic policy\n\n<UpdatePolicyInstructions policySnippet={<Google />} />\n\n## Additional application setup information\n\n- [Google OAuth 2.0 Web Server](https://developers.google.com/identity/protocols/oauth2/web-server) (prerequisite steps)\n- [GCP Help: Setting up OAuth 2.0](https://support.google.com/cloud/answer/6158849?hl=en)\n- [Google OAuth 2.0 workflow](https://developers.google.com/identity/protocols/oauth2)\n",
			  "contentTitle": "Google OAuth"
			}
		  ],
		  "metadata": {
			"name": "google",
			"description": "",
			"excerpt": "",
			"title": "Google"
		  }
		},
		{
		  "name": "google-gke",
		  "path": "/integrations/google-gke",
		  "docs": [
			{
			  "path": "/integrations/google-gke/google-kubernetes-engine",
			  "frontMatter": {
				"title": "Kubernetes ingress to GKE services with ngrok",
				"description": "Learn how to use the ngrok Kubernetes Operator on Google Kubernetes Engine (GKE) to quickly add secure Kubernetes ingress to your apps or APIs.",
				"tags": [
				  "kubernetes",
				  "k8s",
				  "google kubernetes engine",
				  "gke",
				  "google",
				  "ingress controller"
				]
			  },
			  "content": "\nThe [ngrok Kubernetes Operator](https://github.com/ngrok/ngrok-operator) is our official open-source controller for adding public and secure ingress traffic to your k8s services. It works out of the box with Google Kubernetes Engine cluster to provide ingress to your services no matter the network configuration, as long as it has outbound access to the ngrok service. This allows ngrok to be portable and work seamlessly across any type of infrastructure.\n\n## What you'll need\n\n- A [GKE cluster](https://cloud.google.com/kubernetes-engine/docs/deploy-app-cluster)\n- An [ngrok account](https://ngrok.com/signup).\n- [kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl/) and [Helm\n  3.0.0+](https://helm.sh/docs/intro/install/) installed on your local\n  workstation.\n- The [ngrok Kubernetes Operator](/k8s/) installed on\n  your cluster.\n- A reserved domain, which you can get in the ngrok\n  [dashboard](https://dashboard.ngrok.com/domains) or with the [ngrok\n  API](/api/resources/reserved-domains/).\n  - You can choose from an ngrok subdomain or bring your own custom branded\n    domain, like `https://api.example.com`.\n  - We'll refer to this domain as `<NGROK_DOMAIN>`.\n\n## Ensure `kubectl` can speak with your cluster \n\nWith a Google Kubernetes Engine (GKE) cluster, authentication for `kubectl` happens with a credential helper. So in-order to deploy the ngrok Kubernetes Operator to your cluster, you'll need to ensure that you can use the `gcloud` CLI and that the credential helper is available.\n\nLet's ensure that you have the `gcloud` CLI installed and configured with your Google Cloud credentials. You can confirm this works and you're authenticated correctly by running the following command:\n\n```bash\ngcloud auth list\n```\n\nIf you see your correct Google account listed, you should be all set. If not, you can run `gcloud auth login` to authenticate with your Google account.\n\nNext, we'll ensure that the credential helper is available. Run the following command to confirm that the credential helper is available:\n\n```bash\ngcloud components install gke-gcloud-auth-plugin\n```\n\nFinally, we can add the cluster to our KUBECONFIG:\n\n```bash\ngcloud container clusters get-credentials --region <cluster-region> --project <cluster-project> <cluster-name>\n```\n\n## Install the ngrok Kubernetes Operator \n\nNow we can install the ngrok Kubernetes Operator to provide ingress to our services.\n\nCheck out our [Operator installation doc](/getting-started/kubernetes/ingress/) for\ndetails on how to use Helm to install with your ngrok credentials.\n\n## Install a Sample Application \n\nCreate a manifest file (for example `ngrok-manifest.yaml`) with the following contents. You will need to replace the `NGROK_DOMAIN` on line 45 with your own custom value. This is the URL you will use to access your service from anywhere. If you're on a free account, it must be on a static subdomain which you can claim by logging into your account and following the instructions on the claim static subdomain banner. For paid accounts, you can use a custom domain or a subdomain of `ngrok.app` or `ngrok.dev` (for example, `username-loves-ingress.ngrok.app` or `k8s.example.com`).\n<Tip>\n**Notes:**\n\n\n\n- Lines 1-34: Create the 2048 app service and deployment\n- Lines 35-54 (highlighted): Create the ngrok Kubernetes Operator. Line 45 determines the ingress URL for public requests.\n</Tip>\n\n```yaml showLineNumbers\napiVersion: v1\nkind: Service\nmetadata:\n  name: game-2048\nspec:\n  ports:\n    - name: http\n      port: 80\n      targetPort: 80\n  selector:\n    app: game-2048\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: game-2048\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: game-2048\n  template:\n    metadata:\n      labels:\n        app: game-2048\n    spec:\n      containers:\n        - name: backend\n          image: alexwhen/docker-2048\n          ports:\n            - name: http\n              containerPort: 80\n---\n# highlight-start\n# ngrok Kubernetes Operator Configuration\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: game-2048-ingress\n  namespace: ngrok-operator\nspec:\n  ingressClassName: ngrok\n  rules:\n    - host: <NGROK_DOMAIN>\n      http:\n        paths:\n          - path: /\n            pathType: Prefix\n            backend:\n              service:\n                name: game-2048\n                port:\n                  number: 80\n# highlight-end\n```\n\n1. Apply the manifest file to your k8s cluster.\n\n   ```bash\n   kubectl apply -f ngrok-manifest.yaml\n   ```\n\n   **Note:** If you get an error when applying the manifest, double check that you've updated the `NGROK_DOMAIN` value and try again.\n\n1. Access your ingress URL using the subdomain you chose in the manifest file above (i.e. `https://my-awesome-k8s-cluster.ngrok.app`) to confirm the 2048 app is accessible from the internet.\n\n   ![application public](/img/howto/kubernetes-operator/k8s-ingress-app-2.png)\n\n## Add authentication to your app \n\nWith our [Traffic Policy system](/traffic-policy/) and the [`oauth`\naction](/traffic-policy/actions/oauth), ngrok manages OAuth protection\nentirely at the ngrok cloud service, which means you don't need to add any\nadditional services to your cluster, or alter routes, to ensure ngrok's edge\nauthenticates and authorizes all requests before allowing ingress and access to\nyour endpoint.\n\nTo enable the `oauth` action, you'll create a new `NgrokTrafficPolicy` custom\nresource and apply it to your entire `Ingress` with an annotation. You can also\napply the policy to just a specific backend or as the default backend for an\n`Ingress`—see our doc on using the [Operator with\nIngresses](/k8s/guides/using-ingresses/#using-ngroktrafficpolicy-with-ingress).\n\n1. Edit your existing `2048.yaml` manifest with the following, leaving the\n   `Service` and `Deployment` as they were. Note the new `annotations` field and\n   the `NgrokTrafficPolicy` CR.\n\n   ```yaml\n    ...\n   ---\n   # Configuration for ngrok's Kubernetes Operator\n   apiVersion: networking.k8s.io/v1\n   kind: Ingress\n   metadata:\n     name: game-2048-ingress\n     namespace: default\n     annotations:\n       k8s.ngrok.com/traffic-policy: oauth\n   spec:\n     ingressClassName: ngrok\n     rules:\n       - host: <NGROK_DOMAIN>\n         http:\n           paths:\n             - path: /\n               pathType: Prefix\n               backend:\n                 service:\n                   name: game-2048\n                   port:\n                     number: 80\n   ---\n   # Traffic Policy configuration for OAuth\n   apiVersion: ngrok.k8s.ngrok.com/v1alpha1\n   kind: NgrokTrafficPolicy\n   metadata:\n     name: oauth\n     namespace: default\n   spec:\n     policy:\n   \t   on_http_request:\n   \t\t   - type: oauth\n   \t\t\t   config:\n   \t\t\t     provider: google\n   ```\n\n1. Re-apply your `2048.yaml` configuration.\n\n   ```bash\n   kubectl apply -f 2048.yaml\n   ```\n\n1. When you open your demo app again, you'll be asked to log in via Google.\n   That's a start, but what if you want to authenticate only yourself or colleagues?\n\n1. You can use [expressions](/traffic-policy/concepts/expressions) and [CEL\n   interpolation](/traffic-policy/concepts/cel-interpolation) to filter out\n   and reject OAuth logins that don't contain `example.com`. Update the\n   `NgrokTrafficPolicy` portion of your manifest after changing `example.com` to\n   your domain.\n\n   ```yaml\n   # Traffic Policy configuration for OAuth\n   apiVersion: ngrok.k8s.ngrok.com/v1alpha1\n   kind: NgrokTrafficPolicy\n   metadata:\n     name: oauth\n     namespace: default\n   spec:\n     policy:\n       on_http_request:\n         - type: oauth\n           config:\n             provider: google\n         - expressions:\n             - \"!actions.ngrok.oauth.identity.email.endsWith('@example.com')\"\n           actions:\n             - type: custom-response\n               config:\n                 body: Hey, no auth for you ${actions.ngrok.oauth.identity.name}!\n                 status_code: 400\n   ```\n\n1. Check out your deployed 2048 app once again. If you log in with an email that\n   doesn't match your domain, ngrok rejects your request. Authentication... done!\n",
			  "contentTitle": "Kubernetes ingress to GKE services with ngrok"
			}
		  ],
		  "metadata": {
			"name": "google-gke",
			"description": "",
			"excerpt": "",
			"title": "Google Kubernetes Engine (GKE)"
		  }
		},
		{
		  "name": "heroku",
		  "path": "/integrations/heroku",
		  "docs": [
			{
			  "path": "/integrations/heroku/webhooks",
			  "frontMatter": {
				"description": "Develop and test Heroku webhooks from localhost",
				"title": "Heroku Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Heroku webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Heroku webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Heroku by using Webhooks.\nHeroku webhooks can be used to notify an external application whenever specific events occur in your Heroku account.\n\nBy integrating ngrok with Heroku, you can:\n\n- **Develop and test Heroku webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Heroku** in real-time via the inspection UI and API.\n- **Modify and Replay Heroku Webhook requests** with a single click and without spending time reproducing events manually in your Heroku account.\n- **Secure your app with Heroku validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Heroku).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Heroku \n\nTo register a webhook on your Heroku account follow the instructions below:\n\n1. Access [Heroku](https://heroku.com/) and sign in using your Heroku account.\n\n1. On the Dashboard page, click the name of a app from the **Personal** app list.\n   **Tip:** If you don't have an app, create a new one by clicking **New** and then clicking **Create new app**.\n\n1. On your app's page, click **More**, click **View Webhooks**, and then click **Create Webhook**.\n\n1. On the **New Webhook** popup, enter a name in the **Webhook Name** field and enter the URL provided by the ngrok agent to expose your application to the internet in the **Payload URL** field (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![URL to Publish](img/ngrok_url_configuration_heroku.png)\n\n1. Enter a `12345` in the **Secret** field, click the **api:app** and the **api:build** checkboxes under the **Event Types** section, and then click **Add Webhook**:\n\n### Run Webhooks with Heroku and ngrok\n\nHeroku sends different request body contents depending on the event that is being triggered.\nYou can trigger a call from Heroku to your application by following the instructions below:\n\n1. Access [Heroku](https://heroku.com/) and sign in using your Heroku account.\n\n1. On the Dashboard page, click your app name, click the **Deploy** tab, scroll down to the **Manual deploy** section, select a branch to deploy, and then click **Deploy Branch**.\n\n   After the deployment finishes, confirm your localhost app receives a notification and logs both headers and body in the terminal.\n\nOptionally, you can verify the log of the webhook call on your Heroku's page:\n\n1. On the Dashboard page, click your app name, click **More**, click **View Webhooks**, and then click the name of your webhook on the list of webhooks.\n\n   ![Webhook Logs](img/ngrok_logs_heroku.png)\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Heroku webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Create a traffic policy file named `heroku_policy.yml`, replacing `{your webhook secret}` with the value you have entered in the **Secret** field during the webhook registration (See [Integrate ngrok and Heroku.](#setup-webhook)):\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: heroku\n             secret: \"{your webhook secret}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file heroku_policy.yml\n   ```\n\n1. Access [Heroku](https://heroku.com/), sign in using your Heroku account, access your app, and then execute a new build.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "Heroku Webhooks"
			}
		  ],
		  "metadata": {
			"name": "heroku",
			"description": "",
			"excerpt": "",
			"title": "Heroku"
		  }
		},
		{
		  "name": "home-assistant",
		  "path": "/integrations/home-assistant",
		  "docs": [
			{
			  "path": "/integrations/home-assistant/home-assistant-with-ngrok",
			  "frontMatter": {
				"title": "Home Assistant",
				"description": "Access your Home Assistant instance from anywhere with ngrok.",
				"tags": [
				  "home assistant",
				  "security",
				  "docker",
				  "iot"
				]
			  },
			  "content": "\n# Home Assistant with ngrok\n<Tip>\n**TL;DR**\n\n\n\nTo put your Home Assistant instance online with ngrok:\n\n1. Start Home Assistant locally in a Docker container\n1. Add ngrok to the Docker container\n1. Allow trusted proxies in Home Assistant\n</Tip>\n\nThis guide covers how to set up Home Assistant with ngrok. This combination lets you access your Home Assistant dashboard over the public internet.\n\nPrerequisites:\n\n- Docker Desktop\n- Docker Compose\n- [ngrok](https://download.ngrok.com) installed on your machine\n- Basic familiarity with the command line\n\nTip: This guide walks through setting up Home Assistant in a Docker container from scratch, but the same principles apply if you already have a Home Assistant instance set up, or if you set it up using one of their other [installation methods](https://www.home-assistant.io/installation/).\n\n## **Step 1**: Initial setup\n\n1. Create a directory called `home-assistant`\n\n1. Inside the `home-assistant` directory:\n\n- create your Docker Compose file called `compose.yaml`\n- create a directory called `config`\n\n## **Step 2**: Run Home Assistant in a Docker container\n\n1. Update `compose.yaml`:\n\n```yaml\nservices:\n  homeassistant:\n    image: \"ghcr.io/home-assistant/home-assistant:stable\"\n    volumes:\n      - /etc/localtime:/etc/localtime:ro\n      - /run/dbus:/run/dbus:ro\n      # the first part of this path will be the location of\n      # the `/home-assistant/config` directories you created in the last step\n      - /Desktop/home-assistant/config:/config\n    restart: unless-stopped\n    ports:\n      - 8123:8123\n    privileged: true\n```\n\n1. In your terminal, start a Docker container with this compose.yaml file:\n\n```bash\ndocker compose up -d\n```\n\n1. Visit localhost:8123 in your browser. You should see your Home Assistant login page:\n   ![Home Assistant on localhost](/img/integrations/ngrok_test_ha_locally.png)\n\n## **Step 3**: Add ngrok\n\n1. Add ngrok to your `compose.yaml` under the services section:\n\n```yaml\nservices:\n  ngrok:\n    image: ngrok/ngrok:latest\n    command:\n      - \"http\"\n      - \"http://host.docker.internal:8123\"\n    ports:\n      # you can choose different ports here if you want\n      - 4041:4041\n    environment:\n      # find this at https://dashboard.ngrok.com/get-started/your-authtoken\n      NGROK_AUTHTOKEN: YOUR_AUTH_TOKEN\n```\n\n1. In your terminal, restart your Docker container with this compose.yaml file:\n\n```bash\ndocker compose up -d\n```\n\n1. Visit your [ngrok dashboard](https://dashboard.ngrok.com/endpoints) to see the endpoint URL:\n   ![ngrok Endpoints](/img/integrations/ngrok_endpoint.png)\n\n1. If you visit the ngrok URL, you'll get a 4xx response:\n   ![ngrok Endpoints](/img/integrations/ngrok_bad_request.png)\n\nand an error log line your Docker Desktop logs for the Home Assistant container:\n\n```\nERROR (MainThread) [homeassistant.components.http.forwarded] A request from a reverse proxy was received from 192.168.65.1, but your HTTP integration is not set-up for reverse proxies\n```\n\nThat's because we still have to update the Home Assistant configuration to allow trusted proxies.\n\n## **Step 3**: Allow trusted proxies in Home Assistant\n\n1. In your `/home-assistant/config` directory, look for the file called `configuration.yaml`. By default, it should already have these settings:\n\n```yaml\n# Loads default set of integrations. Do not remove.\ndefault_config:\n\n# Load frontend themes from the themes folder\nfrontend:\n  themes: !include_dir_merge_named themes\n\nautomation: !include automations.yaml\nscript: !include scripts.yaml\nscene: !include scenes.yaml\n```\n\nAdd this new section to the bottom:\n\n```yaml\nhttp:\n  use_x_forwarded_for: true\n  trusted_proxies:\n    # this IP may be different on your network; grab the IP from the error message\n    # in your logs\n    - 192.168.65.1\n    - 127.0.0.1\n    - ::1\n```\n\n1. Restart the Docker container so the updated Home Assistant configuration can take effect.\n\n1. Visit your ngrok endpoint URL and see your Home Assistant instance online!\n   ![ngrok hosting Home Assistant](/img/integrations/ngrok_home_assistant_online.png)\n",
			  "contentTitle": "Home Assistant"
			}
		  ],
		  "metadata": {
			"name": "Home Assistant",
			"description": "",
			"excerpt": "",
			"title": "Home Assistant"
		  }
		},
		{
		  "name": "hostedhooks",
		  "path": "/integrations/hostedhooks",
		  "docs": [
			{
			  "path": "/integrations/hostedhooks/webhooks",
			  "frontMatter": {
				"description": "Develop and test HostedHooks webhooks from localhost",
				"title": "HostedHooks Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate HostedHooks webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure HostedHooks webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with HostedHooks by using Webhooks.\nHostedHooks webhooks can be used to route requests to HostedHooks servers to your localhost app.\n\nBy integrating ngrok with HostedHooks, you can:\n\n- **Develop and test HostedHooks webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from HostedHooks** in real-time via the inspection UI and API.\n- **Modify and Replay HostedHooks Webhook requests** with a single click and without spending time reproducing events manually in your HostedHooks account.\n- **Secure your app with HostedHooks validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with HostedHooks).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate HostedHooks \n\nTo register a webhook on your HostedHooks account follow the instructions below:\n\n1. Access [HostedHooks](https://www.hostedhooks.com/) and sign in using your HostedHooks account.\n\n1. Click **Apps** on the left menu, and then click **Setup New App**.\n\n1. On the **Setup Your Application** page, enter `My App` in the **App Name** field and then click **Save App**.\n\n1. On the app page, click **Create Your Webhook Event** (Step 1), enter `myapp.event` in the **Event Type** field, and then click **Save Webhook Event**.\n\n1. On the app page, click **Create your first Subscriber** (Step 2), enter `My Localhost App` in the **Subscription Name** field, and then click **Save Subscription**.\n\n1. On the **My Localhost App Subscription** page, click **+ New Endpoint**.\n\n1. On the **New Endpoint** page, enter the URL provided by the ngrok agent to expose your application to the internet in the **Webhook URL** field (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![hostedhooks URL to Publish](img/ngrok_url_configuration_hostedhooks.png)\n\n1. Enter `1.0` in the **Version** field, enter `ngrok` in the **Description** field, and then click **Save Endpoint**.\n\n1. Click the left arrow to go back to the app page and then click **Subscribe to a webhook event** (Step 4).\n\n1. On the **Details** page, select **myapp.event** in the **Subscribed Events** selector and then click **Add Event**.\n\n1. Click the left arrow twice to go back to the app page and then click **Send a test webhook message**.\n\n   Confirm your localhost app receives the **myapp.event** event notification and logs both headers and body in the terminal.\n\n### Run Webhooks with HostedHooks and ngrok \n\nWhenever you post a message to the HostedHooks message endpoint using the value **myapp.event** as the event type inside the body of the request, HostedHooks routes this message to your localhost app through your ngrok URL.\nYou can trigger new calls from HostedHooks to your application by following the instructions below.\n\n1. Open a terminal window and run the following command:\n\n   ```bash\n   curl --request POST --url https://hostedhooks.com/api/v1/apps/APP_ID/messages\n   \\\n   --header 'Authorization: Bearer API_KEY' \\\n   --header 'Content-Type: application/json' --data '{\n       \"data\": {\n           \"foo\": \"bar\"\n       },\n       \"event_type\": \"myapp.event\",\n       \"version\": \"1.0\",\n       \"event_id\": \"00001\"\n   }'\n   ```\n\n   **Note**: Replace the following with the corresponding values:\n   - APP_ID: The ID of your application. Copy the value from your app page on HostedHooks, in the **My App** section.\n   - API_KEY: The **API Key** value from the **Settings** page on HostedHooks.\n\n   Confirm your localhost app receives the event notification and logs both headers and body in the terminal.\n\nAlternatively, you can verify the log of the webhook call in HostedHooks:\n\n1. Access the [HostedHooks Dashboard](https://www.hostedhooks.com/), click **Apps** on the left menu, and then click your app tile.\n\n1. On your app page, scroll down to the **Inbound Messages** section and verify the messages sent to your app.\n   ![Webhook Logs](img/ngrok_logs_hostedhooks.png)\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your HostedHooks webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Access the [HostedHooks Dashboard](https://www.hostedhooks.com/), click **Apps** on the left menu, and then click your app tile.\n\n1. On the app page, click **View** in the **Subscribers** section and click **View** in the **Endpoints** section.\n\n1. On the **Endpoint** page, click **Reveal** in the **Signing Secret** field and copy the value that appears.\n\n1. Create a traffic policy file named `hostedhooks_policy.yml`, replacing `{app sign secret}` with the value you copied before:\n\n   ```yaml\n   on_http_request:\n     - name: \"Verify HostedHooks requests\"\n       actions:\n         - type: verify-webhook\n           config:\n             provider: \"hostedhooks\"\n             secret: \"{app sign secret}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file hostedhooks_policy.yml\n   ```\n\n1. Post a new message to the message endpoint of HostedHooks by following the same procedure as the [Run Webhooks with HostedHooks and ngrok](#run-webhook) section.\n   **Tip**: Modify the value of the **event_id** field in the JSON body. This value must be unique per app.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "HostedHooks Webhooks"
			}
		  ],
		  "metadata": {
			"name": "hostedhooks",
			"description": "",
			"excerpt": "",
			"title": "HoostedHooks"
		  }
		},
		{
		  "name": "hubspot",
		  "path": "/integrations/hubspot",
		  "docs": [
			{
			  "path": "/integrations/hubspot/webhooks",
			  "frontMatter": {
				"description": "Develop and test HubSpot webhooks from localhost",
				"title": "HubSpot Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate HubsSpot webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure HubSpot webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with HubSpot by using Webhooks.\nHubSpot webhooks can be used to notify an external application whenever specific events occur in your HubSpot account.\n\nBy integrating ngrok with HubSpot, you can:\n\n- **Develop and test HubSpot webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from HubSpot** in real-time via the inspection UI and API.\n- **Modify and Replay HubSpot Webhook requests** with a single click and without spending time reproducing events manually in your HubSpot account.\n- **Secure your app with HubSpot validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with HubSpot).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate HubSpot \n\nTo trigger a webhook on a HubSpot account you can create an app in the [HubSpot Developers](https://developers.hubspot.com/) site and associate this app to your account or make use of automation workflows.\n\nThe following instructions explain how to configure an automation workflow on your HubSpot account.\n**Note:** This automation workflow feature requires a HubSpot Pro or developer account.\n\n1. Sign in to [HubSpot](https://app.hubspot.com/). If you have multiple HubSpot accounts click **open** for a pro account or an App test account.\n\n1. On the dashboard page, click **Automation** on the top menu and then click **Workflows**.\n\n1. On the **Workflows** page, click **Create workflow** and then click **From scratch**.\n\n1. On the workflow page, enter `New Contacts` as the name of the workflow, select **Blank workflow**, and then click **Next**.\n\n1. On the **New Contacts** workflow page, click **Set up triggers** to open the **Enrollment triggers** popup.\n\n1. On the **Enrollment triggers** popup, select **Contact properties** as the **Filter type**, select **Contact owner** from the search list, select **is any of**, select your user from the list below, click **Apply filter**, and then click **Save**.\n\n1. On the **New Contacts** workflow page, click **+** just after the **Contact enrollment** box to open the **Choose an action** popup.\n\n1. On the **Choose an action** popup, click **Send a webhook**.\n\n1. On the **Send a webhook** popup, select **POST** as the **Method**, and in the **Webhook URL** field enter the URL provided by the ngrok agent to expose your application to the internet (i.e., `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![URL](img/ngrok_url_configuration_hubspot.png)\n\n1. Select **None** as **Authentication type** and make sure **Include all contact properties** is selected.\n\n1. Click **Test action**, search for a **Contact**, and then click **Test**.\n\n   Confirm your localhost app receives the test event notification and logs both headers and body to the terminal.\n\n1. Click **Review and publish** on the top right of the page.\n\n1. On the **Review before you turn on** page, select **No** for the **Do you want to enroll them when this workflow turns on?** question, and then click **Turn on** on the top right of the page.\n\n### Run Webhooks with HubSpot and ngrok\n\nYou can trigger new calls from HubSpot to your application by creating a contact on your HubSpot account.\n\n1. Access your HubSpot account or, if you are on the workflow page, click **Back to Workflows** on the top left of the page.\n\n1. On the top menu, click **Contacts** and then click **Contacts**.\n\n1. On the **Contacts** page, click **Create contact** to open the **Create contact** popup.\n\n1. On the **Create contact** popup, enter an **Email**, **First Name**, and **Last name** for your new contact.\n\n1. Select your user as the **Contact owner**, and then click **Create**.\n   **Tip**: This needs to be the same user you selected during your workflow trigger configuration.\n\nAfter a few seconds, confirm your localhost app receives the contact-created event notification and logs both headers and body to the terminal.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your HubSpot webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. On the HubSpot dashboard page, click **Automation** on the top menu and then click **Workflows**.\n\n1. In the **Workflows** list page, click the **New Contacts** workflow.\n\n1. In the **New Contacts** workflow page, click **Actions** for the **Send a webhook** step and then click **Edit**.\n\n1. In the **Send a webhook** popup, enter the ID of a custom app you created using your developer account, and then click **Save**.\n\n1. On your developer account home page, click **Manage apps** and then click your app.\n\n1. On your app page, click the **Auth** tab, click **Show** in the **Client secret** section, and then click **Copy**.\n\n1. Create a traffic policy file named `hubspot_policy.yml`, replacing `{your client secret}` with the value you copied before:\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: hubspot\n             secret: \"{your client secret}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file hubspot_policy.yml\n   ```\n\n1. Access your [HubSpot](https://hubspot.com) account and create a new contact (don't forget to Select your user as the **Contact owner**).\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "HubSpot Webhooks"
			}
		  ],
		  "metadata": {
			"name": "hubspot",
			"description": "",
			"excerpt": "",
			"title": "HubSpot"
		  }
		},
		{
		  "name": "hygraph",
		  "path": "/integrations/hygraph",
		  "docs": [
			{
			  "path": "/integrations/hygraph/webhooks",
			  "frontMatter": {
				"description": "Develop and test Hygraph webhooks from localhost",
				"title": "Hygraph Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Hygraph webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Hygraph webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Hygraph by using Webhooks.\nHygraph webhooks can be used to notify an external application whenever specific events occur in your Hygraph account.\n\nBy integrating ngrok with Hygraph, you can:\n\n- **Develop and test Hygraph webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Hygraph** in real-time via the inspection UI and API.\n- **Modify and Replay Hygraph Webhook requests** with a single click and without spending time reproducing events manually in your Hygraph account.\n- **Secure your app with Hygraph validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Hygraph).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Hygraph \n\nTo register a webhook on your Hygraph account follow the instructions below:\n\n1. Access [Hygraph](https://app.hygraph.com/) and sign in using your Hygraph account.\n\n1. On the left menu, click **Webhooks** and then click **Add Webhook**.\n\n1. On the webhook popup, enter a name in the **Name** field and enter the URL provided by the ngrok agent to expose your application to the internet in the **URL** field (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![hygraph URL to Publish](img/ngrok_url_configuration_hygraph.png)\n\n1. Select **Asset** in the **Content Model** field and then click **Add** at the top of the popup screen.\n\n### Run Webhooks with Hygraph and ngrok\n\nHygraph sends different request body contents depending on the event that is being triggered.\nYou can trigger new calls from Hygraph to your application by following the instructions below.\n\n1. On the Hygraph home page, click **Assets** and then click **+ Add entry**.\n\n1. On the **Assets** page, click **Upload**, select a file from your desktop, click **Upload**, and then click **Save & Publish**.\n\n   Confirm your localhost app receives event notifications and logs both headers and body in the terminal.\n\n   Alternatively, you can verify the log of the webhook call in Hygraph:\n   1. On the left menu, click **Webhooks** and then click **View Logs** for your webhook, and then click one of the messages.\n      ![Webhook Logs](img/ngrok_logs_hygraph.png)\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Hygraph webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Access [Hygraph](https://app.hygraph.com/) and sign in using your Hygraph account.\n\n1. On the left menu, click **Webhooks**, and click the pencil icon in your webhook tile.\n\n1. On the popup, enter a secret key that is at least 32 characters long in the **Secret key** field, and then click **Update** at the top of the popup screen.\n\n1. Create a traffic policy file named `hygraph_policy.yml`, replacing `{your secret key}` with the value you used in the **Secret key** field:\n\n   ```yaml\n   on_http_request:\n     - name: \"Verify Hygraph requests\"\n       actions:\n         - type: verify-webhook\n           config:\n             provider: \"graphcms\"\n             secret: \"{your secret key}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file hygraph_policy.yml\n   ```\n\n1. On the Hygraph home page, create a new asset.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "Hygraph Webhooks"
			}
		  ],
		  "metadata": {
			"name": "hygraph",
			"description": "",
			"excerpt": "",
			"title": "Hygraph"
		  }
		},
		{
		  "name": "instagram",
		  "path": "/integrations/instagram",
		  "docs": [
			{
			  "path": "/integrations/instagram/webhooks",
			  "frontMatter": {
				"description": "Develop and test Instagram webhooks from localhost",
				"title": "Instagram Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Instagram webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm run startFacebook`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000 --url myexample.ngrok.app`\n1. [Configure Instagram webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Instagram by using Webhooks.\nInstagram webhooks can be used to notify an external application whenever specific events occur in your Instagram account.\n\nBy integrating ngrok with Instagram, you can:\n\n- **Develop and test Instagram webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Instagram** in real-time via the inspection UI and API.\n- **Modify and Replay Instagram Webhook requests** with a single click and without spending time reproducing events manually in your Instagram account.\n- **Secure your app with Instagram validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm run startFacebook\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n**Note:** This integration requires an ngrok Pro or Enterprise license because Facebook validates your ngrok domain and certificate.\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com), click **Your Authtoken**, and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n\n1. On the left menu, expand **Universal Gateway** and then click **Domains**.\n   **Tip:** If you don't have an ngrok Pro or Enterprise license, sign up for one by clicking **Update Subscription** and follow the subscribe procedure.\n\n1. On the **Domains** page, click **+ Create Domain** or **+ New Domain**.\n\n1. In the **Domain** pane, provide a value for the **Domain** field (i.e. `myexample.ngrok.app`), and then click **Continue**.\n   ![ngrok New Domain](/img/integrations/ngrok_new_domain.png)\n   **Tip**: Make sure your domain is available.\n\n1. Close the **Start a Tunnel** pane and then close the **Domain** pane.\n\n1. Start ngrok by running the following command in a terminal on your local desktop:\n\n   ```bash\n   ngrok http 3000 --url myexample.ngrok.app\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Facebook).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel_domain.png)\n\n## **Step 3**: Integrate Instagram \n\nTo register a webhook on your Instagram account follow the instructions below:\n\n**Requirements**: You'll need a Facebook page and a Facebook app associated with your Facebook page. Create one before following the rest of these steps.\n\nConnect your Facebook page with your Instagram account by following the instructions below:\n\n1. Access your Facebook account, click on your avatar icon on the top right corner of the page, click **See all profiles**, click **See all Pages**, and then click the name of your page.\n\n1. On the **Manage Page** of your page, expand **Meta Business Suite** on the left menu and then click **Inbox**.\n\n1. On the **Inbox** page, click **Instagram Comments** and then click **Connect account**. Follow the instructions to connect your Instagram account to your Facebook page.\n\nAfter you connect your Instagram account to your Facebook page, follow the instructions below to configure your Instagram webhook:\n\n1. Access the [Meta for Developers](https://developers.facebook.com/) page, and Log in using your Facebook account.\n\n1. On the Developers page, click **My Apps** and then click your app.\n1. On the app dashboard, click **Add Product** on the left menu, and then click **Set up** inside the **Webhooks** tile.\n\n1. On the **Webhooks** page, select **Instagram** from the combo box and then click **Subscribe to this object**.\n\n1. In the **Edit User subscription** popup, for the **Callback URL** field enter the URL provided by the ngrok agent to expose your application to the internet, with `/webhooks` at the end (i.e. `https://myexample.ngrok.app/webhooks`).\n   ![Callback URL](img/ngrok_url_configuration_instagram.png)\n\n1. Enter `12345` for the **Verify token** field, click **No** on the **Include values** slider to turn it to **Yes**, and then click **Verify and save**.\n\n1. After you add a webhook to Instagram, Instagram will submit a validation post request to your application through ngrok. Confirm your localhost app receives the validation get request and logs `WEBHOOK_VERIFIED` in the terminal.\n\n1. Back to the **Webhooks** page, make sure the **Instagram** object is selected and then click **Subscribe** to the **comments** field.\n   **Tip**: You can subscribe to multiple fields within the **Instagram** object, as well as select other objects to subscribe to. For each of them, you provide the same URL.\n\n1. Click **Test** for the **comments** field, click **Send to My Server** and confirm your localhost app receives the test post request.\n\n1. On the top of your app's page, make sure **App Mode** is **Live**.\n\n### Run Webhooks with Instagram and ngrok\n\nDepending on the object and the field you subscribe to, Instagram sends different request body contents.\n\nBecause you selected the **comments** field, you can test the integration by commenting on a post on your Instagram account:\n\n1. Access your Instagram account, open a story, enter a comment and then post the comment.\n\nConfirm your localhost app receives a message and logs both headers and body in the terminal.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Instagram webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Access the [Meta for Developers](https://developers.facebook.com/) page, log in using your Instagram account, and then click **My Apps** in the top right corner.\n\n1. On the Developers page, expand **Settings** on the left menu and then click **Basic**.\n\n1. In the **Basic Settings** page, click **Show** to reveal the **App secret** value and copy this value.\n\n1. Create a traffic policy file named `instagram_policy.yml`, replacing `{your app secret}` with the value you have copied before:\n\n   ```yaml\n   on_http_request:\n     - name: \"Instagram Webhooks\"\n       actions:\n         - type: \"webhook-validation\"\n           config:\n             provider: facebook_graph_api\n             secret: \"{your app secret}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file instagram_policy.yml\n   ```\n\n1. Access the Instagram page you have assigned to your webhook and send a message to another Instagram user.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "Instagram Webhooks"
			}
		  ],
		  "metadata": {
			"name": "instagram",
			"description": "",
			"excerpt": "",
			"title": "Instagram"
		  }
		},
		{
		  "name": "intercom",
		  "path": "/integrations/intercom",
		  "docs": [
			{
			  "path": "/integrations/intercom/webhooks",
			  "frontMatter": {
				"description": "Develop and test Intercom webhooks from localhost",
				"title": "Intercom Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Intercom webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Intercom webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Intercom by using Webhooks.\nIntercom webhooks can be used to notify an external application whenever specific events occur in your Intercom account.\n\nBy integrating ngrok with Intercom, you can:\n\n- **Develop and test Intercom webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Intercom** in real-time via the inspection UI and API.\n- **Modify and Replay Intercom Webhook requests** with a single click and without spending time reproducing events manually in your Intercom account.\n- **Secure your app with Intercom validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Intercom).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Intercom \n\nTo register a webhook on your Intercom account follow the instructions below:\n\n1. Access the [Intercom Home](https://app.intercom.com/) page, and sign in using your Intercom account.\n\n1. On the left menu, click your avatar icon and then click **Settings**.\n   **Tip**: The avatar icon is below the **What's new** bell icon. If your avatar icon doesn't appear, zoom out on the page.\n\n1. In the **Settings** menu, expand the **Apps & Integrations** section and then click **Developer Hub**.\n   **Tip**: If the **Developer Guidelines** popup appears, accept the guidelines by clicking **Accept and Continue**.\n\n1. In the **Developer Hub** page, click **New App**.\n\n1. In the **New app** popup window, provide a name for the app, select the appropriate workspace in which you work, keep **Internal integration** selected, and then click **Create app**.\n\n1. In your app page, click **Webhooks** under the **Configure** section of the left menu.\n\n1. In the **Your request endpoint URL** field enter the URL provided by the ngrok agent to expose your application to the internet (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![Your request endpoint URL](img/ngrok_url_configuration_intercom.png)\n\n1. In the **Webhook topics**, select **contact.user.created** and then click **Save**.\n\n   After you add a webhook to your Intercom account, Intercom will submit a test post request to your application through ngrok.\n   Confirm your localhost app receives this test notification in the terminal.\n\n1. Optionally, in the Intercom **Webhooks** page, you can click **Send a test request** to resend this test post request to your application.\n\n### Run Webhooks with Intercom and ngrok\n\nBecause you've selected the **contact.user.created** event, you can trigger new calls from Intercom to your application by following the instructions below:\n\n1. In the same browser, access [Intercom Home](https://app.intercom.com/) page, and then click the **Contacts** icon.\n\n1. On the left menu, click **New**, click **New users or leads**, and then click **Create new user**.\n\n1. In the **Create a new user** popup window, provide a **Name**, an **Email**, a **User UI**, and then click **Create a user**.\n\nConfirm your localhost app receives the create user event notification and logs both headers and body in the terminal.\n\n**Tip:** Intercom sends different request body contents depending on the event you select during the webhook registration.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Intercom webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Access the Intercom **Developer Hub** page, click your app name, and then click **Basic information** on the left menu.\n\n1. In the **Basic information** page, copy the **Client secret** value.\n\n1. Create a traffic policy file named `intercom_policy.yml`, replacing `{your client secret}` with the value you copied before:\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: intercom\n             secret: \"{your client secret}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file intercom_policy.yml\n   ```\n\n1. Access the [Intercom Home](https://app.intercom.com/) page and create a new contact.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "Intercom Webhooks"
			}
		  ],
		  "metadata": {
			"name": "intercom",
			"description": "",
			"excerpt": "",
			"title": "Intercom"
		  }
		},
		{
		  "name": "jumpcloud",
		  "path": "/integrations/jumpcloud",
		  "docs": [
			{
			  "path": "/integrations/jumpcloud/sso-oidc",
			  "frontMatter": {
				"title": "JumpCloud Endpoint SSO (OpenID Connect)",
				"description": "Use JumpCloud OIDC to secure access to ngrok endpoints"
			  },
			  "content": "\nimport Disclaimer from \"/snippets/integrations/_endpoint-sso-disclaimer.mdx\";\n\n<Disclaimer />\n<Tip>\n**TL;DR**\n\n\n\nTo secure access to ngrok with JumpCloud Single Sign-On using OpenID Connect:\n\n1. [Configure JumpCloud SSO](#configure-jumpcloud)\n1. [Configure ngrok](#configure-ngrok)\n1. [Test access to ngrok with JumpCloud SSO](#test-sso)\n</Tip>\n\nThis article details how to configure JumpCloud as the primary Identity Provider for ngrok tunnels.\nBy integrating JumpCloud SSO with ngrok, you can:\n\n- **Restrict access to ngrok tunnels** only to users authenticated via JumpCloud\n- **Use JumpCloud security policies and MFA authenticators**.\n- **Use JumpCloud's Dashboard to facilitate access to ngrok apps**.\n\n## Supported Features\n\nThe ngrok integration with JumpCloud supports:\n\n- **SP-Initiated SSO**: In this mode, users access ngrok edges and tunnels and are redirected to JumpCloud for authentication.\n\n## Requirements\n\nTo configure ngrok tunnels with JumpCloud, you must have:\n\n- a JumpCloud account with administrative rights to create apps\n- an [ngrok Enterprise Account](https://ngrok.com/pricing) with an authtoken or admin access to configure edges with OpenID Connect.\n\n## Configuration Steps\n\nTo integrate ngrok with JumpCloud SSO, you will need to:\n\n1. Configure JumpCloud with the ngrok app\n1. Configure ngrok with the SSO settings provided by JumpCloud\n\n## **Step 1**: Configure JumpCloud \n\n### Add the ngrok App in JumpCloud\n\n1. Access the [JumpCloud Console](https://console.jumpcloud.com/), and sign in using your JumpCloud administrator account.\n\n1. On the left menu, click **SSO**, click **Get Started** or **+ Add New Application**, and then click **Custom OIDC App**.\n\n1. On the **New Application** popup, enter `ngrok oidc` in the **Display Label** field.\n\n1. Click the **SSO** tab, enter `https://idp.ngrok.com/oauth2/callback` in the **Redirect URIs** field, select **Client Secret Basic** as the **Client Authentication Type**, and enter the URL provided by the ngrok agent to expose your application to the internet in the **Login URL** (i.e. `https://myexample.ngrok.app`).\n   ![JumpCloud configuration](img/ngrok_url_configuration_jumpcloud.png)\n\n1. Click **Activate**.\n1. On the **Application Saved** popup, copy the value of both the **Client ID** and the **Client Secret** fields, and then click **Got It**.\n\n### Grant access to JumpCloud users\n\nJumpCloud allows administrators to restrict access to SSO apps — such as ngrok — via user group assignments. By default, apps created in JumpCloud have no group assignments — in other words, nobody can use JumpCloud SSO to access ngrok until you assign a group to the app.\n\nTo assign JumpCloud groups to the ngrok app:\n\n1. On the left menu of the [JumpCloud Console](https://console.jumpcloud.com/), click **SOO** and click the ngrok custom OIDC app you created.\n\n1. On the app popup, click the **User Groups** tab, click the checkbox of the **All Users** group, and then click **Save**.\n   **Tip**: Make sure to add JumpCloud users to this group when you create or manage users that need access to the ngrok app.\n\n## **Step 2**: Configure ngrok \n\nngrok can leverage JumpCloud SSO in two ways:\n\n- From the ngrok CLI (using the `--oidc` parameter)\n- From the ngrok dashboard\n\n### **Option 1**: ngrok CLI\n\n> **Note:** For this tutorial, we assume you have an app running locally (i.e., on localhost:3000) with the ngrok client installed.\n\n1. Launch a terminal\n\n1. Enter the following command to launch an ngrok tunnel with JumpCloud SSO:\n\n   ```bash\n   ngrok http 3000 --oidc=JUMPCLOUD_OAUTH_URL \\\n   --oidc-client-id=JUMPCLOUD_CLIENT_ID \\\n   --oidc-client-secret=JUMPCLOUD_CLIENT_SECRET \\\n   ```\n\n   **Note**: Replace the following with values:\n   - JUMPCLOUD_OAUTH_URL: Your JumpCloud OIDC base URL (i.e. `https://oauth.id.jumpcloud.com/`).\n   - JUMPCLOUD_CLIENT_ID: The client id you copied from JumpCloud.\n   - JUMPCLOUD_CLIENT_SECRET: The client secret you copied from JumpCloud.\n\n   Alternatively, add the `--url YOUR_DOMAIN` argument to get your custom URL, replacing `YOUR_DOMAIN` with your URL of preference.\n\n1. Copy the URL available next to **Forwarding** (for example, `https://jumpcloud-sso-test.ngrok.app`).\n\n1. Skip to **Step 3**\n\n### **Option 2**: ngrok Edge\n\nTo configure an edge with JumpCloud:\n\n1. Access the [ngrok Dashboard](https://dashboard.ngrok.com/) and sign in using your ngrok account.\n\n1. On the left menu, click **Universal Gateway** and then click **Edges**.\n\n1. If you don't have an edge already set to add JumpCloud SSO, create a test edge:\n   - Click **+ New Edge**.\n   - Click **Create HTTPS Edge**.\n   - Click the **pencil icon** next to \"no description\", enter `Edge with JumpCloud SSO OIDC` as the edge name and click **Save**.\n\n1. On the edge settings menu, click **OIDC**.\n\n1. Click **Begin setup** and enter the following values into the fields:\n   ![JumpCloud config in ngrok](img/jumpcloud-1.png)\n   - **Issuer URL**: Your JumpCloud OIDC base URL (i.e. `https://oauth.id.jumpcloud.com/`).\n   - **Client ID**: The client id you copied from JumpCloud.\n   - **Client Secret**: The client secret you copied from JumpCloud.\n\n1. Click **Save** at the top, and then click the left arrow to go back to the **Edges** page.\n\n1. Launch a tunnel connected to your JumpCloud edge:\n<Tip>\n**Note**\n\n\nFor this step, we assume you have an app running locally (i.e. on localhost:3000) with the ngrok client installed.\n</Tip>\n\n1.  Click **Start a tunnel**.\n\n1.  Click the **copy icon** next to the tunnel command.\n    ![tunnel config](img/jumpcloud-2.png)\n\n1.  Launch a tunnel:\n    - Launch a terminal.\n    - Paste the command but replace `http://localhost:80` with your localhost app address (i.e., `http://localhost:3000`).\n    - Click **Enter** and an ngrok tunnel associated with your edge configuration will launch.\n\n1.  To confirm that the tunnel is connected to your edge:\n    - Return to the ngrok dashboard\n    - Close the **Start a tunnel** and the **Tunnel group** tabs\n    - Refresh the test edge page. Under traffic, You will see the message _You have 1 tunnel online. Start additional tunnels to begin load balancing._\n      ![tunnel confirmed](img/jumpcloud-3.png)\n\n1.  In the test edge, copy the **endpoint URL**. (You use this URL to test the JumpCloud Authentication)\n    ![tunnel url](img/jumpcloud-4.png)\n\n## Step 3: Test the integration \n\n1. In your browser, launch an incognito window.\n\n1. Access your ngrok tunnel (i.e., `https://jumpcloud-sso-test.ngrok.app` or using the copied endpoint URL).\n\n1. You should be prompted to log in with your JumpCloud credentials.\n\n1. After logging in, you should be able to see your web app.\n",
			  "contentTitle": "JumpCloud Endpoint SSO (OpenID Connect)"
			},
			{
			  "path": "/integrations/jumpcloud/sso-saml",
			  "frontMatter": {
				"description": "Use JumpCloud SAML to secure access to ngrok endpoints",
				"title": "JumpCloud SSO (SAML)"
			  },
			  "content": "import Disclaimer from \"/snippets/integrations/_endpoint-sso-disclaimer.mdx\";\n\n<Disclaimer />\n<Tip>\n**TL;DR**\n\n\n\nTo secure access to ngrok with JumpCloud Single Sign-On using SAML:\n\n1. [Configure JumpCloud SSO](#configure-jumpcloud)\n1. [Configure ngrok](#configure-ngrok)\n1. [Test access to ngrok with JumpCloud SSO](#test-sso)\n</Tip>\n\nThis article details how to configure JumpCloud as the primary Identity Provider for ngrok tunnels.\nBy integrating JumpCloud SSO with ngrok, you can:\n\n- **Restrict access to ngrok tunnels** only to users authenticated via JumpCloud\n- **Use JumpCloud security policies and MFA authenticators**.\n- **Use JumpCloud's Dashboard to facilitate access to ngrok apps**.\n\n## Requirements\n\nTo configure ngrok tunnels with JumpCloud, you must have:\n\n- an JumpCloud account with administrative rights to create apps\n- an [ngrok Enterprise Account](https://ngrok.com/pricing) with an authtoken or admin access to configure edges with SAML.\n\n## Configuration Steps\n\nTo integrate ngrok with JumpCloud SSO, you will need to:\n\n1. Configure JumpCloud with the ngrok app\n1. Configure ngrok with the SSO settings provided by JumpCloud\n\n## **Step 1**: Configure JumpCloud \n\n1. Access the [JumpCloud Console](https://console.jumpcloud.com/), and sign in using your JumpCloud administrator account.\n\n1. On the left menu, click **SSO**, click **Get Started** or **+ Add New Application**, and then click **Custom SAML App**.\n\n1. On the **New Application** popup, enter `ngrok saml` in the **Display Label** field.\n\n1. Click the **SSO** tab, enter `https://ngrok-jumpcloud` in the **IdP Entity ID** field, enter temporary values (i.e., `https://temporary`) in both the **SP Entity ID** and the **ACS URL** fields, and then click **activate**.\n\n### **Step 2**: Download the IdP metadata \n\n1. On the **SSO** page of the [JumpCloud Console](https://console.jumpcloud.com/), click your **Custom SAML App**, click the **SSO** tab, click **Export Metadata**, and then save the XML file on your desktop.\n\n### **Step 3**: Configure ngrok \n\nTo configure an edge with JumpCloud:\n\n1. Access the [ngrok Dashboard](https://dashboard.ngrok.com/) and sign in using your ngrok account.\n\n1. On the left menu, click **Universal Gateway** and then click **Edges**.\n\n1. If you don't have an edge already set to add JumpCloud SSO, create a test edge:\n   - Click **+ New Edge**.\n   - Click **Create HTTPS Edge**.\n   - Click the **pencil icon** next to \"no description\", enter `Edge with JumpCloud SSO SAML` as the edge name, and click **Save**.\n\n1. On the edge settings menu, click **SAML**.\n\n1. On the **SAML** page, click **Begin setup**, click **Upload XML**, and then open the XML metadata file you downloaded from JumpCloud (See [Download the IdP metadata](#idp-metadata)).\n   ![JumpCloud config in ngrok](img/jumpcloud-5.png)\n\n1. Click **Save** at the top.\n\n### **Step 4**: Download the SP metadata \n\n1. On the **SAML** page of your [ngrok edge](https://dashboard.ngrok.com/edges), click the three dots close to the **SP Metadata** field, click **Download XML File**, and then save the XML file on your desktop.\n\n### **Step 5**: Link JumpCloud with ngrok \n\n1. Access the [JumpCloud Console](https://console.jumpcloud.com/), click **SSO**, click your **Custom SAML App**, click the **SSO** tab, click **Upload Metadata**, and then open the XML metadata file you downloaded from ngrok (See [Download the SP metadata](#sp-metadata)).\n   ![JumpCloud config in ngrok](img/jumpcloud-6.png)\n\n1. Click **Save**.\n\n### **Step 6**: Start a Tunnel \n\n1. Access the [ngrok edges page](https://dashboard.ngrok.com/edges), click your edge, and then click **Start a tunnel**.\n<Tip>\n**Note**\n\n\nFor this step, we assume you have an app running locally (i.e. on localhost:3000) with the ngrok client installed.\n</Tip>\n\n1. Click the **copy icon** next to the tunnel command.\n   ![tunnel config](img/jumpcloud-2.png)\n\n1. Launch a tunnel:\n   - Launch a terminal.\n   - Paste the command but replace `http://localhost:80` with your localhost app address (i.e., `http://localhost:3000`).\n   - Click **Enter** and an ngrok tunnel associated with your edge configuration will launch.\n\n1. To confirm that the tunnel is connected to your edge:\n   - Return to the ngrok dashboard\n   - Close the **Start a tunnel** and the **Tunnel group** tabs\n   - Refresh the test edge page. Under traffic, You will see the message _You have 1 tunnel online. Start additional tunnels to begin load balancing._\n     ![tunnel confirmed](img/jumpcloud-3.png)\n\n1. In the test edge, copy the **endpoint URL**. (You use this URL to test the JumpCloud Authentication)\n   ![tunnel url](img/jumpcloud-4.png)\n\n## Grant access to JumpCloud users \n\nJumpCloud allows administrators to restrict access to SSO apps — such as ngrok — via user group assignments. By default, apps created in JumpCloud have no group assignments — in other words, nobody can use JumpCloud SSO to access ngrok until you assign a group to the app.\n\nTo assign JumpCloud groups to the ngrok app:\n\n1. On the left menu of the [JumpCloud Console](https://console.jumpcloud.com/), click **SOO** and click the ngrok custom SAML app you created.\n\n1. On the app popup, click the **User Groups** tab, click the checkbox of the **All Users** group, and then click **Save**.\n   **Tip**: Make sure to add JumpCloud users to this group when you create or manage users that need access to the ngrok app.\n\n## Test the integration \n\n1. In your browser, launch an incognito window.\n\n1. Access your ngrok tunnel (i.e., `https://jumpcloud-sso-test.ngrok.app` or using the copied endpoint URL).\n\n1. You should be prompted to log in with your JumpCloud credentials.\n\n1. After logging in, you should be able to see your web app.\n",
			  "contentTitle": "JumpCloud SSO (SAML)"
			}
		  ],
		  "metadata": {
			"name": "jumpcloud",
			"description": "",
			"excerpt": "",
			"title": "JumpCloud"
		  }
		},
		{
		  "name": "launchdarkly",
		  "path": "/integrations/launchdarkly",
		  "docs": [
			{
			  "path": "/integrations/launchdarkly/webhooks",
			  "frontMatter": {
				"description": "Develop and test LaunchDarkly webhooks from localhost",
				"title": "LaunchDarkly Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate LaunchDarkly webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure LaunchDarkly webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with LaunchDarkly by using Webhooks.\nLaunchDarkly webhooks can be used to notify an external application whenever specific events occur in your LaunchDarkly account.\n\nBy integrating ngrok with LaunchDarkly, you can:\n\n- **Develop and test LaunchDarkly webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from LaunchDarkly** in real-time via the inspection UI and API.\n- **Modify and Replay LaunchDarkly Webhook requests** with a single click and without spending time reproducing events manually in your LaunchDarkly account.\n- **Secure your app with LaunchDarkly validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with LaunchDarkly).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate LaunchDarkly \n\nTo register a webhook on your LaunchDarkly account follow the instructions below:\n\n1. Access the [LaunchDarkly App](https://app.launchdarkly.com/) and sign in using your LaunchDarkly account.\n\n1. On the left menu, click **Integrations**.\n\n1. On the **Integrations** page, search for `webhooks` and then click **Add integration** for the **Webhooks** tile.\n\n1. On the **Create a new webhook** popup, enter a name in the **NAME** field, and enter the URL provided by the ngrok agent to expose your application to the internet in the **URL** field (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![URL](img/ngrok_url_configuration_launchdarkly.png)\n\n1. On the **Create a new webhook** popup, click **Sign this webhook** and copy the value of the **Secret** provided by LaunchDarkly.\n   **Tip**: You will use the **Secret** value later to add more security to your webhook calls. See [Secure webhook requests](#security).\n\n1. Click the **I have read and agree to the Integration Terms and Conditions** checkbox, and then click **Save settings**.\n\nAfter you save the webhook, LaunchDarkly sends a request to your application. Confirm your localhost app receives the POST notification and logs both headers and body in the terminal.\n\n### Run Webhooks with LaunchDarkly and ngrok\n\nLaunchDarkly sends different request body contents depending on the event that is being triggered.\nYou can trigger new calls from LaunchDarkly to your application by following the instructions below.\n\n1. On the LaunchDarkly dashboard, click **Segments** on the left menu and then click **Create segment**.\n\n1. On the **Create a segment** popup, enter a **Name** for the segment, and then click **Save segment**.\n\n   Confirm your localhost app receives the create-project event notification and logs both headers and body in the terminal.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your LaunchDarkly webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Create a traffic policy file named `launchdarkly_policy.yml`, replacing `{your webhook secret}` with the value you have copied before (See [Integrate ngrok and LaunchDarkly.](#setup-webhook)):\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: launch_darkly\n             secret: \"{your webhook secret}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file launchdarkly_policy.yml\n   ```\n\n1. Access the [LaunchDarkly App](https://app.launchdarkly.com/) and create a new segment.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "LaunchDarkly Webhooks"
			}
		  ],
		  "metadata": {
			"name": "launchdarkly",
			"description": "",
			"excerpt": "",
			"title": "LaunchDarkly"
		  }
		},
		{
		  "name": "linkedin",
		  "path": "/integrations/linkedin",
		  "docs": [
			{
			  "path": "/integrations/linkedin/oauth",
			  "frontMatter": {
				"description": "Authenticate users with LinkedIn OAuth",
				"title": "LinkedIn"
			  },
			  "content": "import Linkedin from \"/snippets/traffic-policy/actions/oauth/examples/custom-linkedin-example.mdx\";\nimport UpdatePolicyInstructions from \"/snippets/traffic-policy/actions/oauth/update-policy/update-policy-instructions.mdx\";\n\n\n\n## Creating a custom LinkedIn OAuth application\n\nThe step-by-step instructions below follow LinkedIn's documentation on [setting up OAuth 2.0](https://learn.microsoft.com/en-us/linkedin/shared/authentication/authorization-code-flow?tabs=HTTPS1#step-1-configure-your-application) for a web application.\n\n### Create credentials for ngrok\n\n1.  Navigate to the [LinkedIn Developer Portal](https://developer.linkedin.com/), sign in, click **My apps** on the top menu, and then click **Create app**.\n\n2.  Enter **App name**, select a **LinkedIn Page**, enter the **Privacy policy URL** in the corresponding fields, and then click **Create app**.\n\n3.  On the app page, click the **Auth** tab and make note of both the **Client ID** and **Client Secret** values.\n\n4.  Click the pencil icon for the **Authorized redirect URLs** in the **OAuth 2.0 settings** section, add the ngrok oauth callback URL (i.e. `https://idp.ngrok.com/oauth2/callback`), and then click **Update**.\n\n    ![](/img/howto/oauth/1-linkedin-register.png)\n\n5.  Click the **Products** tab, and then click **Request access** for **Sign In with LinkedIn using OpenID Connect**.\n\n    ![](/img/howto/oauth/2-linkedin-add-products.png)\n\n### Update your ngrok endpoint traffic policy\n\n<UpdatePolicyInstructions policySnippet={<Linkedin />} />\n\n### Additional application setup information\n\n- [Authorization Code Flow](https://learn.microsoft.com/en-us/linkedin/shared/authentication/authorization-code-flow)\n",
			  "contentTitle": "LinkedIn"
			}
		  ],
		  "metadata": {
			"name": "linkedin",
			"description": "",
			"title": "LinkedIn"
		  }
		},
		{
		  "name": "linkerd",
		  "path": "/integrations/linkerd",
		  "docs": [
			{
			  "path": "/integrations/linkerd/k8s",
			  "frontMatter": {
				"description": "Set up a local cluster to demonstrate how to use the ngrok Kubernetes Operator with Linkerd.",
				"title": "Ingress to a microservices-based application connected via Linkerd's service mesh"
			  },
			  "content": "---\n\nThe ngrok Kubernetes Operator is the official controller for adding secure public ingress and middleware execution to your Kubernetes applications with ngrok's cloud service. With ngrok, you can manage and secure traffic to your applications at every stage of the development lifecycle while also benefiting from simpler configurations, security, and edge acceleration.\n\nLinkerd is an open source [service mesh](https://linkerd.io/what-is-a-service-mesh/#), which is a set of network proxies that handle communications between microservices to add in observability, security, and reliability at the platform level, rather than the application level, of your cloud native infrastructure. For example, Linkerd enables mutual TLS (mTLS) between microservices, which ensures confidentiality (encryption) and authenticity (identity validation) on both sides of the connection. After you deploy Linkerd's control plane, you can then install extensions for additional functionality, like a dashboard for debugging errors, exploring workloads, and more.\n\nWhen integrated, the ngrok Kubernetes Operator and Linkerd abstract complexity away from your entire networking stack (both internal and external traffic), while giving you access to additional monitoring features and more resiliency.\n\nUsing this guide, you will launch a local cluster (or use an existing local/remote cluster) to mesh a microservices-based application with Linkerd, and leverage ngrok to route public traffic through an encrypted tunnel to your cluster.\n\n## What you'll need\n\n- An existing remote or local Kubernetes cluster _OR_ the [minikube CLI](https://minikube.sigs.k8s.io/docs/start/)\n  installed locally to create a new testing cluster.\n- The [Linkerd 2.x CLI](https://linkerd.io/2.14/getting-started/#step-1-install-the-cli) installed locally with either\n  the helper script, Homebrew, or by downloading the binary in your `$PATH`.\n- An [ngrok account](https://ngrok.com/signup).\n- [kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl/) and [Helm\n  3.0.0+](https://helm.sh/docs/intro/install/) installed on your local\n  workstation.\n- The [ngrok Kubernetes Operator](/k8s/) installed on\n  your cluster.\n- A reserved domain, which you can get in the ngrok\n  [dashboard](https://dashboard.ngrok.com/domains) or with the [ngrok\n  API](/api/resources/reserved-domains/).\n  - You can choose from an ngrok subdomain or bring your own custom branded\n    domain, like `https://api.example.com`.\n  - We'll refer to this domain as `<NGROK_DOMAIN>`.\n\n## Set up a local development cluster \n\n1. Create a local Kubernetes cluster with minikube. You will assign it a profile named `ngrok-linkerd` with `-p`, and for the best compatibility with Linkerd, you will use the `containerd` [container runtime](https://minikube.sigs.k8s.io/docs/runtimes/).\n\n   ```bash\n   minikube start -p ngrok-linkerd --container-runtime=containerd\n   ```\n\n   <Tip>\n\n   If your OS does not support containerd, you can run minikube without specifying the container runtime.\n\n   ```bash\n   minikube start -p ngrok-linkerd\n   ```\n\n   If minikube defaults to using the `docker` runtime, you will likely see an error related to root privileges when installing Linkerd to your cluster. The error includes a workaround to let you install Linkerd despite using the `docker` runtime.\n\n   </Tip>\n\n1. Use `kubectl` to verify your local cluster is running properly.\n\n   ```bash\n   kubectl get namespaces\n\n   NAME              STATUS   AGE\n   default           Active   72s\n   kube-node-lease   Active   72s\n   kube-public       Active   72s\n   kube-system       Active   72s\n   ```\n\n## Deploy Linkerd's service mesh to your cluster \n\n1. Verify your Linkerd CLI is working correctly with `linkerd version`, which should display the same output as below. The `Server version: unavailable` is expected at this point.\n\n   ```bash\n   linkerd version\n   Client version: stable-2.14.2\n   Server version: unavailable\n   ```\n\n1. Validate that your Kubernetes cluster is ready to deploy Linkerd with `linkerd check --pre`. You should see the following output at the end:\n\n   ```bash\n   linkerd check --pre\n   ...\n   Status check results are √\n   ```\n\n1. Generate and deploy the Kubernetes manifests required to run Linkerd on your cluster, starting with the CRDs.\n\n   ```bash\n   linkerd install --crds | kubectl apply -f -\n   ```\n\n   Followed by the core resources.\n\n   ```bash\n   linkerd install | kubectl apply -f -\n   ```\n\n1. Check that Linkerd installed correctly with `linkerd check`. You should a number of successful checks in your terminal output, with a final verification at the end.\n\n   ```bash\n   linkerd check\n   ...\n   Status check results are √\n   ```\n\n   <Note>\n\n   These steps are based on the [Linkerd documentation](https://linkerd.io/2.14/getting-started/), which we encourage you to explore for additional details on the value of a service mesh, additional Linkerd features, and more.\n\n   </Note>\n\n## Deploy an example microservices-based application \n\nTo demonstrate how Linkerd and the ngrok Kubernetes Operator integrate to add additional observability, security, and reliability into your cluster, you'll deploy the [Emojivoto](https://github.com/BuoyantIO/emojivoto) demo application, which was developed by Buoyant, the company that originally developed Linkerd.\n\n1. Create an ngrok static subdomain for ingress if you don't have one already. Navigate to the [**Domains**\n   section](https://dashboard.ngrok.com/domains) of the ngrok dashboard and click **Create Domain** or **New\n   Domain**. This static subdomain will be your `NGROK_DOMAIN` for the remainder of this guide.\n\n   By creating a subdomain on the ngrok Edge, you provide a public route to accept HTTP, HTTPS, and TLS traffic.\n\n1. Deploy Emojivoto to the `emojivoto` namespace.\n\n   ```bash\n   curl --proto '=https' --tlsv1.2 -sSfL https://run.linkerd.io/emojivoto.yml \\\n     | kubectl apply -f -\n   ```\n\n1. Add meshing capabilities by injecting Linkerd's data plane proxies into each pod with a rolling deploy. The following command retrieves all the deployments created in the previous step, injects the Linkerd proxy, and then redeploys each pod.\n\n   ```bash\n   kubectl get -n emojivoto deploy -o yaml \\\n     | linkerd inject - \\\n     | kubectl apply -f -\n   ```\n\n1. Verify your data plane with `linkerd -n emojivoto check --proxy`, which should end with a healthy status check.\n\n   ```bash\n   linkerd -n emojivoto check --proxy\n   ...\n   Status check results are √\n   ```\n\n1. Create a new `emojivoto-ingress.yml` file and add the [following YAML content](https://linkerd.io/2.14/tasks/using-ingress/#ngrok), which defines the ngrok Kubernetes Operator for routing traffic arriving on your `NGROK_DOMAIN` to the `web-svc` deployment, which you created when deploying Emojivoto.\n\n   <Tip>\n\n   Make sure you edit line `9` of the manifest below, which contains the `NGROK_DOMAIN` variable, with your ngrok subdomain. It should look something like `one-two-three.ngrok.app`.\n\n   </Tip>\n\n   ```yaml showLineNumbers\n   apiVersion: networking.k8s.io/v1\n   kind: Ingress\n   metadata:\n     name: emojivoto-ingress\n     namespace: emojivoto\n   spec:\n     ingressClassName: ngrok\n     rules:\n       - host: <NGROK_DOMAIN>\n         http:\n           paths:\n             - path: /\n               pathType: Prefix\n               backend:\n                 service:\n                   name: web-svc\n                   port:\n                     number: 80\n   ```\n\n1. Apply the `emojivoto-ingress.yaml` manifest you just created.\n\n   ```bash\n   kubectl apply -f emojivoto-ingress.yaml\n   ```\n\n   Give your cluster a few moments to launch the necessary resources and for ngrok's cloud service to pick up the new tunnel created by the ngrok Kubernetes Operator.\n\n   <Tip>\n\n   If you see an error when applying the manifest, double-check that you've updated the `NGROK_DOMAIN` value and try again.\n\n   </Tip>\n\n1. Access your Emojivoto application by navigating to the your ngrok domain, e.g. `https://one-two-three.ngrok.app`, in your browser.\n\n   ![Viewing the Emojivoto application](img/emojivoto.png)\n\n## Add Linkerd's dashboard to verify meshing and mTLS \n\nGiven that one of the key benefits of a service mesh is increased observability, and the inherent security enhancements that come from mTLS connections between your microservices, you'll want to double-check that your deployments and pods are properly meshed.\n\n1. Install the Linkerd dashboard.\n\n   ```bash\n   linkerd viz install | kubectl apply -f -\n   ```\n\n1. To [verify mTLS](https://linkerd.io/2.14/tasks/validating-your-traffic/), first restart all pods in the `emojivoto` namespace to enable [\"tapping\"](https://linkerd.io/2.14/reference/cli/viz/#tap).\n\n   ```bash\n   kubectl -n emojivoto rollout restart deploy\n   ```\n\n1. Then use Linkerd's tap feature, with `linkerd viz -n emojivoto tap deploy`, to pipe the traffic stream from all pods in the `emojivoto` namespace to your terminal. Because the Emojivoto app is designed to automatically generate traffic, you'll see a consistent stream of requests.\n\n   ```bash\n   linkerd viz -n emojivoto tap deploy\n   ...\n   req id=0:11 proxy=out src=10.244.0.15:43706 dst=10.244.0.2:8080 tls=true :method=POST :authority=emoji-svc.emojivoto:8080 :path=/emojivoto.v1.EmojiService/ListAll\n   ```\n\n   You should see `tls=true` in all of these requests between these pods. You can also use `kubectl get pods -o wide` to see the IP address of each pod, which lets you verify the source and destination of each request. For example, the request shown above is the `web-svc` service sending a POST request, with mTLS enabled, to the `emoji-svc` service, which maintains and stores the votes database.\n\n1. Run `linkerd viz dashboard &`, which will open the Linkerd dashboard in your browser. The default dashboard shows various \"golden metrics\" like real-time success rates, traffic (in requests per second), and latencies per namespace. The first column after the **Namespace** also displays the number of meshed pods in that namespace, providing additional verification that your services and pods are meshed via Linkerd.\n\n   Some of the automatically generated traffic is designed to fail, causing the errors you'll see throughout—and showcasing how you can use Linkerd's dashboard to debug issues with pod-to-pod communications.\n\n   ![Viewing the Linkerd dashboard for the Emojivoto services](img/linkerd_metrics.png)\n\n## What's next?\n\nYou've now integrated a demo microservices application with Linkerd's service mesh and ngrok's Kubernetes Operator to add multiple new layers of security and reliability without having to worry about configuring middleware, network interfaces, [mTLS](https://linkerd.io/2.14/features/automatic-mtls/), or deploying new [monitoring services](https://linkerd.io/2.14/features/telemetry/) for observing the external behavior of your code.\n\nAfter deploying this local demo, you have a few options for moving forward.\n\n### Clean up\n\nIf you're looking to clean up from the work you've done for this local demo, stop and delete your minikube cluster with the `minikube` CLI:\n\n```\nminikube stop -p ngrok-linkerd\nminikube delete -p ngrok-linkerd\n```\n\nThen remove the Linkerd CLI from your local workstation:\n\n```bash\nrm -rf $HOME/.linkerd2\n```\n\n### Extend your ngrok Kubernetes Operator and Linkerd integration\n\nTo bring this integration to a production-grade Kubernetes environment and a real-world application, you will want to explore [installing Linkerd with Helm](https://linkerd.io/2.14/tasks/install-helm/) and Buoyant's official [Linkerd Production Handbook](https://docs.buoyant.io/runbook/getting-started/).\n\nEven in more complex scenarios, you can follow the same procedures listed above to install the ngrok Kubernetes Operator and configure an Ingress service, letting ngrok's cloud service handle routing and middleware execution for simplicity, global load balancing, and automatic encryption.\n\nLearn more about the ngrok Kubernetes Operator, or contribute to its ongoing development, by checking out the [GitHub repository](https://github.com/ngrok/ngrok-operator) and the [project-specific documentation](https://github.com/ngrok/ngrok-operator/tree/main/docs).\n",
			  "contentTitle": "Ingress to a microservices-based application connected via Linkerd's service mesh"
			}
		  ],
		  "metadata": {
			"name": "linkerd",
			"description": "",
			"excerpt": "",
			"title": "Linkerd"
		  }
		},
		{
		  "name": "linode",
		  "path": "/integrations/linode",
		  "docs": [
			{
			  "path": "/integrations/linode/gslb",
			  "frontMatter": {
				"description": "In this guide, you'll learn how to layer load balancing between three or more globally-distributed, cloud-based virtual machines in Linode.",
				"title": "Use ngrok's Global Server Load Balancing with Linode"
			  },
			  "content": "<Tip>\n**TL;DR**\n\n\n\nTo use ngrok's [Global Load Balancer](/universal-gateway/global-load-balancer/) with Linode:\n\n1. [Reserve your ngrok domain](#reserve-domain)\n2. [Create your ngrok Edge](#create-edge)\n3. [Create Tunnel Group backends for your VMs](#create-tunnel-group-backends)\n4. [Create a Weighted Backend and Route on your Edge](#create-weighted-backend)\n5. [Install the ngrok agent and an example workload on each VM](#install-ngrok-agent)\n6. [Test out ngrok's Global Server Load Balancing](#test-gslb)\n7. [(optional) Enable the Traffic Policy module for API gateway features](#enable-traffic-policy)\n</Tip>\n\nIn this guide, you'll learn how to layer ngrok's [Global Load Balancer](/universal-gateway/global-load-balancer/) (GSLB) on top of a VM-based deployment on Linode.\n\nGLSB improves the performance and resiliency for your apps by distributing traffic to the nearest Point of Prescence (PoP) and the upstream service. Unlike a traditional GSLB deployment, ngrok automatically routes traffic without requiring you to deploy new infrastructure, provision IPs, or change DNS records. All you have to do is configure your ngrok agents for a simple path to high availability, horizontal scaling, A/B testing, and more.\n\nngrok's GSLB even works on top of Linode's internal load balancing mechanism, NodeBalancer, for additional global resiliency and latency improvements.\n<Warning>\n**This how-to guide requires:**\n\n\n\n1. An [ngrok account](https://ngrok.com/signup).\n1. An account with [Linode](https://login.linode.com/signup).\n1. Three Ubuntu 24.04 virtual machines (VMs) in three globally-distributed regions (e.g. Atlanta, Osaka, and Frankfurt):\n   - Hostnames should be unique, ideally using the location of the datacenter (e.g. `atlanta`, `osaka`, and `frankfurt`).\n   - [Docker](https://docs.docker.com/engine/install/) and [Docker Compose](https://docs.docker.com/compose/install/) installed on each VM.\n</Warning>\n\n## **Step 1**: Reserve your ngrok domain \n\nYour first task is to [generate a new API key](https://dashboard.ngrok.com/api) in the ngrok dashboard. Make sure you save the API key before you close the modal, because it won't be displayed again.\n\nTo simplify authenticating your account with the ngrok API, export the API key on your local workstation.\n\n```bash\nexport NGROK_API_KEY=<YOUR-API-KEY>\n```\n\nNext, create a domain that is a subdomain of an [ngrok-managed domain](/universal-gateway/domains/). For an example deployment like this, `YOUR_COMPANY-linode-gslb.ngrok.app` would work great.\n\nYou can reserve your domain in one of two ways: with the [ngrok API](/api/), or in the [ngrok dashboard](https://dashboard.ngrok.com/domains).\n\nWith the ngrok API, reserve your domain on the [`/reserved_domains` endpoint](/api/resources/reserved-domains/) using the `NGROK_API_KEY` and `NGROK_DOMAIN` variables you exported.\n\n```bash\ncurl \\\n  -X POST https://api.ngrok.com/reserved_domains \\\n  -H \"Authorization: Bearer ${NGROK_API_KEY}\" \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Ngrok-Version: 2\" \\\n  -d '{\"description\":\"Linode Load Balancing\",\"domain\":\"'${NGROK_DOMAIN}'\"}'\n```\n\nExport a variable for your new domain, which will be used in following API calls.\n\n```bash\nexport NGROK_DOMAIN=<YOUR-NGROK-DOMAIN>\n```\n<Tip>\n**Custom domains within ngrok**\n\n\n\nUsing CNAMEs, ngrok can host an endpoint on your domain while also managing the complete TLS certificate lifecycle on your behalf. If you'd prefer to use a custom domain rather than an ngrok-managed one, [follow our guide](/universal-gateway/custom-domains/) to set up your DNS and replace your custom domain in the `export` command above.\n</Tip>\n\n## **Step 2**: Create your ngrok Edge \n\nWith ngrok, you can manage multiple endpoints, such as domains or routes, using a single [Edge](/universal-gateway/edges/) configuration in the cloud. Edges let you update endpoints without taking them offline, connect multiple ngrok agents to a single endpoint, apply modules like [OAuth](/traffic-policy/actions/oauth/) or [IP restrictions](/traffic-policy/actions/restrict-ips/), and balance the load between your upstream services.\n\nSend a `POST` request to the [`/edges/https` endpoint](/api/resources/edges-https/), replacing the `description` field below as needed.\n\n```bash\ncurl \\\n  -X POST https://api.ngrok.com/edges/https \\\n  -H \"Authorization: Bearer ${NGROK_API_KEY}\" \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Ngrok-Version: 2\" \\\n  -d '{\"description\":\"Linode HTTPS Edge\",\"hostports\":[\"'${NGROK_DOMAIN}':443\"]}'\n```\n\nExport the `id` in this response, which begins with `edghts_...`, for future use.\n\n```bash\nexport EDGE_ID=edghts_...\n```\n\n## **Step 3**: Create Tunnel Group backends for your VMs \n\nNext, create a Tunnel Group for each of your globally-distributed VMs. A Tunnel Group uses one or more labels to identify which agent-created tunnels it should attach to a given Edge and route, which you'll create in a moment.\n\nYou'll need to run the API request to the [`/backends/tunnel_group` endpoint](/api/resources/tunnel-group-backends/) for **each** of your VMs, changing the `<LOCATION_NAME>` with the name of the city or region of the data center where they're deployed (e.g. `atlanta`, `osaka`, and `frankfurt`).\n\n```bash\ncurl \\\n  -X POST https://api.ngrok.com/backends/tunnel_group \\\n  -H \"Authorization: Bearer ${NGROK_API_KEY}\" \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Ngrok-Version: 2\" \\\n  -d '{\"labels\":{\"dc\":\"<LOCATION_NAME>\"}}'\n```\n\nExport the `id`, beginning with `bkdtg_...`, returned from the ngrok API for each Tunnel Group you create.\n\n```bash\nexport BACKEND_ID_01=bkdtg_...\nexport BACKEND_ID_02=bkdtg_...\nexport BACKEND_ID_03=bkdtg_...\n```\n\n## **Step 4**: Create a Weighted Backend and Route on your Edge \n\nWith a [Weighted Backend](/universal-gateway/edges#weighted), you can specify custom weights for Tunnel Group backends, shaping precisely how to load-balance traffic across the infrastructure you've distributed around the globe. Without a Weighted Backend, the ngrok Edge and [GSLB](/universal-gateway/global-load-balancer/) will always favor the Point of Presence (PoP) and VM nearest the user making requests.\n\nCreate a Weighted Backend at the [`/backends/weighted` endpoint](/api/resources/weighted-backends/) using your Tunnel Group backend `id`s exported from the previous step. The `curl` command below creates equal weighting for your backends, but you can use integers between `0-10000` to configure precise proportional weights.\n\n```bash\ncurl \\\n\t-X POST https://api.ngrok.com/backends/weighted \\\n\t-H \"Authorization: Bearer ${NGROK_API_KEY}\" \\\n\t-H \"Content-Type: application/json\" \\\n\t-H \"Ngrok-Version: 2\" \\\n\t-d '{\"backends\":{\"'${BACKEND_ID_01}'\":1,\"'${BACKEND_ID_02}'\":1,\"'${BACKEND_ID_03}'\":1}}'\n```\n\nExport the `id` of your new Weighted Backend.\n\n```bash\nexport WEIGHTED_BACKEND_ID=bkdwd_...\n```\n\nYou can now create an catch-all Edge Route at `/` using your Weighted Backend using the [`/edges/https/{EDGE_ID}/routes` endpoint](/api/resources/edges-https-routes/).\n\n```bash\ncurl \\\n  -X POST \"https://api.ngrok.com/edges/https/${EDGE_ID}/routes\" \\\n  -H \"Authorization: Bearer ${NGROK_API_KEY}\" \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Ngrok-Version: 2\" \\\n  -d '{\"match\":\"/\",\"match_type\":\"path_prefix\",\"backend\":{\"enabled\":true,\"backend_id\":\"'${WEIGHTED_BACKEND_ID}'\"}}' \\\n```\n\nYou now have an active domain, Edge, Tunnel Group backends, a Weighted Backend, and a route. If you open a new tab and navigate to `https://<YOUR_NGROK_DOMAIN>` right now, you'll see an error message from ngrok. You've successfully reserved a domain and created an edge, but don't yet have ngrok agents or active tunnels.\n\n![An example of an ngrok domain and Edge with no matching tunnels](img/edge-no-tunnels.png)\n\nYou can also navigate to the [Edges dashboard](https://dashboard.ngrok.com/edges) to see your Edge configuration, on the domain you reserved, with no online tunnels.\n\n![alt text](img/edge-dashboard-no-tunnels.png)\n\n## **Step 5**: Install the ngrok agent and an example workload on each VM \n\nTo get some tunnels online and quickly see how ngrok's GSLB works, you'll use an [example API deployment](https://github.com/joelhans/ngrok-vps-gslb-demo). This demo deployment has four parts:\n\n1. A straightforward Go-based API with a single endpoint at `/api`, which returns a randomly generated UUID and the machine's `hostname`, which should reflect the regions of your VMs.\n2. A `Dockerfile` for containerizing said Go-based API.\n3. A `docker-compose.yml` file for starting the API container and a containerized edition of the ngrok agent on the same network.\n4. A `ngrok.yml` [agent configuration file](/agent/config/v3/) to connect the agent to your ngrok account and one of the Tunnel Group backends you previously created.\n\nRepeat the following steps on **each** VM:\n\n1. Clone the demo repository.\n\n   ```bash\n   git clone https://github.com/joelhans/ngrok-vps-gslb-demo\n   cd ngrok-vps-gslb-demo\n   ```\n\n2. Edit the `ngrok.yml` [ngrok agent configuration file](/agent/config/) with your `<YOUR_NGROK_AUTHTOKEN>`, which you can in the [ngrok dashboard](https://dashboard.ngrok.com/get-started/your-authtoken)&mdash;note that it's different from the API key you created in the first step. Next, edit the `<LOCATION_NAME>` for that VM, matching the labels you created in [step 3](#create-tunnel-group-backends) (e.g. `atlanta`, `osaka`, and `frankfurt`).\n\n   ```yaml\n   version: 2\n   authtoken: <YOUR_NGROK_AUTHTOKEN>\n   log_level: debug\n   log: stdout\n   tunnels:\n     vps-demo:\n       addr: 5000\n       labels:\n         - dc=<LOCATION_NAME>\n   ```\n\n3. Build and start the containerized API deployment, passing the hostname of the VM to the hostname of the Docker container.\n\n   ```bash\n   HOSTNAME=$(hostname -f) docker compose up -d\n   ```\n\n## **Step 6**: Test out ngrok's Global Server Load Balancing \n\nngrk is now load-balancing your single API endpoint across all three distributed VMs.\n\nYou can now ping your demo API at `<YOUR_NGROK_DOMAIN>/api` to see which backend responds.\n\n```bash\ncurl ${NGROK_DOMAIN}/api\n[{\"id\":\"1cf26269-ce8b-4f16-91f1-fdf7bc6d9e80\",\"dc\":\"atlanta\"}]\n```\n\nTo see the weighting in action, try a batch of `curl` requests.\n\n```bash\nfor i in `seq 1 20`; do \\\n  curl  \\\n    -X GET \"${NGROK_DOMAIN}/api\" ; \\\n  done\n```\n\nYou should see each VM respond with similar frequency:\n\n```json skip-validation\n[{\"id\":\"c46bdbd9-b588-4ffa-8018-d299d0918bbc\",\"dc\":\"osaka\"}]\n[{\"id\":\"dce5a46e-15af-4479-a073-8fbc7f0097c5\",\"dc\":\"atlanta\"}]\n[{\"id\":\"ecc6451c-bc25-43bd-8cb6-a162f019adf3\",\"dc\":\"frankfurt\"}]\n[{\"id\":\"ecc6451c-bc25-43bd-8cb6-a162f019adf3\",\"dc\":\"frankfurt\"}]\n[{\"id\":\"ecc6451c-bc25-43bd-8cb6-a162f019adf3\",\"dc\":\"frankfurt\"}]\n[{\"id\":\"c46bdbd9-b588-4ffa-8018-d299d0918bbc\",\"dc\":\"osaka\"}]\n[{\"id\":\"c46bdbd9-b588-4ffa-8018-d299d0918bbc\",\"dc\":\"osaka\"}]\n[{\"id\":\"ecc6451c-bc25-43bd-8cb6-a162f019adf3\",\"dc\":\"frankfurt\"}]\n[{\"id\":\"ecc6451c-bc25-43bd-8cb6-a162f019adf3\",\"dc\":\"frankfurt\"}]\n[{\"id\":\"dce5a46e-15af-4479-a073-8fbc7f0097c5\",\"dc\":\"atlanta\"}]\n[{\"id\":\"ecc6451c-bc25-43bd-8cb6-a162f019adf3\",\"dc\":\"frankfurt\"}]\n[{\"id\":\"dce5a46e-15af-4479-a073-8fbc7f0097c5\",\"dc\":\"atlanta\"}]\n[{\"id\":\"dce5a46e-15af-4479-a073-8fbc7f0097c5\",\"dc\":\"atlanta\"}]\n[{\"id\":\"c46bdbd9-b588-4ffa-8018-d299d0918bbc\",\"dc\":\"osaka\"}]\n[{\"id\":\"ecc6451c-bc25-43bd-8cb6-a162f019adf3\",\"dc\":\"frankfurt\"}]\n[{\"id\":\"c46bdbd9-b588-4ffa-8018-d299d0918bbc\",\"dc\":\"osaka\"}]\n[{\"id\":\"c46bdbd9-b588-4ffa-8018-d299d0918bbc\",\"dc\":\"osaka\"}]\n[{\"id\":\"dce5a46e-15af-4479-a073-8fbc7f0097c5\",\"dc\":\"atlanta\"}]\n[{\"id\":\"ecc6451c-bc25-43bd-8cb6-a162f019adf3\",\"dc\":\"frankfurt\"}]\n[{\"id\":\"dce5a46e-15af-4479-a073-8fbc7f0097c5\",\"dc\":\"atlanta\"}]\n```\n\nTo confirm your global load balancing, head over to the [Edges dashboard](https://dashboard.ngrok.com/edges) once again to confirm your tunnels are online and weighted equally at 33.33%.\n\n![The ngrok dashboard showing online, weighted tunnels](img/edge-weighted-active.png)\n\n## **Step 7** (optional): Enable the Traffic Policy module for API gateway features \n\nYour demo API is already globally load-balanced, but if you want to extend your ngrok usage even further, you can enable one or more [Traffic Policy modules](/traffic-policy/) on your Edge to control traffic or establish standards for how your upstream services are accessed.\n\nYou have two options:\n\n- Using `curl` with the ngrok API's [`/edges/https/{edge_id}/routes/{id}/policy` endpoint](/api/resources/edge-route-traffic-policy-module/). For this, you will need find the `id` of the catch-all Route you created in [step 4](#create-weighted-backend).\n\n  ```bash\n  export ROUTE_ID=edghtsrt_...\n\n  curl \\\n    -X PUT \"https://api.ngrok.com/edges/https/${EDGE_ID}/routes/${ROUTE_ID}/policy\" \\\n    -H \"Authorization: Bearer ${NGROK_API_KEY}\" \\\n    -H \"Content-Type: application/json\" \\\n    -H \"Ngrok-Version: 2\" \\\n    -d '{\"enabled\":true,\"on_http_response\":[{\"actions\":[{\"type\":\"add-headers\",\"config\":{\"headers\": {\"is-ngrok\": \"1\",\"country\": \"${.ngrok.geo.country_code}\"}}}],\"name\":\"Add ngrok headers\"}]}'\n  ```\n\n- In the Traffic Policy module section of your [Edge](https://dashboard.ngrok.com/edges) in the ngrok dashboard, where you can click the **Edit Traffic Policy** button and add the YAML below.\n\n  ```yaml\n  on_http_request: []\n  on_http_response:\n    - expressions: []\n      name: Add ngrok headers\n      actions:\n        - type: add-headers\n          config:\n            headers:\n              country: ${.ngrok.geo.country_code}\n              is-ngrok: \"1\"\n  ```\n\nWhen you request your API again, the response includes the `country` (with the appropriate code for where you're generating said request) and `is-ngrok` headers.\n\n```bash\ncurl -s -I -X GET https://<YOUR_NGROK_DOMAIN>/api\n\nHTTP/2 200\ncontent-type: application/json\ncountry: US\ndate: Wed, 22 May 2024 14:53:42 GMT\nis-ngrok: 1\ncontent-length: 63\n```\n\n## What's next?\n\nYou now have a globally load-balanced API deployment using three Linode VMs, three ngrok agents, three secure tunnels, one ngrok Edge, and a single convenient endpoint for your users.\n\nFrom here, you have many options for extending your use of ngrok's GSLB:\n\n- Spread the load from user requests further by creating additional deployments in more regions, adding a new Tunnel Group backend for each, and [patching](/api/resources/weighted-backends/#update-weighted-backend) your Weighted Backend configuration.\n- Add more VMs to a region with existing deployments and add them to the relevant Tunnel Group backend. Ngrok will then load-balance between those specific VMs equally _after_ weighting requests on the Backend level.\n  - Alternatively, use [NodeBalancers](https://www.linode.com/docs/products/networking/nodebalancers/) for\n- Provision a Kubernetes cluster with the same workload and the ngrok [Kubernetes Operator](/k8s/) to load-balance between VM- and Kubernetes-based deployments of the same API or application.\n- Use your Weighted Backend for A/B tests by changing your deployments between different regions and VMs.\n\nIf you're eager to learn more about ngrok's GSLB, give the following a read:\n\n- [Introducing Always-On Global Server Load Balancing](https://ngrok.com/blog-post/what-is-gslb-global-server-load-balancing)\n- [What is global server load balancing (GSLB)?](https://ngrok.com/blog-post/what-is-gslb-global-server-load-balancing)\n",
			  "contentTitle": "Use ngrok's Global Server Load Balancing with Linode"
			}
		  ],
		  "metadata": {
			"name": "linode",
			"description": "",
			"excerpt": "",
			"title": "Linode"
		  }
		},
		{
		  "name": "mailchimp",
		  "path": "/integrations/mailchimp",
		  "docs": [
			{
			  "path": "/integrations/mailchimp/webhooks",
			  "frontMatter": {
				"description": "Develop and test Mailchimp webhooks from localhost",
				"title": "Mailchimp Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Mailchimp webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Mailchimp webhooks with your ngrok URL.](#setup-webhook)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Mailchimp by using Webhooks.\nMailchimp webhooks can be used to notify an external application whenever specific events occur in your Mailchimp account.\n\nBy integrating ngrok with Mailchimp, you can:\n\n- **Develop and test Mailchimp webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Mailchimp** in real-time via the inspection UI and API.\n- **Modify and Replay Mailchimp Webhook requests** with a single click and without spending time reproducing events manually in your Mailchimp account.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Mailchimp).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Mailchimp \n\nTo register a webhook on your Mailchimp account follow the instructions below:\n\n1. Access [Mailchimp](https://https://mailchimp.com/) and sign in using your Mailchimp account.\n\n1. On the Mailchimp **Home** page, click **Audience** on the left menu and then click **Audience dashboard**.\n\n1. On the **Audience** page, click **Manage Audience** and then click **Settings**.\n\n1. On the **Settings** page, click **Webhooks** and then click **Create New Webhook**.\n\n1. On the **Create new webhook** page, enter the URL provided by the ngrok agent to expose your application to the internet in the **Callback URL** field (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`) and then click **Save**.\n   ![URL to Publish](img/ngrok_url_configuration_mailchimp.png)\n\n   Confirm your localhost app receives a GET request and logs both headers and body in the terminal.\n\n### Run Webhooks with Mailchimp and ngrok\n\nMailchimp sends different request body contents depending on the audience you register your webhook, as well as depending on the event taking place.\nYou can trigger new calls from Mailchimp to your application by following the instructions below.\n\n1. On the Mailchimp **Home** page, click **Audience** on the left menu and then click **All Contacts**.\n\n1. On the **Audience** page, click **Add contacts** and then click **Add a subscriber**.\n\n1. On the **Add subscriber** page, enter a valid email address in the **Email Address** field, click the **This person gave me permission to email them** checkbox, and then click **Subscribe**.\n   **Note**: If you don't have the email address on your contact list, you need to import this contact.\n\n   Confirm your localhost app receives the create-project event notification and logs both headers and body in the terminal.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n",
			  "contentTitle": "Mailchimp Webhooks"
			}
		  ],
		  "metadata": {
			"name": "mailchimp",
			"description": "",
			"excerpt": "",
			"title": "Mailchimp"
		  }
		},
		{
		  "name": "mailgun",
		  "path": "/integrations/mailgun",
		  "docs": [
			{
			  "path": "/integrations/mailgun/webhooks",
			  "frontMatter": {
				"description": "Develop and test Mailgun webhooks from localhost",
				"title": "Mailgun Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Mailgun webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Mailgun webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Mailgun by using Webhooks.\nMailgun webhooks can be used to notify an external application whenever specific events occur in your Mailgun account.\n\nBy integrating ngrok with Mailgun, you can:\n\n- **Develop and test Mailgun webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Mailgun** in real-time via the inspection UI and API.\n- **Modify and Replay Mailgun Webhook requests** with a single click and without spending time reproducing events manually in your Mailgun account.\n- **Secure your app with Mailgun validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Mailgun).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Mailgun \n\nTo register a webhook on your Mailgun account follow the instructions below:\n\n1. Access [Mailgun](https://app.mailgun.com/) and sign in using your Mailgun account.\n\n1. On the **Dashboard** page, click **Sending** in the left menu, click **Webhooks** and then click **Add webhook**.\n\n1. On the **New webhook** popup, select **Delivered Messages** in the **Event type** field, and enter the URL provided by the ngrok agent to expose your application to the internet in the **URL** field (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![Webhook URL](img/ngrok_url_configuration_mailgun.png)\n\n1. Click **Create webhook**.\n\nTo test the webhook follow the instructions below:\n\n1. On the **Webhooks** page, select **Delivered Messages** in the **Event type** combobox, enter the ngrok URL in the **URL to test** field, and then click **Test webhook**.\n\n   Confirm your localhost app receives the event notification and logs both headers and body in the terminal. Also, confirm a **Response** message appears on the **Webhooks** page.\n\n### Run Webhooks with Mailgun and ngrok\n\nMailgun sends different request body contents depending on the event that is being triggered.\nYou can trigger new calls from Mailgun to your application by following the instructions below.\n\n1. Access the [Mailgun Dashboard](https://app.mailgun.com/), click **Sending** in the left menu, and then click **Overview**.\n\n1. Enter a valid email address in the **Email address** field in the **Authorized Recipients** section, and then click **Save Recipient**.\n\nVerify the recipient receives an email from Mailgun asking to agree to receive emails from your Mailgun account, click the **I Agree** link in the body of the email and then click **Yes**.\n\n1. In the [Mailgun Dashboard](https://app.mailgun.com/), click **Select** in the **API** tile and choose one of the options that appears on the screen to send emails. For example, open a terminal window and run the following command using curl:\n\n   ```bash\n   curl --location --request POST 'API_BASE_URL/messages' \\\n   --header 'Authorization: Basic api:API_KEY' \\\n   --form 'from=\"mailgun@YOUR_DOMAIN\"' \\\n   --form 'to=\"AUTHORIZED_RECIPIENT\"' \\\n   --form 'subject=\"Hello from Mailgun\"' \\\n   --form 'text=\"Testing some Mailgun email!\"'\n   ```\n\n   **Note**: Replace the following with values from your Mailgun account:\n   - API_BASE_URL: **API base URL** value that appears on the **Overview** page.\n   - API_KEY: **API Key** value that appears on the **Overview** page.\n   - YOUR_DOMAIN: Find your domain by clicking **Domains** in the left menu.\n   - AUTHORIZED_RECIPIENT: the **Email address** you registered as an authorized recipient.\n\n   Confirm your localhost app receives an event notification and logs both headers and body in the terminal.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Mailgun webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Access [Mailgun](https://app.mailgun.com/) and sign in using your Mailgun account.\n\n1. On the **Dashboard** page, click **Sending** in the left menu and then click **Webhooks**.\n\n1. On the **Webhooks** page, click the eye icon near the **HTTP webhook signing key** text and copy the value that appears.\n\n1. Create a traffic policy file named `mailgun_policy.yml`, replacing `{webhook signing key}` with the value you have copied before:\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: mailgun\n             secret: \"{webhook signing key}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file mailgun_policy.yml\n   ```\n\n1. Access [Mailgun](https://app.mailgun.com/) and send a new email to an authorized recipient.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "Mailgun Webhooks"
			}
		  ],
		  "metadata": {
			"name": "mailgun",
			"description": "",
			"excerpt": "",
			"title": "Mailgun"
		  }
		},
		{
		  "name": "microk8s",
		  "path": "/integrations/microk8s",
		  "docs": [
			{
			  "path": "/integrations/microk8s/k8s",
			  "frontMatter": {
				"title": "Kubernetes ingress to apps/APIs on clusters managed by Canonical MicroK8s",
				"description": "Add ingress to any app running in a Kubernetes cluster managed by Canonical Microk8s using the ngrok Kubernetes Operator."
			  },
			  "content": "\nUsing this guide, you'll launch a new Kubernetes cluster with Canonical's open-source [MicroK8s](https://microk8s.io/) and use the [ngrok Kubernetes Operator](https://marketplace.digitalocean.com/apps/ngrok-ingress-controller) to securely ingress public traffic to an example app using the **new [Kubernetes Gateway API](https://kubernetes.io/docs/concepts/services-networking/gateway/)**.\n\nAlong the way, you'll learn enough to leverage MicroK8s in your next Kubernetes deployment—local development, embedded in a CI environment, and production workloads—with simple and secure traffic ingress.\n\nHere is what you'll be building with:\n\n- The **[ngrok Kubernetes Operator](https://ngrok.com/blog-post/ngrok-k8s)**: ngrok's official controller for adding secure public ingress and middleware execution to your Kubernetes apps with ngrok's cloud service. With ngrok, you can manage and secure app traffic at every stage of the development lifecycle while benefiting from simpler configurations, security, and edge acceleration.\n- The **Kubernetes Gateway API**: This new API, which made generally available in [October 2023](https://kubernetes.io/blog/2023/10/31/gateway-api-ga/), is a role-oriented mechanism for provisioning load-balancing infrastructure and routing traffic. The Gateway API does not replace \"traditional\" [Operators](https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/)—both are available for production usage, but the Gateway API may be better suited for large organizations with defined roles for managing Kubernetes services, cluster operators vs. application developers.\n- **Canonical MicroK8s**: An open-source system for low-ops, minimal, production-ready Kubernetes. MicroK8s' single-node configuration, small size, and customizeable footprint lets you use it for local development, in minimal environments like GitHub's CI/CD, or using Kubernetes on IoT hardware.\n\n## What you'll need\n\n- [MicroK8s](https://microk8s.io/) installed locally.\n- An [ngrok account](https://ngrok.com/signup).\n- [kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl/) and [Helm\n  3.0.0+](https://helm.sh/docs/intro/install/) installed on your local\n  workstation.\n- The [ngrok Kubernetes Operator](/k8s/installation/helm/) installed on\n  your cluster.\n- A reserved domain, which you can get in the ngrok\n  [dashboard](https://dashboard.ngrok.com/domains) or with the [ngrok\n  API](/api/resources/reserved-domains/).\n  - You can choose from an ngrok subdomain or bring your own custom branded\n    domain, like `https://api.example.com`.\n  - We'll refer to this domain as `<NGROK_DOMAIN>`.\n\n## Deploy a Kubernetes cluster with MicroK8s \n\nStart by deploying a new single-node MicroK8s Kubernetes cluster in your chosen environment. That could be your local workstation, an IoT device, a virtual machine in the cloud, or any system running one of the [42 supported flavors of Linux](https://snapcraft.io/microk8s).\n\n1. Follow the [get started](https://microk8s.io/docs/getting-started) tutorial for MicroK8s to install the binary for your target system.\n\n   Once Microk8s is installed, it automatically deploys a single-node Kubernetes cluster.\n\n1. Run `microk8s status --wait-ready` to check on the state of your MicroK8s cluster.\n\n   ```bash\n   microk8s status --wait-ready\n\n   microk8s is running\n   high-availability: no\n     datastore master nodes: 127.0.0.1:19001\n     datastore standby nodes: none\n   ...\n   ```\n\n   If you see `microk8s is ready`, your new cluster is ready to go!\n\n## Install an example app \n\nNow you need a domain and Kubernetes service to ingress traffic to!\n\n1. If you don't have an ngrok static domain, create one. Navigate to the [**Domains** section](https://dashboard.ngrok.com/domains) of the ngrok dashboard and click **Create Domain** or **New Domain**. This static domain, which will look like `example.ngrok.app`, will be your `NGROK_DOMAIN` for the remainder of this guide.\n\n   Creating a subdomain on the ngrok network provides a public route to accept HTTP, HTTPS, and TLS traffic.\n\n1. Create a new Kubernetes manifest (`2048.yaml`) with the YAML below. This manifest defines the 2048 application service and deployment, then configures the ngrok Kubernetes Operator to connect the `game-2048` service to the ngrok edge via your `NGROK_DOMAIN`.\n\n   ```yaml showLineNumbers\n   apiVersion: v1\n   kind: Service\n   metadata:\n     name: game-2048\n     namespace: default\n   spec:\n     ports:\n       - name: http\n         port: 80\n         targetPort: 80\n     selector:\n       app: game-2048\n   ---\n   apiVersion: apps/v1\n   kind: Deployment\n   metadata:\n     name: game-2048\n     namespace: default\n   spec:\n     replicas: 1\n     selector:\n       matchLabels:\n         app: game-2048\n     template:\n       metadata:\n         labels:\n           app: game-2048\n       spec:\n         containers:\n           - name: backend\n             image: alexwhen/docker-2048\n             ports:\n               - name: http\n                 containerPort: 80\n   ```\n\n1. Apply the `2048.yaml` manifest to your MicroK8s cluster.\n\n   ```bash\n   kubectl apply -f 2048.yaml\n   ```\n\n## Configure the ngrok Kubernetes Operator \n\nWith your example app running alongside the ngrok Kubernetes Operator, you now need to configure the new [Kubernetes Gateway API](/k8s/?k8s-install=gatewayAPI) to route traffic arriving from outside the cluster on `NGROK_DOMAIN` to the `game-2048` service.\n\nYou'll first create a [GatewayClass](https://gateway-api.sigs.k8s.io/api-types/gatewayclass/), which represents a class of cluster-level [Gateways](https://gateway-api.sigs.k8s.io/api-types/gateway/). You'll then configure the Gateway with a listener, and an [HTTPRoute](https://gateway-api.sigs.k8s.io/api-types/httproute/) to specify how the Gateway should route requests.\n\n1. Create a new file called `gatewayclass.yaml` on your workstation with the below YAML:\n\n   ```yaml\n   apiVersion: gateway.networking.k8s.io/v1\n   kind: GatewayClass\n   metadata:\n     name: ngrok\n   spec:\n     controllerName: ngrok.com/gateway-controller\n   ```\n\n1. Install the GatewayClass:\n\n   ```bash\n   kubectl apply -f gatewayclass.yaml\n   ```\n\n1. Create a new file named `2048-gateway.yaml` on your workstation with the below YAML, replacing `<YOUR_NGROK_DOMAIN>`:\n\n   ```yaml showLineNumbers\n   apiVersion: gateway.networking.k8s.io/v1\n   kind: Gateway\n   metadata:\n     name: 2048-gateway\n     namespace: default\n   spec:\n     gatewayClassName: ngrok\n     listeners:\n       - name: 2048-web\n   \t\t\t protocol: HTTPS\n   \t\t\t port: 80\n         hostname: \"<YOUR_NGROK_DOMAIN>\"\n   \t\t\t allowedRoutes:\n   \t\t\t   namespaces:\n   \t\t\t\t   from: Same\n   ---\n   apiVersion: gateway.networking.k8s.io/v1\n   kind: HTTPRoute\n   metadata:\n     name: 2048-route\n     namespace: default\n   spec:\n     parentRefs:\n       - group: gateway.networking.k8s.io\n   \t\t\t kind: Gateway\n         name: 2048-gateway\n         namespace: default\n     hostnames:\n       - \"<YOUR_NGROK_DOMAIN>\"\n     rules:\n       - matches:\n           - path:\n               type: PathPrefix\n               value: /\n         backendRefs:\n           - name: game-2048\n             kind: Service\n             port: 80\n   ```\n\n   This YAML uses the [Gateway API](https://gateway-api.sigs.k8s.io/#introduction) to first define a [Gateway](https://gateway-api.sigs.k8s.io/api-types/gateway) that allows north/south traffic to enter the cluster from external requests, then uses an [HTTPRoute](https://gateway-api.sigs.k8s.io/concepts/api-overview/#httproute) to terminate the connection at the pod running the `game-2048` service.\n\n1. Access your 2048 demo app by navigating to your ngrok domain, e.g. `https://<YOUR_NGROK_DOMAIN>`. ngrok's network\n   and the ngrok Kubernetes Operator routes traffic to your app from any device or external network.\n\n## What's next?\n\nTo track the development of the ngrok Kubernetes Operator and its use of the new Kubernetes Gateway API, check out the [GitHub\nrepository](https://github.com/ngrok/ngrok-operator) and give it a ⭐.\n",
			  "contentTitle": "Kubernetes ingress to apps/APIs on clusters managed by Canonical MicroK8s"
			}
		  ],
		  "metadata": {
			"name": "MicroK8s",
			"description": "",
			"excerpt": "",
			"title": "microk8s"
		  }
		},
		{
		  "name": "microsoft",
		  "path": "/integrations/microsoft",
		  "docs": [
			{
			  "path": "/integrations/microsoft/oauth",
			  "frontMatter": {
				"description": "Authenticate users with Microsoft Entra ID OAuth",
				"title": "Microsoft OAuth"
			  },
			  "content": "import Microsoft from \"/snippets/traffic-policy/actions/oauth/examples/custom-microsoft-example.mdx\";\nimport UpdatePolicyInstructions from \"/snippets/traffic-policy/actions/oauth/update-policy/update-policy-instructions.mdx\";\n\n\n\n## Creating a custom Microsoft OAuth application\n\nStep-by-step instructions below closely follow [Microsoft documentation](https://learn.microsoft.com/en-us/entra/identity-platform/quickstart-register-app) to create a new application for ngrok within the Azure portal.\n\n### Register an application\n\n1.  Sign-in to the [Azure portal](https://portal.azure.com/) then select or [create a tenant](https://learn.microsoft.com/en-us/entra/identity-platform/quickstart-create-new-tenant) for your application.\n2.  Search for \"Microsoft Entra ID\" and select it.\n3.  Select \"App registrations\" on the left hand navigation.\n4.  Select \"New registration\" at the top.\n5.  Enter a name for your application.\n6.  ngrok does not support [**single tenant** applications](https://learn.microsoft.com/en-us/entra/identity-platform/single-and-multi-tenant-apps). Choose supported account types from:\n    - Accounts in any organizational directory (Any Microsoft Entra directory - Multitenant)\n    - Accounts in any organizational directory (Any Microsoft Entra directory - Multitenant) and personal Microsoft accounts (e.g. Skype, Xbox)\n7.  Choose a \"Web\" redirect URI and enter `https://idp.ngrok.com/oauth2/callback`.\n8.  Register your application. The final form should resemble: ![](/img/howto/oauth/1-microsoft-create_app.png)\n\n### Configure your application\n\n1.  When viewing your application, choose \"Overview\" on the left hand navigation.\n2.  Store the \"Application (client) ID\" in the top information section for later. ![](/img/howto/oauth/2-microsoft-app_overview.png)\n3.  Select \"API permissions\" on the left hand navigation.\n4.  Add additional scopes that your application requires and store them for later.\n    - Scopes which require an application review by Microsoft are unsupported.\n    - Scopes that [require admin consent](https://learn.microsoft.com/en-us/entra/identity-platform/permissions-consent-overview#admin-restricted-permissions) prevent tenants' users from authorizing until consent is granted.\n5.  Ensure `User.Read` or a more permissive scope (e.g. `User.Read.All`) is configured for ngrok. Example minimal configuration: ![](/img/howto/oauth/3-microsoft-api_permissions.png)\n6.  Choose \"Certificates and Secrets\" on the left hand navigation.\n7.  Select \"New Client Secret\" at the bottom, name the secret, set an expiration, and hit create.\n8.  Creation is asynchronous. When complete, save the secret from the \"Value\" column (blurred below) for later: ![](/img/howto/oauth/4-microsoft-client_secret.png)\n\n### Update your ngrok endpoint traffic policy\n\n<UpdatePolicyInstructions policySnippet={<Microsoft />} />\n\n### Additional application setup information\n\n- [Creating a Microsoft Entra ID tenant](https://learn.microsoft.com/en-us/entra/identity-platform/quickstart-create-new-tenant)\n- [Permissions and consent](https://learn.microsoft.com/en-us/entra/identity-platform/permissions-consent-overview#admin-restricted-permissions) (restricted permissions)\n- [Graph API User object properties](https://developers.facebook.com/docs/facebook-login/handling-declined-permissions#reprompt) (id, displayName, and mail/userPrincipalName)\n",
			  "contentTitle": "Microsoft OAuth"
			},
			{
			  "path": "/integrations/microsoft/sso-saml",
			  "frontMatter": {
				"description": "Use SAML with Microsoft Entra ID to provide SSO to the ngrok Dashboard",
				"title": "Microsoft Entra ID SSO (SAML)"
			  },
			  "content": "---\n<Tip>\n**TL;DR**\n\n\n\nTo secure access to ngrok Dashboard using Microsoft Entra ID Single Sign-On with SAML:\n\n1. [Configure Microsoft Entra ID SSO](#configure-entra)\n1. [Configure ngrok](#configure-ngrok)\n1. [Test access to ngrok with Microsoft Entra ID SSO](#test-sso)\n</Tip>\n\nThis article details how to configure Microsoft Entra ID as the primary Identity Provider for the ngrok Dashboard.\nBy integrating Microsoft Entra ID SSO with ngrok, you can:\n\n- **Restrict access to the ngrok Dashboard** only to users authenticated via Microsoft Entra ID\n- **Use Microsoft Entra ID's Dashboard to facilitate access to the ngrok app**.\n\n## Requirements\n\nTo configure the ngrok Dashboard with Microsoft Entra ID, you must have:\n\n- an ngrok account with administrative rights to modify the account settings\n- an [ngrok Account](https://ngrok.com/pricing) with access to configure SAML SSO.\n\n## Configuration Steps\n\nTo integrate ngrok with Microsoft Entra ID SSO, you will need to:\n\n1. Configure Microsoft Entra ID with the ngrok app\n1. Configure ngrok with the SSO settings provided by Microsoft Entra ID\n\n## **Step 1**: Configure Microsoft Entra ID \n\n### Create the ngrok App in Microsoft Entra ID\n\n1. Access your Microsoft Entra ID Dashboard as an administrator.\n1. Click **Enterprise Applications**.\n1. Click **New application** > **Create your own application**.\n1. Provide a name for the app (e.g. ngrok Dashboard) and choose the **Non-gallery** option and click **Create**.\n1. Select **Single sign-on**, and then choose **SAML**.\n1. Enter in temporary values for \"Identifier\" and \"Reply URL\" and modify the value of \"Unique User Identifier\" to equal \"user.mail\".\n   1. **Identifier (Entity ID)**: https://temporary\n   1. **Reply URL (Assertion Consumer Service URL)**: https://temporary\n   1. **Unique User Identifier**: user.mail\n<Tip>\n**Note**\n\n\n      This value can differ based upon setup, it is required that this user property value is an email address\n</Tip>\n\n![enter temporary values](img/entra-saml-temp.png)\n\n### Download the IdP metadata\n\n1. From within the **Single sign-on** section on the ngrok Dashboard app, click on the **Download** option for **Federation Metadata XML**. Download the metadata XML.\n\n### Grant access to users and groups\n\nMicrosoft Entra ID allows administrators to restrict access to SSO apps — such as the ngrok Dashboard — via assignments. By default, apps created in Microsoft Entra ID have no assignments — in other words, nobody can use Microsoft Entra ID SSO to access the ngrok Dashboard until you assign them to the app. To assign users and groups to the ngrok Dashboard app:\n\n1. Navigate to the **User and groups** from within the application.\n1. Use the **Add user/group** button to associate groups and users with the ngrok app. **To test the SSO with ngrok, make sure you're assigned to the app**.\n\n## **Step 2**: Configure ngrok \n\n### ngrok Dashboard SSO\n\nTo configure ngrok Dashboard SSO with Microsoft Entra ID:\n\n1. Go to the [ngrok Dashboard](https://dashboard.ngrok.com).\n1. Click **Settings** > **Account**\n1. Within the **Single Sign-On (SSO)** section, click **New Identity Provider** > **New SAML Provider**\n   ![create IdP](img/entra-new-idp.png)\n1. On the SAML Provider settings, provide a **Description** and click **Upload XML**\n1. Select your metadata file saved from the steps above and **Save**\n1. After you save, the SP Metadata will appear. Copy these values into the Microsoft Entra ID ngrok Dashboard app **Single sign-on** settings where temporary values were placed above:\n   ![Update Entra with SP values](img/entra-6.png)\n1. Save the changes in Microsoft Entra ID.\n\n## Step 3: Test the integration \n\n1. Navigate to the Microsoft Entra ID ngrok Dashboard app **Single sign-on** settings.\n1. Scroll to the bottom of the settings and click **Test** > **Test sign in**\n1. You should be redirected to the ngrok Dashboard.\n   1. If the current user is not a member of the ngrok account and JIT is enabled, the user will be prompted to join.\n      ![SSO JIT Prompt](img/entra-7.png)\n   1. If the current user is already a member, they will be successfully authenticated into the ngrok Dashboard.\n",
			  "contentTitle": "Microsoft Entra ID SSO (SAML)"
			}
		  ],
		  "metadata": {
			"name": "microsoft",
			"description": "",
			"title": "Microsoft"
		  }
		},
		{
		  "name": "miniorange",
		  "path": "/integrations/miniorange",
		  "docs": [
			{
			  "path": "/integrations/miniorange/sso-oidc",
			  "frontMatter": {
				"title": "miniOrange Endpoint SSO (OpenID Connect)",
				"description": "Use miniOrange OIDC to secure access to ngrok endpoints"
			  },
			  "content": "\nimport Disclaimer from \"/snippets/integrations/_endpoint-sso-disclaimer.mdx\";\n\n<Disclaimer />\n<Tip>\n**TL;DR**\n\n\n\nTo secure access to ngrok with miniOrange Single Sign-On using OpenID Connect:\n\n1. [Configure miniOrange SSO](#configure-miniorange)\n1. [Configure ngrok](#configure-ngrok)\n1. [Test access to ngrok with miniOrange SSO](#test-sso)\n</Tip>\n\nThis article details how to configure miniOrange as the primary Identity Provider for ngrok tunnels.\nBy integrating miniOrange SSO with ngrok, you can:\n\n- **Restrict access to ngrok tunnels** only to users authenticated via miniOrange.\n- **Use miniOrange security policies and MFA authenticators**.\n- **Use miniOrange's Dashboard to facilitate access to ngrok apps**.\n\n## Supported Features\n\nThe ngrok integration with miniOrange supports:\n\n- **SP-Initiated SSO**: In this mode, users access ngrok edges and tunnels and are redirected to miniOrange for authentication.\n\n## Requirements\n\nTo configure ngrok tunnels with miniOrange, you must have:\n\n- a miniOrange account with administrative rights to create apps.\n- an [ngrok Enterprise Account](https://ngrok.com/pricing) with an authtoken or admin access to configure edges with OpenID Connect.\n\n## Configuration Steps\n\nTo integrate ngrok with miniOrange SSO, you will need to:\n\n1. Configure miniOrange with the ngrok app.\n1. Configure ngrok with the SSO settings provided by miniOrange.\n\n### **Step 1**: Configure miniOrange \n\n1. Access [miniOrange](https://www.miniorange.com/), and sign in using your miniOrange administrator account.\n\n1. On the **Dashboard** page, click **Apps** on the left menu, click **Add Application**, click the **OAUTH/OIDC** tile, and then click the **OAuth2/OpenID Connect** tile.\n\n1. On the **Add App** page, enter `ngrok OIDC` in the **Client Name** field, enter `https://idp.ngrok.com/oauth2/callback` in the **Redirect-URL** field, and then click **Save**.\n   ![miniOrange configuration](img/ngrok_url_configuration_miniorange.png)\n\n1. On the **View Apps** page, click **Select** in the **ngrok OIDC** app line, and then click **Edit**.\n\n1. On the **Edit Application** page, make note of the value of the **Client ID** field, click the **Click to reveal client secret** link, and then make note of the value of the **Client Secret** field.\n\n1. Click **Save**.\n\n1. On the **View Apps** page, click **Select** in the **ngrok** app line, and then click **OAuth Endpoints**.\n\n1. On the **OAuth Endpoints** page, make note of the URL of the **Discovery Endpoints** field.\n\n### **Step 2**: Grant access to miniOrange users\n\nminiOrange allows its users to access OIDC-integrated apps. To create a user follow the instructions below.\n\n1. On the left menu of the [miniOrange Dashboard](https://login.xecurify.com/moas/admin/customer/home), click **Users** and then click **User List**.\n\n1. On the **Users** page, click the **Add User**, enter values for the **Email**, **Username**, **First Name**, **Last Name**, and **Password** field, and then click **Create User**.\n\n### **Step 3**: Configure ngrok \n\nngrok can leverage miniOrange SSO in two ways:\n\n- From the ngrok CLI (using the `--oidc` parameter)\n- From the ngrok dashboard\n\n### **Option 1**: ngrok CLI\n\n> **Note:** For this tutorial, we assume you have an app running locally (i.e., on localhost:3000) with the ngrok client installed.\n\n1. Launch a terminal\n\n1. Enter the following command to launch an ngrok tunnel with miniOrange SSO:\n\n   ```bash\n   ngrok http 3000 --oidc=MINIORANGE_OAUTH_URL \\\n   --oidc-client-id=MINIORANGE_CLIENT_ID \\\n   --oidc-client-secret=MINIORANGE_CLIENT_SECRET \\\n   ```\n\n   **Note**: Replace the following with values:\n   - MINIORANGE_OAUTH_URL: The **Discovery Endpoint** URL you copied from miniOrange, without the `/.well-known/openid-configuration` sufix (i.e. `https://login.xecurify.com/moas/discovery/v2.0/abcd1234`).\n   - MINIORANGE_CLIENT_ID: The client id you copied from miniOrange.\n   - MINIORANGE_CLIENT_SECRET: The client secret you copied from miniOrange.\n\n   Alternatively, add the `--url YOUR_DOMAIN` argument to get your a custom URL, replacing `YOUR_DOMAIN` with your URL of preference.\n\n1. Copy the URL available next to **Forwarding** (for example, `https://miniorange-sso-test.ngrok.app`).\n\n1. Skip to **Step 3**\n\n### **Option 2**: ngrok Edge\n\nTo configure an edge with miniOrange:\n\n1. Access the [ngrok Dashboard](https://dashboard.ngrok.com/) and sign in using your ngrok account.\n\n1. On the left menu, click **Universal Gateway** and then click **Edges**.\n\n1. If you don't have an edge already set to add miniOrange SSO, create a test edge:\n   - Click **+ New Edge**.\n   - Click **Create HTTPS Edge**.\n   - Click the **pencil icon** next to \"no description\", enter `Edge with miniOrange SSO OIDC` as the edge name and click **Save**.\n\n1. On the edge settings menu, click **OIDC**.\n\n1. Click **Begin setup** and enter the following values into the fields:\n   ![miniOrange config in ngrok](img/miniorange-1.png)\n   - **Issuer URL**: The **Discovery Endpoint** URL you copied from miniOrange, without the `/.well-known/openid-configuration` sufix (i.e. `https://login.xecurify.com/moas/discovery/v2.0/abcd1234efG`).\n   - **Client ID**: The client id you copied from miniOrange.\n   - **Client Secret**: The client secret you copied from miniOrange.\n\n1. Click **Save** at the top, and then click the left arrow to go back to the **Edges** page.\n\n### **Step 4**: Start a Tunnel \n\n1. Launch a tunnel connected to your miniOrange edge:\n<Tip>\n**Note**\n\n\nFor this step, we assume you have an app running locally (i.e. on localhost:3000) with the ngrok client installed.\n</Tip>\n\n1.  Click **Start a tunnel**.\n\n1.  Click the **copy icon** next to the tunnel command.\n    ![tunnel config](img/miniorange-2.png)\n\n1.  Launch a tunnel:\n    - Launch a terminal.\n    - Paste the command but replace `http://localhost:80` with your localhost app address (i.e., `http://localhost:3000`).\n    - Click **Enter** and an ngrok tunnel associated with your edge configuration will launch.\n\n1.  To confirm that the tunnel is connected to your edge:\n    - Return to the ngrok dashboard\n    - Close the **Start a tunnel** and the **Tunnel group** tabs\n    - Refresh the test edge page. Under traffic, You will see the message _You have 1 tunnel online. Start additional tunnels to begin load balancing._\n      ![tunnel confirmed](img/miniorange-3.png)\n\n1.  In the test edge, copy the **endpoint URL**. (You use this URL to test the miniOrange Authentication)\n    ![tunnel url](img/miniorange-4.png)\n\n## Test the integration \n\n1. In your browser, launch an incognito window.\n\n1. Access your ngrok tunnel using the copied endpoint URL (i.e., `https://miniorange-sso-test.ngrok.app`).\n\n1. You should be prompted to log in with your miniOrange credentials.\n\n1. After logging in, you should be able to see your web app.\n",
			  "contentTitle": "miniOrange Endpoint SSO (OpenID Connect)"
			},
			{
			  "path": "/integrations/miniorange/sso-saml",
			  "frontMatter": {
				"description": "Use miniOrange SAML to secure access to ngrok endpoints",
				"title": "miniOrange SSO (SAML)"
			  },
			  "content": "import Disclaimer from \"/snippets/integrations/_endpoint-sso-disclaimer.mdx\";\n\n<Disclaimer />\n<Tip>\n**TL;DR**\n\n\n\nTo secure access to ngrok with miniOrange Single Sign-On using SAML:\n\n1. [Configure miniOrange SSO](#configure-miniorange)\n1. [Configure ngrok](#configure-ngrok)\n1. [Test access to ngrok with miniOrange SSO](#test-sso)\n</Tip>\n\nThis article details how to configure miniOrange as the primary Identity Provider for ngrok tunnels.\nBy integrating miniOrange SSO with ngrok, you can:\n\n- **Restrict access to ngrok tunnels** only to users authenticated via miniOrange.\n- **Use miniOrange security policies and MFA authenticators**.\n- **Use miniOrange's Dashboard to facilitate access to ngrok apps**.\n\n## Requirements\n\nTo configure ngrok tunnels with miniOrange, you must have:\n\n- an miniOrange account with administrative rights to create apps.\n- an [ngrok Enterprise Account](https://ngrok.com/pricing) with an authtoken or admin access to configure edges with SAML.\n\n## Configuration Steps\n\nTo integrate ngrok with miniOrange SSO, you will need to:\n\n1. Configure miniOrange with the ngrok app.\n1. Configure ngrok with the SSO settings provided by miniOrange.\n\n### **Step 1**: Configure miniOrange \n\n1. Access [miniOrange](https://www.miniorange.com/), and sign in using your miniOrange administrator account.\n\n1. On the **Dashboard** page, click **Apps** on the left menu, click **Add Application**, click the **SAML/WS-Fed** tile, and then click the **Custom SAML App** tile.\n\n1. On the **Add App** page, enter `ngrok SAML` in the **Custom Application Name** field,\n\n1. Click the **SSO** tab, enter temporary values (i.e., `https://temporary`) in both the **SP Entity ID or Issuer** and the **ACS URL** fields, and then click **Save**.\n\n### **Step 2**: Download the IdP metadata \n\n1. On the **View Apps** page, click **Select** in the **ngrok** app line, and then click **Metadata**.\n\n1. On the **View IDP Metadata** page, click **Show Metadata Details**, click **Download Metadata**, and then save the XML file on your desktop.\n\n### **Step 3**: Configure ngrok \n\nTo configure an edge with miniOrange:\n\n1. Access the [ngrok Dashboard](https://dashboard.ngrok.com/) and sign in using your ngrok account.\n\n1. On the left menu, click **Universal Gateway** and then click **Edges**.\n\n1. If you don't have an edge already set to add miniOrange SSO, create a test edge:\n   - Click **+ New Edge**.\n   - Click **Create HTTPS Edge**.\n   - Click the **pencil icon** next to \"no description\", enter `Edge with miniOrange SSO SAML` as the edge name, and click **Save**.\n\n1. On the edge settings menu, click **SAML**.\n\n1. On the **SAML** page, click **Begin setup**, click **Upload XML**, and then open the XML metadata file you downloaded from miniOrange (See [Download the IdP metadata](#idp-metadata)).\n   ![miniOrange config in ngrok](img/miniorange-5.png)\n\n1. Click **Save** at the top.\n\n### **Step 4**: Download the SP metadata \n\n1. On the **SAML** page of your [ngrok edge](https://dashboard.ngrok.com/edges), click the three dots close to the **SP Metadata** field, click **Download XML File**, and then save the XML file on your desktop.\n\n### **Step 5**: Link miniOrange with ngrok \n\n1. On the [miniOrange Dashboard](https://login.xecurify.com/moas/admin/customer/home), click **Apps** on the left menu, click **Select** in the **ngrok SAML** app line, and then click **Edit**.\n\n1. On the **Edit Application** page, click **Import SP Metadata**, click **File**, open the XML metadata file you downloaded from ngrok (See [Download the SP metadata](#sp-metadata)), and then click **Import**.\n   ![miniOrange config in ngrok](img/miniorange-6.png)\n\n1. On the **Edit Application** page, click **Save**.\n\n### **Step 6**: Start a Tunnel \n\n1. Access the [ngrok edges page](https://dashboard.ngrok.com/edges), click your edge, and then click **Start a tunnel**.\n<Tip>\n**Note**\n\n\nFor this step, we assume you have an app running locally (i.e. on localhost:3000) with the ngrok client installed.\n</Tip>\n\n1. Click the **copy icon** next to the tunnel command.\n   ![tunnel config](img/miniorange-2.png)\n\n1. Launch a tunnel:\n   - Launch a terminal.\n   - Paste the command but replace `http://localhost:80` with your localhost app address (i.e., `http://localhost:3000`).\n   - Click **Enter** and an ngrok tunnel associated with your edge configuration will launch.\n\n1. To confirm that the tunnel is connected to your edge:\n   - Return to the ngrok dashboard\n   - Close the **Start a tunnel** and the **Tunnel group** tabs\n   - Refresh the test edge page. Under traffic, You will see the message _You have 1 tunnel online. Start additional tunnels to begin load balancing._\n     ![tunnel confirmed](img/miniorange-3.png)\n   1. In the test edge, copy the **endpoint URL**. (You use this URL to test the miniOrange Authentication)\n      ![tunnel url](img/miniorange-4.png)\n\n## Grant access to miniOrange users \n\nminiOrange allows its users to access SAML-integrated apps. To create a user follow the instructions below:\n\n1. On the left menu of the [miniOrange Dashboard](https://login.xecurify.com/moas/admin/customer/home), click **Users** and then click **User List**.\n\n1. On the **Users** page, click the **Add User**, enter values for the **Email**, **Username**, **First Name**, **Last Name**, and **Password** field, and then click **Create User**.\n\n## Test the integration \n\n1. In your browser, launch an incognito window with the **Endpoints** URL of your edge.\n\n1. Access your ngrok tunnel using the copied endpoint URL (i.e., `https://miniorange-sso-test.ngrok.app`).\n\n1. You should be prompted to log in with your miniOrange credentials.\n\n1. After logging in, you should be able to see your web app.\n",
			  "contentTitle": "miniOrange SSO (SAML)"
			}
		  ],
		  "metadata": {
			"name": "miniorange",
			"description": "",
			"excerpt": "",
			"title": "miniOrange"
		  }
		},
		{
		  "name": "modern-treasury",
		  "path": "/integrations/modern-treasury",
		  "docs": [
			{
			  "path": "/integrations/modern-treasury/webhooks",
			  "frontMatter": {
				"description": "Develop and test Modern Treasury webhooks from localhost",
				"title": "Modern Treasury Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Modern Treasury webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Modern Treasury webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Modern Treasury by using Webhooks.\nModern Treasury webhooks can be used to notify an external application whenever specific events occur in your Modern Treasury account.\n\nBy integrating ngrok with Modern Treasury, you can:\n\n- **Develop and test Modern Treasury webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Modern Treasury** in real-time via the inspection UI and API.\n- **Modify and Replay Modern Treasury Webhook requests** with a single click and without spending time reproducing events manually in your Modern Treasury account.\n- **Secure your app with Modern Treasury validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Modern Treasury).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Modern Treasury \n\nTo register a webhook on your Modern Treasury account follow the instructions below:\n\n1. Access the [Modern Treasury site](https://app.moderntreasury.com/) and sign in using your Modern Treasury account.\n\n1. On the left menu, click **View Sandbox** to switch to Sandbox mode.\n   **Note**: The Sandbox view provides you with example accounts that allow you to test Modern Treasury functions. If you have an active Modern Treasury account you can follow these steps without switching to Sandbox mode.\n\n1. On the left menu, click **Developers**, click the **Webhooks** tab, and then click **Create New Webhook Endpoint**.\n\n1. On the **New webhook** page, enter the URL provided by the ngrok agent to expose your application to the internet in the **Webhook URL** field (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![Webhook URL](img/ngrok_url_configuration_moderntreasury.png)\n\n1. Make sure **Receive all events** is selected as the **Events to send** option and then click **Save**.\n\n### Run Webhooks with Modern Treasury and ngrok\n\nModern Treasury sends different request body contents depending on the event that is being triggered.\nYou can trigger new calls from Modern Treasury to your application by following the instructions below.\n\n1. Access the [Modern Treasury site](https://app.moderntreasury.com/) and sign in using your Modern Treasury account.\n\n1. On the left menu, click **View Sandbox** to switch to Sandbox.\n   **Note**: The Sandbox view provides you with example accounts that allow you to test Modern Treasury functions. If you have an active Modern Treasury account you can follow these steps without switching to Sandbox view.\n\n1. On the left menu, click **Payments** and then click **Payments Overview**.\n\n1. On the **Payments Overview** page, click **Create New** and then click **Payment Order**.\n\n1. On the **Create Payment Order** page, click **Pay**, select one of the revenue accounts in the **From** field, select one of the counterparties accounts in the **To** field, select **ACH** as the **Payment Method**, enter **$10.00** as the **Amount**, and then click **Create Payment Order**.\n\n   Confirm your localhost app receives event notifications every time the payment gets updated and logs both headers and body in the terminal.\n\nOptionally, you can verify the log of the webhook call in Modern Treasury:\n\n1. On the left menu, click **Developers**, click the **Events** tab, and then click the corresponding event received by the localhost application.\n   ![Events](img/ngrok_logs_moderntreasury.png)\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Modern Treasury webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Access the [Modern Treasury site](https://app.moderntreasury.com/) and sign in using your Modern Treasury account.\n\n1. On the left menu, click **View Sandbox** to switch to Sandbox mode.\n   **Note**: The Sandbox view provides you with example accounts that allow you to test Modern Treasury functions. If you have an active Modern Treasury account you can follow these steps without switching to Sandbox mode.\n\n1. On the left menu, click **Developers**, click the **Webhooks** tab, and then click the URL of your webhook.\n\n1. On your webhook page, copy the value of the **Webhook Key** field.\n\n1. Create a traffic policy file named `modern_treasury_policy.yml`, replacing `{your webhook key}` with the value you have copied before (See [Integrate ngrok and Modern Treasury.](#setup-webhook)):\n\n   ```yaml\n   on_http_request:\n     - name: \"Verify Modern Treasury requests\"\n       actions:\n         - type: verify-webhook\n           config:\n             provider: modern_treasury\n             secret: \"{your webhook key}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file modern_treasury_policy.yml\n   ```\n\n1. Access the [Modern Treasury site](https://app.moderntreasury.com/) and create a new payment order.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "Modern Treasury Webhooks"
			}
		  ],
		  "metadata": {
			"name": "modern-treasury",
			"description": "",
			"excerpt": "",
			"title": "Modern Treasury"
		  }
		},
		{
		  "name": "mongodb",
		  "path": "/integrations/mongodb",
		  "docs": [
			{
			  "path": "/integrations/mongodb/webhooks",
			  "frontMatter": {
				"description": "Develop and test MongoDB webhooks from localhost",
				"title": "MongoDB Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate MongoDB webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure MongoDB webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with MongoDB Atlas by using Webhooks.\nMongoDB webhooks can be used to notify an external application whenever specific events occur in your MongoDB account.\n\nBy integrating ngrok with MongoDB, you can:\n\n- **Develop and test MongoDB webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from MongoDB** in real-time via the inspection UI and API.\n- **Modify and Replay MongoDB Webhook requests** with a single click and without spending time reproducing events manually in your MongoDB account.\n- **Secure your app with MongoDB validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with MongoDB).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate MongoDB \n\nTo register a webhook on your MongoDB account follow the instructions below:\n\n1. Access the [MongoDB console](https://cloud.mongodb.com/) and sign in using your MongoDB account.\n\n1. On your project home page, click the bell icon below your name at the top-right corner to view the project alerts.\n   **Note**: If you don't have a project, create one before continuing.\n\n1. On the **Project Alerts** page, click **Add New Alert** and then click **Webhooks**.\n\n1. On the **Create a New Alert** popup, under **Alert if**, click **User** as the target, and then click **User joined the project** as the condition.\n\n1. Click **Add**, click **Webhook**, and enter the URL provided by the ngrok agent to expose your application to the internet in the **Webhook URL** field (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![Frameio URL to Publish](img/ngrok_url_configuration_mongodb.png)\n\n1. Enter the value `12345` in the **Webhook Secret** field. This value is used to provide more security to your webhook call. (See [Secure webhook requests](#security)).\n\n1. Click **Save**.\n\n### Run Webhooks with MongoDB and ngrok\n\nMongoDB sends different request body contents depending on the event that is being triggered.\nYou can trigger new calls from MongoDB to your application by following the instructions below.\n\n1. On your project home page, click the person icon to invite to the project.\n\n1. In the **invite new users via email address** field, enter an email to invite to your project.\n\n1. The new user receives an email and is required to register to MongoDB Atlas. After registration, confirm your localhost app receives an event notification and logs both headers and body in the terminal.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your MongoDB webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Create a traffic policy file named `mongodb_policy.yml`, replacing `{your webhook secret}` with the value of the **Webhook Secret** field you copied during the webhook registration (See [Integrate ngrok and MongoDB.](#setup-webhook)):\n\n   ```yaml\n   on_http_request:\n     - name: \"Verify MongoDB requests\"\n       actions:\n         - type: verify-webhook\n           config:\n             provider: \"mongodb\"\n             secret: \"{your webhook secret}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file mongodb_policy.yml\n   ```\n\n1. Access your project home page and invite a new person to your project.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "MongoDB Webhooks"
			}
		  ],
		  "metadata": {
			"name": "mongodb",
			"description": "",
			"excerpt": "",
			"title": "MongoDB"
		  }
		},
		{
		  "name": "mqtt-explorer",
		  "path": "/integrations/mqtt-explorer",
		  "docs": [
			{
			  "path": "/integrations/mqtt-explorer/mqtt",
			  "frontMatter": {
				"description": "Communicate with your MQTT server",
				"title": "MQTT"
			  },
			  "content": "<Tip>\n**TL;DR**\n\n\n\nTo publish your MQTT server with ngrok:\n\n1. [Start an MQTT server.](#start-mqtt-server) `mosquitto`\n1. [Launch ngrok.](#start-ngrok) `ngrok tcp 1883`\n1. [Configure MQTT Explorer with your ngrok URL.](#setup-mqtt-explorer)\n</Tip>\n\n## **Step 1**: Start an MQTT server \n\nFor this tutorial, we'll use the [Eclipse Mosquitto quickstart available on GitHub](https://github.com/eclipse-mosquitto/mosquitto).\n\nAfter [downloading the Mosquitto binary](https://mosquitto.org/download/) for your operating system, start the server by running this command in your terminal:\n\n```bash\nmosquitto\n```\n\nThe server runs by default on port 1883. Your output should look like this:\n\n```bash\n1734408888: mosquitto version 2.0.20 starting\n1734408888: Using default config.\n1734408888: Starting in local only mode. Connections will only be possible from clients running on this machine.\n1734408888: Create a configuration file which defines a listener to allow remote access.\n1734408888: For more details see https://mosquitto.org/documentation/authentication-methods/\n1734408888: Opening ipv4 listen socket on port 1883.\n1734408888: Opening ipv6 listen socket on port 1883.\n1734408888: mosquitto version 2.0.20 running\n```\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your auth token.\n\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok tcp 1883\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with MQTT Explorer).\n   ![ngrok agent running](/img/integrations/ngrok_start_tcp_tunnel.png)\n\n## **Step 3**: Integrate MQTT Explorer \n\n1. Open [MQTT Explorer](https://mqtt-explorer.com/) and click the plus sign to create a new MQTT connection. Enter the TCP address from the last step and click \"Connect\":\n   ![ngrok agent running](/img/integrations/ngrok_mqtt_explorer.png)\n\n1. You should see a few new lines in your MQTT server logs:\n\n```bash\n1734410153: New connection on port 1883.\n1734410153: New client connected as mqtt-explorer-ba9b56f9 (p2, c1, k60).\n```\n\n3. The client, MQTT Explorer, is now connected to your server over the public internet! But you need to subscribe to a topic to get messages from the client. In your terminal, open a new tab and enter:\n\n```bash\nmosquitto_sub -t 'example/topic' -v\n```\n\n4. Back in MQTT Explorer, publish a message to `example/topic`:\n   ![ngrok agent running](/img/integrations/mqtt_explorer_topic.png)\n\n5. You'll see the message in the terminal tab where you subscribed to the topic:\n\n```bash\nexample/topic hello world\n```\n",
			  "contentTitle": "MQTT"
			}
		  ],
		  "metadata": {
			"name": "mqtt-explorer",
			"description": "",
			"excerpt": "",
			"title": "MQTT Explorer"
		  }
		},
		{
		  "name": "mux",
		  "path": "/integrations/mux",
		  "docs": [
			{
			  "path": "/integrations/mux/webhooks",
			  "frontMatter": {
				"description": "Develop and test Mux webhooks from localhost",
				"title": "Mux Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Mux webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Mux webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Mux by using Webhooks.\nMux webhooks can be used to notify an external application whenever specific events occur in your Mux account.\n\nBy integrating ngrok with Mux, you can:\n\n- **Develop and test Mux webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Mux** in real-time via the inspection UI and API.\n- **Modify and Replay Mux Webhook requests** with a single click and without spending time reproducing events manually in your Mux account.\n- **Secure your app with Mux validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Mux).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Mux \n\nTo register a webhook on your Mux account follow the instructions below:\n\n1. Access [Mux](https://www.mux.com/) and sign in using your Mux account.\n\n1. On the Mux dashboard, click **Settings on the left menu, and then click **Webhooks\\*\\*.\n\n1. On the **Webhooks** tab of the **Settings** page, click **Create new webhook**.\n\n1. Select your environment, and enter the URL provided by the ngrok agent to expose your application to the internet in the **URL to notify** field (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![mux URL to Publish](img/ngrok_url_configuration_mux.png)\n\n1. Click **Create Webhook**.\n\n### Run Webhooks with Mux and ngrok\n\nMux sends different request body contents depending on the event that is being triggered.\nYou can trigger new calls from Mux to your application by following the instructions below.\n\n1. On the Mux dashboard, click **Assets** on the left menu and then click **Create New Asset**.\n\n1. On the **Create a new asset** popup, click **Run Request**.\n\n   Confirm your localhost app receives event notifications and logs both headers and body in the terminal.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Mux webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Access [Mux](https://www.mux.com/) and sign in using your Mux account.\n\n1. On the Mux dashboard, click **Settings** on the left menu, and then click **Webhooks**.\n\n1. On the **Webhooks** tab of the **Settings** page, click **Show Signing Secret** for your webhook and copy the value of the signing secret.\n\n1. Create a traffic policy file named `mux_policy.yml`, replacing `{your signing secret}` with the value you have copied before (See [Integrate ngrok and Mux.](#setup-webhook)):\n\n   ```yaml\n   on_http_request:\n     - name: \"Verify Mux requests\"\n       actions:\n         - type: verify-webhook\n           config:\n             provider: \"mux\"\n             secret: \"{your signing secret}\"\n   ```\n\n1. Restart our ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file mux_policy.yml\n   ```\n\n1. Access [Mux](https://www.mux.com/), sign in, and create a new asset.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "Mux Webhooks"
			}
		  ],
		  "metadata": {
			"name": "mux",
			"description": "",
			"excerpt": "",
			"title": "Mux"
		  }
		},
		{
		  "name": "okta",
		  "path": "/integrations/okta",
		  "docs": [
			{
			  "path": "/integrations/okta/dashboard-sso-okta-setup",
			  "frontMatter": {
				"description": "How to use Okta SSO to sign into the ngrok dashboard",
				"title": "Okta Dashboard SSO Setup"
			  },
			  "content": "# Configuring Okta Single Sign-On (SSO)\n\nThis guide walks you through using Okta as an identity provider when signing into the ngrok dashboard.\nThis should not be confused with configuring an ngrok endpoint so [application users can log in using Okta](/integrations/okta/sso-oidc).\n\n## What you'll need\n\n- Admin access to create new applications in Okta\n- Admin access to edit your ngrok account settings\n- An [ngrok Enterprise](https://ngrok.com/pricing) account\n\n## 1. Create a new SAML App Integration in Okta\n\n1. From the \"Applications\" menu, click the blue \"Create App Integration\" button.\n   ![](/img/howto/dash-sso/okta-create-app.png)\n1. Select \"SAML 2.0\" and click \"Next\"\n   ![](/img/howto/dash-sso/okta-create-app-1.png)\n1. Give your app a name, and click \"Next\"\n   ![](/img/howto/dash-sso/okta-name-app.png)\n1. Enter in temporary values for \"Single sign on URL\" and \"Audience URI\" and select \"EmailAddress\" for \"Name ID format\" and then click \"Next\". ngrok requires the username to be in email format.\n   ![](/img/howto/dash-sso/okta-nameid-format.png)\n1. Select \"This is an internal app that we have created\" and click \"Finish\".\n\n## 2. Download your SAML App metadata XML\n\n1. Navigate to the \"Sign On\" Tab on the new app and click on \"Actions\" under the Active SHA-2 certificate\n1. Click \"View IdP metadata\".\n   ![](/img/howto/dash-sso/okta-view-cert.png)\n1. In that new window, Select \"Save As\" from the File menu to save your metadata.xml file for uploading into ngrok in a later step.  \n   ![](/img/howto/dash-sso/okta-save-as-xml.png)\n\n## 3. Configure Single Sign-On (SSO) for your ngrok account\n\n1. Log into your ngrok dashboard and navigate to the [\"Settings > Account\"](https://dashboard.ngrok.com/settings) section in the left navigation menu.\n   ![](/img/howto/dash-sso/okta-ngrok-account-settings.png)\n1. Select \"+ New Identity Provider\" button to add a new identity provider.\n1. Add a helpful description, and then upload the metadata.xml file from Okta into the ngrok dashboard.\n   ![](/img/howto/dash-sso/okta-ngrok-config-options.png)\n1. In the Options section, select whether you'd like to allow users to log into the dashboard directly from their Okta dashboard\n1. Click \"Save\". Clicking Save will create the integration and generate the required URLs for your Okta Application.\n   ![](/img/howto/dash-sso/okta-ngrok-required-urls.png)\n\n## 4. Add the ngrok generated URLs to your Okta SAML application\n\n1. Back in your Okta account, on the \"General\" tab of your Okta app, click on \"Edit\" under \"SAML Settings\"\n   ![](/img/howto/dash-sso/okta-edit-app.png)\n1. Click 'Next' on the 'General Settings' tab to get to the 'Configure SAML' tab.\n1. Replace the values ngrok provided you. Put the ngrok 'ACS URL' value into Okta's \"Single sign on URL\" field. Put the ngrok 'SP Entity ID' value into Okta's \"Audience URI (SP Entity ID)\" field.\n   ![](/img/howto/dash-sso/okta-temp-urls.png)\n1. Click \"Next\". Click \"Finish\".\n\nYou should now be configured to log into your ngrok account using Okta.\n\nBy default, your ngrok account will still allow users to log in with their existing credentials as well as through Okta (\"Mixed Mode\"). Once you verify that everything is working properly with your integration, you can enable \"SSO Enforced\" in the ngrok Dashboard which will require all new users to log in through Okta for their ngrok account.\n",
			  "contentTitle": "Okta Dashboard SSO Setup"
			},
			{
			  "path": "/integrations/okta/scim",
			  "frontMatter": {
				"title": "Okta SCIM User Provisioning",
				"description": "Enable automated user provisioning via SCIM",
				"tags": [
				  "okta",
				  "scim",
				  "user provisioning",
				  "dashboard sso"
				]
			  },
			  "content": "\n# Automated User Provisioning via SCIM with Okta\n\n## Configuring ngrok\n\nStart by logging into your ngrok Dashboard as an admin user.\n\n1. Navigate to the **Settings**, **Account** menu in the left side of the page.\n\n   ![ngrok Dashboard Settings](img/okta-scim-account-settings.png)\n\n1. Go to the **User Provisioning / SCIM** section and toggle on the **Automated User Provisioning via SCIM 2.0** option to on. This will open a drawer and prompt you to create a new API key. It is recommended to use a unique key just for SCIM.\n\n   ![ngrok User Provisioning](img/okta-scim-provisioning.png)\n\n1. Give the API key a descriptive name and assign it either to an administrator user or a service user. Service users are ideal for this integration because they will not be deactivated when a user leaves the account.\n\n   ![ngrok create new API key](img/okta-scim-add-api-key.png)\n\n1. Save the API key somewhere safe or keep this window up while we complete the next steps in Okta.\n\n   ![ngrok new API key](img/okta-scim-new-api-key.png)\n\n## Configuring Okta SCIM\n\nThis document assumes you have already set up [Okta for dashboard SSO](/integrations/okta/dashboard-sso-okta-setup). Once you've completed those steps, you can continue here.\n\nOpen a new tab in your browser, then log in to the Okta admin console as a user with the ability to manage the ngrok application.\n\n1. In the Okta admin console navigate to the to **Applications/Applications** menu on the left side.\n\n   ![Okta Applications](img/okta-scim-okta-app.png)\n\n1. Open the ngrok app you created.\n\n1. Enable SCIM on the general tab in the ngrok application you created under the Provisioning section:\n\n   ![Okta Application General](img/okta-scim-okta-general-settings.png)\n\n1. Switch to the Provisioning tab in your Okta application configuration\n   - SCIM connector base URL:\n     - https://api.ngrok.com/scim/v2/\n   - Unique identifier field for users\n     - `email`\n   - Supported provisioning actions\n     - Push new users\n     - Push profile updates\n   - Authentication mode:\n     - HTTP Header\n   - Authorization:\n     - This is the ngrok API key that you saved or copied earlier\n1. The configuration should look like this:\n\n   ![Okta Application Provisioning](img/okta-scim-okta-app-provisioning.png)\n\n1. Click **Test Connect Configuration** and you should see a success message.\n\nIf you get an error message that states no users were returned then you have an error in the configuration and should check the configuration for typos and leading or trailing spaces.\n",
			  "contentTitle": "Okta SCIM User Provisioning"
			},
			{
			  "path": "/integrations/okta/sso-oidc",
			  "frontMatter": {
				"title": "Okta Endpoint SSO (OpenID Connect)",
				"description": "Use Okta OIDC to secure access to ngrok endpoints"
			  },
			  "content": "\nimport Disclaimer from \"/snippets/integrations/_endpoint-sso-disclaimer.mdx\";\n\n<Disclaimer />\n\n# Okta SSO (OpenID Connect)\n<Tip>\n**TL;DR**\n\n\n\nTo secure access to ngrok with Okta Single Sign-On using OpenID Connect:\n\n1. [Configure Okta SSO](#configure-okta)\n1. [Configure ngrok](#configure-ngrok)\n1. [Test access to ngrok with Okta SSO](#test-sso)\n</Tip>\n\nThis article details how to configure Okta as the primary Identity Provider for ngrok tunnels.\nBy integrating Okta SSO with ngrok, you can:\n\n- **Restrict access to ngrok tunnels** only to users authenticated via Okta\n- **Use Okta security policies, MFA authenticators** — including Okta Verify, FastPass, and FIDO2 — **and ThreatInsights to control access to ngrok tunnels**.\n- **Use Okta's Dashboard to facilitate access to ngrok apps**.\n\n## Supported Features\n\nThe ngrok integration with Okta supports:\n\n- **SP-Initiated SSO**: In this mode, users access ngrok edges and tunnels and are redirected to Okta for authentication.\n\n## Requirements\n\nTo configure ngrok tunnels with Okta, you must have:\n\n- an Okta account with administrative rights to create apps\n- an [ngrok Enterprise Account](https://ngrok.com/pricing) with an authtoken or admin access to configure edges with OpenID Connect.\n\n## Configuration Steps\n\nTo integrate ngrok with Okta SSO, you will need to:\n\n1. Configure Okta with the ngrok app\n1. Configure ngrok with the SSO settings provided by Okta\n\n## **Step 1**: Configure Okta \n\n### Add the ngrok App in Okta\n\n1. Access your Okta Dashboard as an administrator and then click **Admin**.\n1. Click **Application** > **Applications** .\n1. Click **Browse App Catalog**,\n1. Search for _ngrok_, and then click **Add**.\n1. Enter the **Application label** — this is the app name that will be displayed in the okta dashboard for end users — and click **Next**.\n1. Select **OpenID Connect**, and then enter the following:\n   1. **Sign-in redirect URI**: https://idp.ngrok.com/oauth2/callback\n   1. **Login initiated by**: Login initiated by app\n1. Click **Done**.\n1. Under the **Sign On** tab of the ngrok application, **copy the Client ID and Client Secret**. These values will be used at ngrok to complete the configuration.\n1. In the ngrok configuration under Scopes add the following OAuth Scopes: `openid,profile,email`\n\n### Grant access to Okta people and groups\n\nOkta allows administrators to restrict access to SSO apps — such as ngrok — via assignments. By default, apps created in Okta have no assignments — in other words, nobody can use Okta SSO to access ngrok until you assign them to the app. To assign Okta users and groups to the ngrok app:\n\n1. Click **Application** > **Applications** .\n1. Search for and click the **ngrok app**.\n1. Click **Assignments**.\n1. Use the **Assign** button to associate groups and users with the ngrok app. **To test the SSO with ngrok, make sure you're assigned to the app**.\n\n## **Step 2**: Configure ngrok \n\nngrok can leverage Okta SSO in two ways:\n\n- From the ngrok CLI (using the `--oidc` parameter)\n- From the ngrok dashboard\n\n### **Option 1**: ngrok CLI\n\n> **Note:** For this tutorial, we assume you have an app running locally (i.e., on localhost:3000) with the ngrok client installed.\n\n1. Launch a terminal\n1. Enter the following command to launch an ngrok tunnel with Okta SSO. Replace `<okta_url>` with your okta org address (i.e., https://acme.okta.com) and the `<okta_client_id>` and `<okta_client_secret>` with the respective values copied from the ngrok app registered at Okta. Optionally, add the `--url <domain>` argument to get your own custom URL, replacing `<domain>` with your URL of preference:\n\n   ```bash\n   ngrok http 3000 --oidc <okta_url> \\\n   --oidc-client-id <okta_client_id> \\\n   --oidc-client-secret <okta_client_secret> \\\n   --url <domain>\n   ```\n\n1. Copy the url available next to **Forwarding** (for example, `https://okta-sso-test.ngrok.app`).\n\n1. Skip to **Step 3**\n\n### **Option 2**: ngrok Edge\n\nTo configure an edge with Okta:\n\n1. Go to dashboard.ngrok.com.\n1. Click **Universal Gateway** > **Edges**\n1. If you don't have an edge already set to add Okta SSO, create a test edge:\n   - Click **New Edge**\n   - Click **HTTPS Edge**\n   - Click the **pencil icon** next to \"no description\". Enter _Edge with Okta SSO_ as the edge name and click **Save**.\n1. On the edge settings, click **OIDC**.\n1. Click **Begin setup** and enter the following:\n\n   ![Okta config in ngrok](img/okta-1.png)\n   - **Issuer URL**: Your okta tenant url (i.e. https://acme.oktapreview.com).\n   - **Client ID**: The client id copied from Okta\n   - **Client Secret**: The client secret copied from Okta\n\n1. Click **Save**.\n\n1. Launch a tunnel connected to your Okta edge:\n<Tip>\n**Note**\n\n\nFor this step, we assume you have an app running locally (i.e. on localhost:3000) with the ngrok client installed.\n</Tip>\n\n1.  Click **Start a tunnel**.\n1.  Click the **copy icon** next to the tunnel command.\n\n    ![tunnel config](img/okta-2.png)\n\n1.  Launch a tunnel:\n    - Launch a terminal\n    - Paste the command. Replace http://localhost:80 with your local web app addess (i.e., http://localhost:3000)\n    - hit **Enter**. an ngrok tunnel associated to your edge configuration will launch.\n1.  To confirm that the tunnel is connected to your edge:\n    - Return to the ngrok dashboard\n    - Close the **Start a tunnel** and the **Tunnel group** tabs\n    - Refresh the test edge page. Under traffic, You will see the message _You have 1 tunnel online. Start additional tunnels to begin load balancing_\n\n    ![tunnel confirmed](img/okta-3.png)\n\n1.  In the test edge, copy the **endpoint URL**. (you will use this url to test the Okta Authentication)\n    ![tunnel url](img/okta-4.png)\n\n## Step 3: Test the integration \n\n1. In your browser, launch an incognito window.\n1. Access your ngrok tunnel (i.e., https://okta-sso-test.ngrok.app or using a copied URL).\n1. You should be prompted to log in with your Okta credentials.\n1. After logging in, you should be able to see your web app.\n",
			  "contentTitle": "Okta Endpoint SSO (OpenID Connect)"
			},
			{
			  "path": "/integrations/okta/sso-saml",
			  "frontMatter": {
				"description": "Use Okta SAML to secure access to ngrok endpoints",
				"title": "Okta Endpoint SSO (SAML)"
			  },
			  "content": "# Okta SSO (SAML) for your ngrok endpoints\n\nimport Disclaimer from \"/snippets/integrations/_endpoint-sso-disclaimer.mdx\";\n\n<Disclaimer />\n<Tip>\n**TL;DR**\n\n\n\nTo secure access to ngrok with Okta Single Sign-On using SAML:\n\n1. [Configure Okta SSO](#configure-okta)\n1. [Configure ngrok](#configure-ngrok)\n1. [Test access to ngrok with Okta SSO](#test-sso)\n</Tip>\n\nThis article details how to configure Okta as the primary Identity Provider for ngrok tunnels.\nBy integrating Okta SSO with ngrok, you can:\n\n- **Restrict access to ngrok tunnels** only to users authenticated via Okta\n- **Use Okta security policies, MFA authenticators** — including Okta Verify, FastPass, and FIDO2 — **and ThreatInsights to control access to ngrok tunnels**.\n- **Use Okta's Dashboard to facilitate access to ngrok apps**.\n\n## Requirements\n\nTo configure ngrok tunnels with Okta, you must have:\n\n- an Okta account with administrative rights to create apps\n- an [ngrok Enterprise Account](https://ngrok.com/pricing) with an authtoken or admin access to configure edges with SAML.\n\n## Configuration Steps\n\nTo integrate ngrok with Okta SSO, you will need to:\n\n1. Configure Okta with the ngrok app\n1. Configure ngrok with the SSO settings provided by Okta\n\n## **Step 1**: Configure Okta \n\n### Add the ngrok App in Okta\n\n1. Access your Okta Dashboard as an administrator and then click **Admin**.\n1. Click **Application** > **Applications** .\n1. Click **Create App Integration**,\n1. Select _SAML 2.0_, and then click **Next**.\n1. Enter the **Application label** — this is the app name that will be displayed in the okta dashboard for end users — and click **Next**.\n1. Enter in temporary values for \"Single sign on URL\" and \"Audience URI\" and select \"EmailAddress\" for \"Name ID format\" and then click \"Next\".\n   1. **Single sign-on URL**: https://temporary\n   1. **Audience URI (SP Entity ID)**: https://temporary\n   1. **Name ID format**: Email\n1. Select **I’m an Okta customer adding an internal app** and click **Finish**.\n1. Click **Done**.\n1. Under the **Sign On** tab of the ngrok application, **copy the Client ID and Client Secret**. These values will be used at ngrok to complete the configuration.\n\n### Download the IdP metadata\n\n1. Navigate to the **Sign On** Tab on the new app and click on **Actions** under the Active SHA-2 certificate and select **View IdP metadata**. The metadata will open in a new tab.\n   ![view xml metadata](img/okta-view-cert.png)\n1. In the new tab, Select **Save As** from the File menu to save your metadata.xml file for uploading into ngrok in a later step.\n   ![download xml](img/okta-save-as-xml.png)\n\n### Grant access to Okta people and groups\n\nOkta allows administrators to restrict access to SSO apps — such as ngrok — via assignments. By default, apps created in Okta have no assignments — in other words, nobody can use Okta SSO to access ngrok until you assign them to the app. To assign Okta users and groups to the ngrok app:\n\n1. Navigate to the **Assignments** Tab.\n1. Use the **Assign** button to associate groups and users with the ngrok app. **To test the SSO with ngrok, make sure you're assigned to the app**.\n\n## **Step 2**: Configure ngrok \n\n### ngrok Edge\n\nTo configure an edge with Okta:\n\n1. Go to dashboard.ngrok.com.\n1. Click **Universal Gateway** > **Edges**\n1. If you don't have an edge already set to add Okta SSO, create a test edge:\n   - Click **New Edge**\n   - Click **HTTPS Edge**\n   - Click the **pencil icon** next to \"no description\". Enter _Edge with Okta SSO_ as the edge name and click **Save**.\n1. On the edge settings, click **SAML**.\n1. Click **Begin setup** and click on **Upload XML** beside **IdP Metadata** under **Identity Provider** and select your metadata file saved from the steps above:\n\n   ![Okta config in ngrok](img/okta-5.png)\n\n1. Click **Save** at the top.\n1. After you save, the SP Metadata will appear. Copy these values into the Okta where temporary values were placed above:\n   ![Update Okta with SP values](img/okta-6.png)\n1. Save the changes in Okta.\n1. Launch a tunnel connected to your Okta edge:\n<Tip>\n**Note**\n\n\nFor this step, we assume you have an app running locally (i.e. on localhost:3000) with the ngrok client installed.\n</Tip>\n\n1.  Click **Start a tunnel**.\n1.  Click the **copy icon** next to the tunnel command.\n\n    ![tunnel config](img/okta-2.png)\n\n1.  Launch a tunnel:\n    - Launch a terminal\n    - Paste the command. Replace http://localhost:80 with your local web app addess (i.e., http://localhost:3000)\n    - hit **Enter**. an ngrok tunnel associated to your edge configuration is launched.\n1.  To confirm that the tunnel is connected to your edge:\n    - Return to the ngrok dashboard\n    - Close the **Start a tunnel** and the **Tunnel group** tabs\n    - Refresh the test edge page. Under traffic, You will see the message _You have 1 tunnel online. Start additional tunnels to begin load balancing_\n\n    ![tunnel confirmed](img/okta-3.png)\n\n1.  In the test edge, copy the **endpoint URL**. (you will use this url to test the Okta Authentication)\n    ![tunnel url](img/okta-4.png)\n\n## Step 3: Test the integration \n\n1. In your browser, launch an incognito window.\n1. Access your ngrok tunnel (i.e., https://okta-sso-test.ngrok.app or using a copied URL).\n1. You should be prompted to log in with your Okta credentials.\n1. After login, you should be able to see your web app.\n",
			  "contentTitle": "Okta Endpoint SSO (SAML)"
			},
			{
			  "path": "/integrations/okta/webhooks",
			  "frontMatter": {
				"description": "Develop and test Okta webhooks from localhost",
				"title": "Okta Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Okta webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Okta webhooks with your ngrok URL.](#setup-webhook)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Okta by using Webhooks.\nOkta webhooks can be used to notify an external application whenever specific events occur in your Okta account.\n\nBy integrating ngrok with Okta, you can:\n\n- **Develop and test Okta webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Okta** in real-time via the inspection UI and API.\n- **Modify and Replay Okta Webhook requests** with a single click and without spending time reproducing events manually in your Okta account.\n- **Secure your app with Okta validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm run startOkta\n```\n\nThe app runs by default on port `3000`.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Okta).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Okta \n\nTo register a webhook on your Okta account follow the instructions below:\n\n1. Access yout Okta tentant (i.e. `https://mytenant.okta.com/`) and sign in using your Okta account.\n\n1. On the left menu, click **Workflow**, click **Event Hooks**, and then click **Create Event Hook**.\n\n1. On the **Add Event Hook Endpoint** page, enter `My Webhook` in the **Name** field, and in the **URL** field enter the URL provided by the ngrok agent to expose your application to the internet (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![Okta URL to Publish](img/ngrok_url_configuration_okta.png)\n\n1. In the **Subscribe to events** field select **User sign in attempt** and then click **Save & Continue**.\n\n1. On the **Verification** page, click **Verify** to confirme Okta can contact your localhost through ngrok.\n\n### Run Webhooks with Okta and ngrok\n\nOkta sends different request body contents depending on the event that is being triggered.\nYou can test your webhook by following the steps below.\n\n1. On the **Event Hooks** page, click **Actions** for your webhook and then click **Preview**.\n\n1. On the **Preview** page, select the **Event Type** from the list of event types and then click **Deliver Request**.\n\n   Confirm your localhost app receives an event notification and logs both headers and body in the terminal.\n\nOptionally, You can trigger new calls from Okta to your application by signing out from Okta console, signing in again, and then clicking **Admin** to enter the administrative console.\n\n    Confirm your localhost app receives an event notification and logs both headers and body in the terminal.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n",
			  "contentTitle": "Okta Webhooks"
			}
		  ],
		  "metadata": {
			"name": "okta",
			"description": "",
			"excerpt": "",
			"title": "Okta"
		  }
		},
		{
		  "name": "orbit",
		  "path": "/integrations/orbit",
		  "docs": [
			{
			  "path": "/integrations/orbit/webhooks",
			  "frontMatter": {
				"description": "Develop and test Orbit webhooks from localhost",
				"title": "Orbit Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Orbit webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Orbit webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Orbit by using Webhooks.\nOrbit webhooks can be used to notify an external application whenever specific events occur in your Orbit account.\n\nBy integrating ngrok with Orbit, you can:\n\n- **Develop and test Orbit webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Orbit** in real-time via the inspection UI and API.\n- **Modify and Replay Orbit Webhook requests** with a single click and without spending time reproducing events manually in your Orbit account.\n- **Secure your app with Orbit validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Orbit).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Orbit \n\nTo register a webhook on your Orbit account follow the instructions below:\n\n1. Access the [Orbit Home](https://app.orbit.love/) page and sign in using your Orbit account.\n\n1. On the **Home** page, click **Workspace Settings** at the left menu and then click **Webhooks**.\n\n1. On the **Webhooks** page, click **+ New Webhook**.\n\n1. On the **New webhook** page, enter a name in the **Webhook Name** field, select **a new activity is added to a member** in the **Event Subscription** field, and then enter the URL provided by the ngrok agent to expose your application to the internet in the **Webhook URL** field (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![orbit URL to Publish](img/ngrok_url_configuration_orbit.png)\n\n1. Click **Create Webhook**.\n\n### Run Webhooks with Orbit and ngrok\n\nOrbit sends different request body contents depending on the event that is being triggered.\n\nYou can trigger new calls from Orbit to your application by following the instructions below.\n\n1. Access the [Orbit Home](https://app.orbit.love/) page, sign in, click **Members** at the left menu, and click one of your members.\n\n1. On the **Member** popup, click **Actions** and then click **Add Activity**.\n\n1. On the **Add activity** popup, select an activity in the **Activity Type** field, enter `Test` in the **Title** field, and then click **Submit**.\n\nConfirm your localhost app receives an event notification and logs both headers and body in the terminal.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Orbit webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Access the [Orbit Home](https://app.orbit.love/) page, sign in, click **Workspace Settings** at the left menu, and then click **Webhooks**.\n\n1. Click **Action** (represented by the three dots icon) for your webhook and click **Update**.\n\n1. On the **Update Webhook** page, enter `12345` in the **Webhook Secret** field and click **Save Changes**.\n\n1. Create a traffic policy file named `orbit_policy.yml`, replacing `{your webhook secret}` with the value from the previous step:\n\n   ```yaml\n   on_http_request:\n     - name: \"Verify Orbit requests\"\n       actions:\n         - type: verify-webhook\n           config:\n             provider: \"orbit\"\n             secret: \"{your webhook secret}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file orbit_policy.yml\n   ```\n\n1. Access [Orbit Home](https://app.orbit.love/) page, sign in, and add a new activity to a member.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "Orbit Webhooks"
			}
		  ],
		  "metadata": {
			"name": "orbit",
			"description": "",
			"excerpt": "",
			"title": "Orbit"
		  }
		},
		{
		  "name": "pagerduty",
		  "path": "/integrations/pagerduty",
		  "docs": [
			{
			  "path": "/integrations/pagerduty/webhooks",
			  "frontMatter": {
				"description": "Develop and test PagerDuty webhooks from localhost",
				"title": "PagerDuty Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate PagerDuty webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure PagerDuty webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with PagerDuty by using Webhooks.\nPagerDuty webhooks can be used to notify an external application whenever specific events occur in your PagerDuty account.\n\nBy integrating ngrok with PagerDuty, you can:\n\n- **Develop and test PagerDuty webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from PagerDuty** in real-time via the inspection UI and API.\n- **Modify and Replay PagerDuty Webhook requests** with a single click and without spending time reproducing events manually in your PagerDuty account.\n- **Secure your app with PagerDuty validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with PagerDuty).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate PagerDuty \n\nTo register a webhook on your PagerDuty account follow the instructions below:\n\n1. Access [PagerDuty](https://www.pagerduty.com/), and sign in using your PagerDuty account.\n\n1. Click **Integrations** on the top menu and then click **Generic Webhooks**.\n\n1. On the **Your Webhooks** page, click **+New Webook** for your application.\n\n1. On the **New Webhook** page, in the **WEBHOOK URL** field enter the URL provided by the ngrok agent to expose your application to the internet (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![Your request endpoint URL](img/ngrok_url_configuration_pagerduty.png)\n\n1. On the same page, select **Service** as **SCOPE TYPE**, select one of your service for **SCOPE**, click **Select all** under **EVENT SUBSCRIPTION**, and then click **Add Webhook**.\n\n1. In the **Webhook subscription created** popup, click **OK**.\n   **Tip**: Click **Copy** to copy the **webhook payload signing** code for later usage. See [Secure your webhook requests with verification](#security).\n\n1. In the **Your Webhooks** page, click the webhook you have just created.\n\n1. In your webhook's settings page, scroll down until the **Test** section, click **Send Test Event**, and then click **Yes, Send Event**.\n   Confirm your localhost app receives the test event notification and logs both headers and body in the terminal.\n\n### Run Webhooks with PagerDuty and ngrok\n\nPagerDuty sends different request body contents depending on the event that is being triggered.\nYou can trigger new calls from PagerDuty to your application by following the instructions below.\n\n1. In the same browser, access your PagerDuty company page, click **Services** on the top menu, and then click the **Service Directory**.\n\n1. On the **Service Directory** page, click **+ New Service**.\n\n1. In the **Create a Service** page, enter your service **Name** and then click **Next** until the **Integrations** step appears.\n\n1. In the **Integrations** step, click **Create service without an integration**.\n\n1. On your service page, click **New Incident**, select your service for **Create an incident on the following service**, provide a short title, select **Urgency** as **Low**, and then click **Create Incident**.\n   Confirm your localhost app receives the create new incident event notification and logs both headers and body in the terminal.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your PagerDuty webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Create a traffic policy file named `pagerduty_policy.yml`, replacing `{your webhook payload signing}` with the value you copied before (See [Integrate ngrok and PagerDuty.](#setup-webhook)):\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: pagerduty\n             secret: \"{your webhook payload signing}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file pagerduty_policy.yml\n   ```\n\n1. Access PagerDuty (`https://{tenant}.pagerduty.com/incidents`) and create a new incident.\n\n1. Verify that your local application receives the request and logs information to the terminal.\n<Info>\n**Need some help?**\n\n\n\nWe all do sometimes 😅. To get help from our team, join our [Slack Community](https://ngrok.com/slack).\n</Info>\n",
			  "contentTitle": "PagerDuty Webhooks"
			}
		  ],
		  "metadata": {
			"name": "pagerduty",
			"description": "",
			"excerpt": "",
			"title": "PagerDuty"
		  }
		},
		{
		  "name": "pinwheel",
		  "path": "/integrations/pinwheel",
		  "docs": [
			{
			  "path": "/integrations/pinwheel/webhooks",
			  "frontMatter": {
				"description": "Develop and test Pinwheel webhooks from localhost",
				"title": "Pinwheel Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Pinwheel webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Pinwheel webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Pinwheel by using Webhooks.\nPinwheel webhooks can be used to notify an external application whenever specific events occur in your Pinwheel account.\n\nBy integrating ngrok with Pinwheel, you can:\n\n- **Develop and test Pinwheel webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Pinwheel** in real-time via the inspection UI and API.\n- **Modify and Replay Pinwheel Webhook requests** with a single click and without spending time reproducing events manually in your Pinwheel account.\n- **Secure your app with Pinwheel validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Pinwheel).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Pinwheel \n\nTo register a webhook on your Pinwheel account follow the instructions below:\n\n1. Access the [Pinwheel Developer Portal](https://developer.getpinwheel.com/) and sign in using your Pinwheel account.\n\n1. On the **Dashboard** page, click the **API Keys** tab, click **Reveal Secret**, and make note of both the **API Secret** and **Server** values.\n\n1. Open a terminal window and run the following command to create the webhook:\n\n   ```bash\n   curl --request POST --url SERVER_URL/v1/webhooks \\\n   --header 'x-api-secret: API_SECRET' \\\n   --header 'Content-Type: application/json' --data '{\n       \"url\": \"NGROK_URL\",\n       \"status\": \"active\",\n       \"enabled_events\": [\n           \"account.added\",\n           \"employment.added\",\n           \"identity.added\",\n           \"income.added\"\n       ]\n   }'\n   ```\n\n   **Note**: Replace the following with values copied on previous steps:\n   - SERVER_URL: The Pinwheel Server URL.\n   - NGROK_URL: the URL provided by the ngrok agent to expose your application to the internet (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   - API_SECRET: The Pinwheel API Secret.\n\n   ![URL to Publish](img/ngrok_url_configuration_pinwheel.png)\n\n1. Make sure the response to the previous command is JSON containing a **status** attribute with `active` as the value.\n\n### Run Webhooks with Pinwheel and ngrok\n\nPinwheel sends different request body contents depending on the event you enabled during the webhook registration.\n\nBecause you subscribed your webhook to the **account.added** event, you can trigger new calls to your localhost application by asking users to log into their payroll accounts by using the Pinwheel API.\n\nConfirm your localhost app receives an event notification and logs both headers and body in the terminal.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Pinwheel webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Create a traffic policy file named `pinwheel_policy.yml`, replacing `{your api secret}` with the value of the API Secret you copied before (See [Integrate Pinwheel](#setup-webhook)):\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: pinwheel\n             secret: \"{your api secret}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file pinwheel_policy.yml\n   ```\n\n1. Request users to log into their payroll account by using Pinwheel API.\n\n   Confirm your localhost app receives an event notification and logs both headers and body in the terminal.\n",
			  "contentTitle": "Pinwheel Webhooks"
			}
		  ],
		  "metadata": {
			"name": "pinwheel",
			"description": "",
			"excerpt": "",
			"title": "Pinwheel"
		  }
		},
		{
		  "name": "plivo",
		  "path": "/integrations/plivo",
		  "docs": [
			{
			  "path": "/integrations/plivo/webhooks",
			  "frontMatter": {
				"description": "Develop and test Plivo webhooks from localhost",
				"title": "Plivo Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Plivo webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Plivo webhooks with your ngrok URL.](#setup-webhook)\n1. **Bonus!** [Use ngrok like a PRO.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Plivo by using Webhooks.\nPlivo webhooks can be used to notify an external application whenever SMS and MMS messages are sent to your Plivo numbers.\n\nBy integrating ngrok with Plivo, you can:\n\n- **Develop and test Plivo webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Plivo** in real time via the inspection UI and API.\n- **Modify and Replay Plivo Webhook requests** with a single click and without spending time reproducing events manually in your Plivo account.\n- **Secure your app with Plivo validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Plivo).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Plivo \n\nTo register a webhook on your Plivo account follow the instructions below:\n\n1. Access the [Plivo Console](https://console.plivo.com/) and sign in using your Plivo account.\n\n1. On the **Overview** page, click **Messaging** at the left menu, and then click **PHLO** under **Applications**.\n\n1. On the **Your PHLOs** page, click **Create New PHLO** and then click **Build My Own** on the **Choose your use case** popup.\n\n1. On the PHLO page, click the **pencil icon** next to the `untitled PHLO` message at the top left, replace the text with `Webhook PHLO`, and then click **Save**.\n\n1. Drag the function **HTTP Request** from the left panel to the center of the screen and then click the **HTTP Request** component.\n\n1. On the right panel, select **POST** instead of **GET** in the **HTTP Method**, and enter the URL provided by the ngrok agent to expose your application to the internet in the field next to **POST** (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![Plivo URL to Publish](img/ngrok_url_configuration_plivo.png)\n\n1. Click **FETCH RESPONSE** in the right panel, verify that your webook responds to the call with a message in the **Response** field, and then click **VALIDATE**.\n\n1. On the PHLO page, drag a line from the **Incoming Message** of the **Start** component to the triangle on the top of the **HTTP Request** component you created, and then click **Save**.\n\n1. On the left menu, click **Phone Numbers** and then click one of your numbers.\n   **Note**: If you don't have numbers click **Buy Number** and follow the instructions on the screen.\n\n1. On the phone number page, select **PHLO** in the **Application Type** field, select **Webhook PHLO** in the **PHLO Name** field, and then click **Update Number**.\n\n### Run Webhooks with Plivo and ngrok\n\nPlivo sends different request body contents depending on the event that is being triggered.\nYou can trigger new calls from Plivo to your application by following the instructions below.\n\n1. Send an SMS message to your Plivo phone number.\n\n   Confirm your localhost app receives a notification and logs both headers and body in the terminal.\n\nAlternatively, you can verify the log of the webhook call in Plivo:\n\n1. On the left menu of the [Plivo Console](https://console.plivo.com/), click **Messaging** and then click **SMS/MMS** under **Logs** in the left panel.\n\n1. Click one of the logs and then scroll down to the \\***\\*Status Callbacks** section.\n   ![Webhook Logs](img/ngrok_logs_plivo.png)\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## **Bonus**: Secure webhook requests \n\nThe ngrok webhook verification feature allows ngrok to assert that requests from your Plivo webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Access the [Plivo Console](https://console.plivo.com/) and sign in using your Plivo account.\n\n1. On the **Overview** page, click the eye icon next to **Auth Token** and then copy the value that appears.\n\n1. Create a traffic policy file named `plivo_policy.yml`, replacing `{your auth token}` with the value you copied before:\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: plivo\n             secret: \"{your auth token}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file plivo_policy.yml\n   ```\n\n1. Send a new SMS to your Plivo phone number.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "Plivo Webhooks"
			}
		  ],
		  "metadata": {
			"name": "plivo",
			"description": "",
			"excerpt": "",
			"title": "Plivo"
		  }
		},
		{
		  "name": "pusher",
		  "path": "/integrations/pusher",
		  "docs": [
			{
			  "path": "/integrations/pusher/webhooks",
			  "frontMatter": {
				"description": "Develop and test Pusher webhooks from localhost",
				"title": "Pusher Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Pusher webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Pusher webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Pusher by using Webhooks.\nPusher webhooks can be used to notify an external application whenever specific events occur in your Pusher channel.\n\nBy integrating ngrok with Pusher, you can:\n\n- **Develop and test Pusher webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Pusher** in real-time via the inspection UI and API.\n- **Modify and Replay Pusher Webhook requests** with a single click and without spending time reproducing events manually in your Pusher account.\n- **Secure your app with Pusher validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Pusher).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Pusher \n\nTo register a webhook on your Pusher channel follow the instructions below:\n\n1. Access the [Pusher dashboard](https://dashboard.pusher.com/), sign in using your Pusher account, and then click your channel name in the **Channels** tile.\n\n   **Tip**: If you don't have a channel, create one with the name `my-channel`.\n\n1. On your channel page, click **Webhooks** on the left menu and then click **Add webhook**.\n\n1. On the **Add new webhook** popup, enter the URL provided by the ngrok agent to expose your application to the internet in the **Webhook URL** field (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![URL to Publish](img/ngrok_url_configuration_pusher.png)\n\n1. Click **Client events** under the **Event type** section and then click **Save**.\n\n1. Repeat the previous 3 steps to create webhooks for the other **Event type** values.\n\n### Run Webhooks with Pusher and ngrok \n\nPusher sends different request body contents depending on the event that is being triggered.\nYou can trigger new calls from Pusher to your application by creating a client event test.\n\n1. On the [Pusher dashboard](https://dashboard.pusher.com/), click **Debug console** on the left menu, expand the **Event creator** section, enter `my-channel` in the **Channel** field, enter `my-event` in the **Event** field, enter some text in the **Data** field, and then click **Send event**.\n\n   Confirm your localhost app receives an event notification and logs both headers and body in the terminal.\n\nAlternatively, you can verify any error occurring during webhook calls in Pusher:\n\n1. On the [Pusher dashboard](https://dashboard.pusher.com/), click **Error Logs** on the left menu, and then click the **Webhook errors** tab.\n   ![Webhook Logs](img/ngrok_logs_pusher.png)\n\n**Note**: On this page, Pusher only shows messages that couldn't be delivered for any reason.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Pusher webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. On the [Pusher dashboard](https://dashboard.pusher.com/), click **App keys** on the left menu, and then copy the value of the **secret** field that appears on the screen.\n\n1. Create a traffic policy file named `pusher_policy.yml`, replacing `{your webhook secret}` with the value you have copied before:\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: pusher\n             secret: \"{your webhook secret}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file pusher_policy.yml\n   ```\n\n1. Repeat the steps described in the [Run Webhooks with Pusher and ngrok](#run-webhook) section.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "Pusher Webhooks"
			}
		  ],
		  "metadata": {
			"name": "pusher",
			"description": "",
			"excerpt": "",
			"title": "Pusher"
		  }
		},
		{
		  "name": "rafay",
		  "path": "/integrations/rafay",
		  "docs": [
			{
			  "path": "/integrations/rafay/k8s",
			  "frontMatter": {
				"title": "Ingress to Kubernetes apps managed by Rafay",
				"description": "Add ingress to any app running in a Kubernetes cluster managed by Rafay using the ngrok Kubernetes Operator."
			  },
			  "content": "\nIn this guide, you'll launch a new cluster with [Rafay](https://rafay.co/) and provision the ngrok Kubernetes Operator to route public traffic directly to a demo app through a secure tunnel.\n\nIn the end, you'll have learned enough to deploy your next production-ready Kubernetes app with Rafay, with the ngrok Kubernetes Operator giving you access to additional features, like observability and resiliency, with no extra configuration complexity.\n\nHere is what you'll be building with:\n\n- **The [ngrok Kubernetes Operator](https://ngrok.com/blog-post/ngrok-k8s)**: ngrok's official controller for adding secure public ingress and middleware execution to your Kubernetes apps with ngrok's cloud service. With ngrok, you can manage and secure app traffic at every stage of the development lifecycle while benefiting from simpler configurations, security, and edge acceleration.\n- **Rafay**: A SaaS-based cloud controller that helps platform and DevOps teams manage their Kubernetes clusters and cloud environments. By plugging into existing Internal Developer Programs and CI/CD pipelines, Rafay helps enable more automation, consistency, and governance while also letting internal developers provision and deploy with ease.\n\n## What you'll need\n\n- An account with [Rafay](https://rafay.co/).\n- An account with the necessary privileges to create a cluster on one of the following managed Kubernetes services:\n  - [Amazon Elastic Kubernetes Service](https://aws.amazon.com/eks/) (EKS)\n  - [Azure Kubernetes Service](https://azure.microsoft.com/en-us/products/kubernetes-service) (AKS)\n  - [Google Kubernetes Engine](https://cloud.google.com/kubernetes-engine) (GKE)\n  - _or_ a data center/edge or private cloud where you can deploy an upstream Kubernetes cluster.\n- (optional) Rafay's [RCTL utility](https://docs.rafay.co/cli/config/) installed and initialized on your local workstation.\n- An [ngrok account](https://ngrok.com/signup).\n- [kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl/) and [Helm\n  3.0.0+](https://helm.sh/docs/intro/install/) installed on your local\n  workstation.\n- A reserved domain, which you can get in the ngrok\n  [dashboard](https://dashboard.ngrok.com/domains) or with the [ngrok\n  API](/api/resources/reserved-domains/).\n  - You can choose from an ngrok subdomain or bring your own custom branded\n    domain, like `https://api.example.com`.\n  - We'll refer to this domain as `<NGROK_DOMAIN>`.\n\n## Create a new cluster with Rafay \n\nWe won't detail the steps to deploying a cluster with Rafay. For more information, find the [getting started](https://docs.rafay.co/learn/kops/) guide for your Kubernetes service, then click **Cluster Lifecycle Management**, which points you to the steps required to create and manage a new cluster with Rafay.\n\nTo prepare your cluster for the ngrok Kubernetes Operator and an app you'd like to make publicly accessible via a secure tunnel, you only need to finish the **Provision** part of Rafay's provider-specific getting started docs.\n\n## Prepare your cluster for the ngrok Kubernetes Operator \n\nBefore you create a Rafay blueprint for ingress managed by ngrok, you need to prepare your infrastructure in a way that works with Rafay's blueprints.\n\n1. In Rafay, create a namespace by clicking **Infrastructure&rarr;Namespaces**, then **New Namespace**. Enter **ngrok-operator** and under **Type**, select **Wizard**. Finally, click **Save**.\n\n   ![Create a new namespace](img/namespace-create.png)\n\n   Place the new namespace on your cluster. Click the **Placement** tab, select the cluster, and click **Save & Go To Publish&rarr;Publish**.\n\n   ![Publish the namespace](img/namespace-publish.png)\n\n1. Add a repository for the ngrok Kubernetes Operator to Rafay by clicking **Integrations&rarr;Repositories**. Give the repository a name like `ngrok-kubernetes-operator`.\n\n   In the **Endpoints** field, add the Helm repository, `https://charts.ngrok.com`, then click **Save**.\n\n1. Log in to the [ngrok dashboard](https://dashboard.ngrok.com/) to get your [ngrok Authtoken](https://dashboard.ngrok.com/get-started/your-authtoken) and create an [API key](https://dashboard.ngrok.com/api).\n\n1. Create a file on your local workstation named `ngrok-values.yaml` with the values below, replacing the defaults with your Authtoken and new API key.\n\n   ```yaml\n   credentials:\n     apiKey: <API_KEY>\n     authtoken: <AUTHTOKEN>\n   ```\n\n1. While you're in the ngrok dashboard, create an ngrok static subdomain for ingress. Navigate to the [**Domains**\n   section](https://dashboard.ngrok.com/domains) of the ngrok dashboard and click **Create Domain** or **New\n   Domain**. This static subdomain, which will look like `example.ngrok.app`, will be your `NGROK_DOMAIN` for the remainder of this guide.\n\n## Create and apply a blueprint for the ngrok Kubernetes Operator \n\nRafay uses [blueprints](https://docs.rafay.co/learn/quickstart/blueprint/blueprintlifecycle/overview/) to streamline cluster deployments and configuration of common services. They help your organization standardize an approach to security and reliability, with the option of [customization](https://docs.rafay.co/blueprints/custom_blueprint/) based on your specific needs.\n\nYou'll create a custom blueprint for the ngrok Kubernetes Operator that you or others could then quickly apply to any number of clusters managed by Rafay.\n\n1. Create a new Add-On by clicking **Infrastructure&rarr;Add-Ons**. Give it a name like `ngrok-k8s`, then choose **Helm 3** as the type. Choose to **Pull files from repository**, and **Helm** as the type.\n\n   ![Create an Add-On](img/add-on-create.png)\n\n   Click **New Version**, name it `v1`, and choose the repository you created in the previous step. The **Chart Name** should be `ngrok-operator` and the **Chart Version** `0.17.1` (or a more recent version).\n\n   Under the **Values File(s)** section, upload the `ngrok-values.yaml` file with your credentials.\n\n   ![Configuring the Add-On](img/add-on-config.png)\n\n1. Head over to the **Blueprints** section of the Rafay dashboard and click **New Blueprint**. Name it `ngrok`, and click **Save**.\n\n1. Give this blueprint a `v1` version name, then choose the `minimal` option from the **Base Blueprint** dropdown. Scroll down to the **Add-Ons**, section, where you can add the `ngrok` Add-On you just created.\n\n   ![Adding the Add-On to the blueprint](img/blueprint-addon.png)\n\n   Save your changes.\n\n1. Click **Infrastructure&rarr;Clusters**, then the **⚙** icon associated with your cluster. Select **Update Blueprint**, and choose `v1` of the **ngrok** blueprint.\n\n   Rafay will then apply the blueprint to your existing cluster, deploying new resources, like the ngrok Kubernetes Operator, as necessary.\n\n   ![Successful deployment of a cluster blueprint](img/blueprint-success.png)\n\n## Deploy an app with Rafay \n\nIn Rafay, workloads operate like infrastructure blueprints, but for app deployments. By defining a workload, you or your peers can deploy standardized clusters _and_ apps in multiple clouds and/or clusters.\n\nYou can deploy workloads directly from Rafay's catalog, but in this example, you'll create a custom workload using the [AKS Store Demo](https://github.com/Azure-Samples/aks-store-demo/tree/main), followed by an ingress configuration. Another option for creating workloads is Rafay's [RCTL](https://docs.rafay.co/learn/quickstart/applications/workloads/yaml/#__tabbed_1_2) CLI tool.\n\n1. Download the Kubernetes manifest for the AKS Store onto your local workstation.\n\n   ```bash\n   curl https://raw.githubusercontent.com/Azure-Samples/aks-store-demo/main/aks-store-quickstart.yaml -o aks-store-workload.yaml\n   ```\n\n1. Add the following ingress configuration to the bottom of your `aks-store-workload.yaml` file. This configuration defines how the ngrok Kubernetes Operator will route traffic arriving on `<NGROK_DOMAIN>` to the `store-front` service on port `80` as defined in the manifest.\n\n   ```yaml showLineNumbers\n   ---\n   apiVersion: networking.k8s.io/v1\n   kind: Ingress\n   metadata:\n     name: store-ingress\n     namespace: ngrok-operator\n   spec:\n     ingressClassName: ngrok\n     rules:\n       - host: <NGROK_DOMAIN>\n         http:\n           paths:\n             - path: /\n               pathType: Prefix\n               backend:\n                 service:\n                   name: store-front\n                   port:\n                     number: 80\n   ```\n\n1. Create a new workload from **Applications&rarr;Workloads**. Call your new workload `aks-store` and choose **K8s YAML** as the package type, ensuring you specify `ngrok-ingress-controller` as the namespace.\n\n1. In the **Upload Files** area, upload the `aks-store-workload.yaml` file you created. Under **Placement**, pick your cluster and move ahead to publishing the workload. Give your cluster a few minutes to provision the new AKS Store resources and configure the ngrok Kubernetes Operator.\n\n   ![Configuring the workload](img/create-workload.png)\n\n1. Navigate to your ngrok subdomain, e.g. `https://NGROK_DOMAIN`, in your browser to see your example app as managed, deployed, and publicly networked via Rafay, Kubernetes, and ngrok!\n\n   ![The AKS Store demo app accessible from the public internet](img/finished-ingress.png)\n\n   Behind the scenes, ngrok's cloud service routes requests into the ngrok Kubernetes Operator, which then passes it to the `store-front` service.\n\n## What's next?\n\nYou've now used the open source ngrok Kubernetes Operator to add public ingress to a demo app on a cluster managed by Rafay. Because ngrok abstracts ingress and middleware execution to its cloud service, and you have saved your configuration to Rafay as a blueprint and workload, you can deploy and manage additional versions of this app in a few clicks.\n\nAs you extend your internal catalog of blueprints and networks, you can enable self-service for developers who want to deploy apps without sacrificing on control or efficiency.\n\nLearn more about the ngrok Kubernetes Operator, or contribute to its ongoing development, by checking out the [GitHub repository](https://github.com/ngrok/ngrok-operator) and the [project-specific documentation](https://github.com/ngrok/ngrok-operator/tree/main/docs).\n",
			  "contentTitle": "Ingress to Kubernetes apps managed by Rafay"
			}
		  ],
		  "metadata": {
			"name": "rafay",
			"description": "",
			"excerpt": "",
			"title": "Rafay"
		  }
		},
		{
		  "name": "rancher",
		  "path": "/integrations/rancher",
		  "docs": [
			{
			  "path": "/integrations/rancher/k8s",
			  "frontMatter": {
				"title": "Kubernetes ingress to applications and clusters managed by Rancher",
				"description": "Set up a local installation of Rancher to deploy a new RKE2 cluster and add ingress to applications with ngrok's Kubernetes Operator."
			  },
			  "content": "\nThe ngrok [Operator for Kubernetes](https://ngrok.com/blog-post/ngrok-k8s) is the official controller for\nadding secure public ingress and middleware execution to your Kubernetes applications with ngrok's cloud service. With\nngrok, you can manage and secure traffic to your applications at every stage of the development lifecycle while also\nbenefitting from simpler configurations, security, and edge acceleration.\n\n[Rancher](https://github.com/rancher/rancher) is an open source multi-cluster orchestration management platform\ndeveloped by [SUSE](https://www.suse.com). DevOps teams use Rancher to make their multi-cluster and -cloud environments\nmore efficient, secure, and resilient, which in turn provides a better developer experience for developers building and\ndeploying cloud native applications.\n\nThe ngrok Kubernetes Operator and Rancher integrate to [overcome Kubernetes complexity and improve\ncollaboration](https://www.suse.com/c/overcoming-kubernetes-complexity-and-improving-collaboration/) through the\ncreation of an internal developer platform (IDP) or enabling developers to focus on building, not configuring, their\napplications.\n\nWith this guide, you'll launch Rancher's management platform, create a new RKE2 cluster, connect your cluster's ingress\nto ngrok using Rancher's Chart repository, and deploy a demo application, which will then be reachable to public traffic.\n\n## What you'll need\n\n- One or more Linux hosts that meet Rancher's\n  [requirements](https://ranchermanager.docs.rancher.com/v2.5/pages-for-subheaders/installation-requirements) for\n  operating as Kubernetes nodes. Your hosts can be local/on-prem virtual machines, cloud-based virtual machines, or bare\n  metal servers.\n- [Docker](https://docs.docker.com/engine/install/) installed locally.\n- An [ngrok account](https://ngrok.com/signup).\n- [kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl/) and [Helm\n  3.0.0+](https://helm.sh/docs/intro/install/) installed on your local\n  workstation.\n- The [ngrok Kubernetes Operator](/k8s/) installed on\n  your cluster. While you _can_ install the Operator via Rancher directly, we\n  recommend using our official Helm chart.\n- A reserved domain, which you can get in the ngrok\n  [dashboard](https://dashboard.ngrok.com/domains) or with the [ngrok\n  API](/api/resources/reserved-domains/).\n  - You can choose from an ngrok subdomain or bring your own custom branded\n    domain, like `https://api.example.com`.\n  - We'll refer to this domain as `<NGROK_DOMAIN>`.\n\n## Install Rancher via Docker \n\nTo follow along with this guide, you need Rancher installed on a local or remote Kubernetes cluster. If you already have\nan existing cluster running Rancher, you can skip this step and proceed to [Install a sample application](#install-a-sample-application).\n\nIn the following steps, you'll run Rancher, and create the Kubernetes cluster it runs on, within a Docker container.\nThis simple, local-only installation option should be used only for [test and demonstration\npurposes](https://ranchermanager.docs.rancher.com/pages-for-subheaders/installation-and-upgrade#docker-install). You\ncan, however, use the Rancher backup operator to\n[migrate](https://ranchermanager.docs.rancher.com/how-to-guides/new-user-guides/backup-restore-and-disaster-recovery/migrate-rancher-to-new-cluster)\nthis Docker container-based installation to a production-ready, high-availability Kubernetes cluster.\n\nThe following steps also assume you have already provisioned one or more Linux hosts that will operate as nodes for the\nnew Kubernetes cluster managed by Rancher.\n\n<Note>\nAnother viable option is to launch a single Linux virtual machine on your local workstation or with a cloud provider to host a K3s cluster for [installing Rancher with Helm](https://ranchermanager.docs.rancher.com/getting-started/quick-start-guides/deploy-rancher-manager/helm-cli). If you choose that option, you can skip ahead to [Step 2: Install the ngrok Ingress\nController](#install-a-sample-application) once you’ve finalized your K3s cluster.\n</Note>\n\n1. Launch the Rancher server in a detached, privileged Docker container. With this configuration, you'll access Rancher on `localhost` using a specific port.\n\n```bash\ndocker run --privileged --restart=unless-stopped -d -p 81:80 -p 444:443 rancher/rancher:latest\n```\n\n1. Once Docker finishes running, check to ensure your Rancher container is running properly.\n\n```bash\ndocker ps\nCONTAINER ID   IMAGE                    COMMAND           CREATED        STATUS             PORTS                                                                      NAMES\nd43eceb2e5b2   rancher/rancher:latest   \"entrypoint.sh\"   About a minute ago   Up About a minute   0.0.0.0:81->80/tcp, :::81->80/tcp, 0.0.0.0:444->443/tcp, :::444->443/tcp   vigilant_clarke\n```\n\n1. Navigate to `https://localhost:444` in your browser, which will warn you about self-signed SSL certificates. Pass\n   through that warning, which will show you a prompt from Rancher asking for your **bootstrap password**, which you\n   need to initialize Rancher. Copy and paste that command into your terminal, replacing `[DOCKER_NAME]` with the name\n   output using `docker ps`.\n\n```bash\ndocker logs [DOCKER_NAME] 2>&1 | grep \"Bootstrap Password:\"\n```\n\n1. Copy the terminal output into the password input and click **Log in with Local User**. Next, choose between a\n   randomly-generated password or one of your choosing to initialize the **admin** user.\n\n1. The **Server URL** field will default to `https://localhost:444`, but your worker nodes won't be able to connect to\n   Rancher in this configuration. Find your local IP address—try `hostname -I` for Linux or `ipconfig getifaddr en0` on macOs—which will look similar to `192.168.1.123`, and\n   replace `localhost` with it, similar to the following: `https://192.168.1.107:444`.\n\n   ![Configure the Rancher installation URL](img/rancher_install-url.png)\n\n   When the Rancher dashboard loads, Rancher should have already deployed a single K3s-based cluster named `local`—click on the cluster's name to explore. Rancher recommends that its server management and your workloads run on separate clusters, which is what you'll do next.\n\n1. Create a new [RKE2](https://docs.rke2.io/) cluster by clicking **Create** in your Rancher dashboard home, then\n   **Custom** to deploy a custom cluster. Give your cluster a name, and under the **System Services** heading, uncheck\n   **NGINX Ingress**, as you'll add ngrok-based ingress in the next step. Click **Create** to initialize the cluster.\n\n   ![Configure the RKE2 cluster](img/rancher_cluster-config.png)\n\n1. Register your Linux node(s) with your RKE2 cluster. Leave the **Node Role** options at their defaults, and under the\n   **Registration Command** heading and command example, click the **Insecure** checkbox.\n\n   ![Configure the agent registration command](img/rancher_cluster-agent.png)\n\n   Once you copy-paste the command into your Linux node and execute it, your new cluster will begin bootstrapping the\n   node. When Rancher finishes bootstrapping your node(s), you can navigate to the **Cluster Dashboard** for your RKE2\n   cluster, explore deployed resources, and see basic usage metrics.\n\n1. Set up `kubectl` to manage your RKE2 cluster. At the top of the Cluster Dashboard, click the **Copy KubeConfig to\n   Clipboard** option.\n\n   ![Copy the RKE2 cluster's configuration to your clipboard](img/rancher_cluster-kubeconfig.png)\n\n   Paste the content of your clipboard into your `~/.kube/config` file.\n\n1. Ensure your new RKE2 cluster is active by getting the namespaces for your instance. Your list of namespaces should\n   look like the following:\n\n   ```bash\n   kubectl get namespaces\n\n   NAME                          STATUS   AGE\n   calico-system                 Active   4m\n   cattle-impersonation-system   Active   29s\n   cattle-system                 Active   5m\n   default                       Active   5m4s\n   kube-node-lease               Active   5m6s\n   kube-public                   Active   5m6s\n   kube-system                   Active   5m6s\n   local                         Active   23s\n   tigera-operator               Active   4m10s\n   ```\n\nYou have now installed Rancher in a Docker container, created a new Kubernetes cluster for your applications, and\nconnected one or more Linux nodes to Rancher for handling future workloads.\n\n## Install a sample application \n\nNow that you have the ngrok Kubernetes Operator running and authenticated with your credentials, you're ready to add a\nsample application to your cluster. The ngrok Kubernetes Operator will connect this application to the ngrok cloud service,\nsimplifying how you route external traffic through your Rancher-managed cluster.\n\n1. Create a ngrok static subdomain for ingress if you don't have one already. Navigate to the [**Domains**\n   section](https://dashboard.ngrok.com/domains) of the ngrok dashboard and click **Create Domain** or **New\n   Domain**. This static subdomain will be your `<NGROK_DOMAIN>` for the remainder of this guide.\n\n   Creating a subdomain on the ngrok network provides a public route to accept HTTP, HTTPS, and TLS traffic.\n\n1. Create a new Kubernetes manifest (`2048.yaml`) with the below contents. This manifest defines the 2048 application\n   service and deployment, then configures the ngrok Kubernetes Operator to connect the `game-2048` service to the ngrok\n   edge via your `<NGROK_DOMAIN>`.\n\n   ```yaml showLineNumbers\n   apiVersion: v1\n   kind: Service\n   metadata:\n     name: game-2048\n   spec:\n     ports:\n       - name: http\n         port: 80\n         targetPort: 80\n     selector:\n       app: game-2048\n   ---\n   apiVersion: apps/v1\n   kind: Deployment\n   metadata:\n     name: game-2048\n   spec:\n     replicas: 1\n     selector:\n       matchLabels:\n         app: game-2048\n     template:\n       metadata:\n         labels:\n           app: game-2048\n       spec:\n         containers:\n           - name: backend\n             image: alexwhen/docker-2048\n             ports:\n               - name: http\n                 containerPort: 80\n   ---\n   # ngrok Kubernetes Operator configuration\n   apiVersion: networking.k8s.io/v1\n   kind: Ingress\n   metadata:\n     name: game-2048-ingress\n   spec:\n     ingressClassName: ngrok\n     rules:\n       - host: <NGROK_DOMAIN>\n         http:\n           paths:\n             - path: /\n               pathType: Prefix\n               backend:\n                 service:\n                   name: game-2048\n                   port:\n                     number: 80\n   ```\n\n1. Apply the `2048.yaml` manifest to your RKE2 cluster.\n\n   ```bash\n   kubectl apply -f 2048.yaml\n   ```\n\n1. Access your 2048 demo app by navigating to your ngrok subdomain, e.g. `https://one-two-three.ngrok.app`.\n   ngrok's edge and your Operator will route traffic to your app from any device or external network as long\n   as your Rancher server and application cluster remain operational.\n\n## What's next?\n\nYou've now used the open source ngrok Kubernetes Operator to add public ingress to your Rancher-managed\ncluster and sample application without worrying about IPs, network interfaces, or VPC routing. Because ngrok offloads\ningress and middleware execution to its global edge, you can follow a similar procedure for Rancher-managed clusters in\nany on-prem or cloud Kubernetes environment, like EKS, GKE, and more.\n\nAfter deploying this proof-of-concept environment, you can take your integration between Rancher and the ngrok Ingress\nController in several directions.\n\n### Backup and/or migrate to a high-availability Rancher installation\n\nBackups are always a good idea to prevent data loss, and are also the best way to convert your Docker-based installation\nof Rancher into a production-grade environment that leverages the ngrok cloud service to handle ingress with no additional\nconfiguration.\n\n1. [Back up your Rancher installation](https://ranchermanager.docs.rancher.com/how-to-guides/new-user-guides/backup-restore-and-disaster-recovery/back-up-docker-installed-rancher)\n   using a sequence of `docker ...` commands to create a data container and a backup tarball.\n2. [Migrate your installation](https://ranchermanager.docs.rancher.com/how-to-guides/new-user-guides/backup-restore-and-disaster-recovery/migrate-rancher-to-new-cluster)\n   to a new cluster using the backup tarball as the data source.\n\n### Clean up\n\nBecause you installed Rancher and deployed your application cluster via Docker, you can clean up by stopping the Rancher\ncontainer and removing its contents from your local workstation, replacing `[DOCKER_NAME]` with the name of your Rancher\ncontainer.\n\n```bash\ndocker stop [DOCKER_NAME] && docker rm [DOCKER_NAME]\n```\n\nYou can also now clean up your Linux host, either by following the [Rancher node cleanup\ndoc](https://ranchermanager.docs.rancher.com/how-to-guides/new-user-guides/manage-clusters/clean-cluster-nodes#cleaning-up-nodes)\nor, in the case of a disposable VM, deleting it entirely.\n\n### Extend your Rancher and ngrok Kubernetes Operator integration\n\nThis combination of cluster management and secure, cloud-based public ingress can become a robust development\nenvironment for those still onboarding into the cloud native ecosystem or scale up to a multi-cluster production\nsystem&mdash;all with simpler and more secure ingress from ngrok.\n\nLearn more about the ngrok Kubernetes Operator, or contribute, by checking out the [GitHub\nrepository](https://github.com/ngrok/ngrok-operator) and the [Kubernetes docs](/k8s/).\n",
			  "contentTitle": "Kubernetes ingress to applications and clusters managed by Rancher"
			}
		  ],
		  "metadata": {
			"name": "rancher",
			"description": "",
			"excerpt": "",
			"title": "Rancher"
		  }
		},
		{
		  "name": "salesforce",
		  "path": "/integrations/salesforce",
		  "docs": [
			{
			  "path": "/integrations/salesforce/dashboard-sso-with-oidc",
			  "frontMatter": {
				"title": "Salesforce Dashboard Single Sign-On (SSO) Using OIDC",
				"description": "Use Salesforce's managed applications to add SSO for your ngrok dashboard using the OIDC integration"
			  },
			  "content": "\nThis guide walks you through enabling Salesforce as an Identity Provider to allow single sign-on (SSO) into your ngrok dashboard.\nThis should not be confused with securing your ngrok edge to allow your application users to log in using Salesforce.\n\n## What you'll need\n\n- Administrative access to create new applications in Salesforce\n- Admin access to edit your ngrok account settings\n- An ngrok Enterprise account or an SSO/Account Governance license\n\nYou may also want to consult the Saleforce documentation on [configuring an authentication provider using OpenID Connect](https://help.salesforce.com/s/articleView?id=xcloud.sso_provider_openid_connect.htm&type=5).\n\n<Note>\nThe OIDC flow is initiated from your Applications login page.\n(OIDC Service Provider flow is not supported.)\n</Note>\n\n## 1. Configure Salesforce\n\nBegin by creating a new External Client App in Salesforce:\n\n![Create External Client App](img/external_client_create.png)\n\nConfigure your new external app according to the following criteria:\n\n1.  In the **Policies** tab:\n    - Go to **App Policies**\n      - Set Start Page to Custom\n      - Set Custom Start URL to `https://dashboard.ngrok.com/login/sso`\n2.  In the **Settings** tab:\n    - Go to **Basic Information** and set the External Client App Name\n    - Go to **OAuth Settings > App Settings**:\n      - Set the OAuth Scopes:\n        - Access the Identity URL Service (id, profile, email, address, phone)\n        - Access unique identifiers (openid)\n        - Access custom permissions (custom_permissions)\n      - Set Configure ID Token:\n        - Set ID Token Audience to: `https://idp.ngrok.com`\n        - Set Include Standard Claims\n        - Set Custom Attributes\n      - Flow Enablement:\n        - Set Enable Authorization Code and Credentials Flow\n      - Security:\n        - Set Require Secret for Web Server Flow\n        - Set Require Secret for Refresh Token Flow\n\nFinally, note your Client ID (Consumer Key) and Secret—these can be found in **OAuth Settings > App Settings**:\n\n![Client ID and Secret](img/keyandsecret.png)\n\n## 2. Configure ngrok\n\nNow, configure SSO for your ngrok account:\n\n1. Log into your ngrok dashboard and navigate to **Settings > Account**.\n2. Click **+ New Identity Provider** and select **New OpenID Connect Provider**.\n   ![Add Identity Provider](img/new_oidc_provider.png)\n3. Add a description and set the following details:\n   - Issuer URL, in the format `[yourdomain]-dev-ed.develop.lightning.force.com`\n   - Client ID (from Salesforce)\n   - Client Secret (from Salesforce)\n\n![ngrok Identity Provider Configuration](img/oidc_settings_dash.png)\n\nYou should now be configured properly to log into your ngrok account using Salesforce.\n\nBy default, users will still be able to log into ngrok with their existing credentials as well as through Salesforce—this is known as \"mixed mode.\"\nOnce you verify that everything is working properly with your integration, you can enforce SSO in the ngrok dashboard and require all new users to log in through Salesforce for their ngrok account.\n",
			  "contentTitle": "Salesforce Dashboard Single Sign-On (SSO) Using OIDC"
			},
			{
			  "path": "/integrations/salesforce/ssowithendpoints",
			  "frontMatter": {
				"title": "Secure ngrok Endpoints using Salesforce OpenID Connect",
				"description": "Use Salesforce's managed applications to add SSO for your ngrok resources"
			  },
			  "content": "\nIn this guide shows you how to use Salesforce as:\n\n- An OAuth provider along with the ngrok OIDC traffic policy action to secure your ngrok resources.\n- The primary IdP for your endpoints. The OIDC traffic policy action will supplement an ID token that will be used to identify users that log in to your endpoint.\n\nSince Salesforce is currently not a supported OAuth provider by ngrok, this allows you to leverage its OAuth capabilities and add an extra layer of authorization to your endpoints.\n\n## Why use OIDC to secure your endpoints\n\nThe OIDC traffic policy action allows you to control access to your upstream services and also configure routing based on the information that ngrok stores about user’s authentication/authorization status.\n\n## Why use Salesforce as an IdP\n\nUsing salesforce OAuth enables you to give users of your application, API, Database, SSO without needed separate credentials. Ngrok also handles that authentication transparently. Your organization’s personnel in charge of security and administration can also manage all external application integrations from one place.\n\n## What you'll need\n\n- a Salesforce developer account with administrative rights to create apps\n- An ngrok Enterprise Account with an authtoken or admin access to configure an endpoint with Traffic Policy and OpenID Connect.\n\n## 1. Create a Salesforce External Client App\n\n1. Navigate to the **App Manager** in Salesforce.\n2. Click on **New External Client App**.\n\n![Salesforce Setup](img/external_client_create.png)\n\n## 2. Configure the External Client App\n\n1. Go to the **Policies** tab in your Salesforce dashboard\n2. Go to **App Policies**\n3. Set the start page to OAuth\n\n## 3. Configure OAuth Settings\n\n1. In the Basic Information Section\n   - Set the external client app name to `ngrok` or whatever you would like\n2. Go to the OAuth Settings section\n   - Under App Settings--> OAuth Policies\n     - Set the Callback URL to `https://idp.ngrok.com/oauth2/callback`\n     - Make sure \"All Users can self authorize\" is checked\n     - Make sure the following scopes are selected\n       ![OAuth Scopes](img/oauthscopes.png)\n     - Use the cloud endpoint URL you create in the next step as your **OAuth Start URL**\n     - Under Permitted Users, make sure all users can self authorize\n   - Under Flow Enablement\n     - Enable Authorization Code and credentials flow\n   - Under Security\n     - Check require secret for Web Server flow\n     - Require secret for Refresh Token Flow\n     - Make sure Require Proof Key for Code Exchange (PKCE) is not enabled, as this will throw an error when you log in to your endpoint\n\n## 4. Verify your Salesforce External Client Application Configuration\n\n![Final OAuth Config](img/oauthconfig.png)\n\n## 5. Obtain the Client ID and Client Secret\n\n1. After saving your external client app, go to **Settings** and then under **OAuth Settings** click on the following button to see your Client ID and Client Secret:\n\n![Client ID and Client Secret](img/keyandsecret.png)\n\n## 6. Create a Cloud Endpoint and Configure OIDC Traffic Policy Action\n\n1. Log in to your ngrok dashboard and navigate to the **Endpoints** section.\n2. Click on **Create Endpoint**.\n3. Select **Cloud Endpoint**\n4. Follow the steps found here:\n   [Create a Cloud Endpoint](/getting-started/cloud-endpoints-quickstart/#dashboard) to create your cloud endpoint.\n5. Add the following traffic policy to your endpoint:\n\n```yaml\ntraffic_policy:\n  actions:\n    - type: oidc\n      issuer_url: <your-salesforce-issuer-url>\n      client_id: <your-salesforce-client-id>\n      client_secret: <your-salesforce-client-secret>\n      scopes:\n        - openid\n        - profile\n        - email\n```\n\n6. Replace `<your-salesforce-issuer-url>`, `<your-salesforce-client-id>`, and `<your-salesforce-client-secret>` with the values you obtained from Salesforce in the previous steps. The issuer URL will follow the format: `https://[yourdomain]-dev-ed.develop.my.salesforce.com`\n7. Click save.\n\nYou have now successfully created a cloud endpoint with OIDC traffic policy action using Salesforce as an IdP.\n\n## (Optional) Configure an Agent Endpoint with Salesforce OAuth from the CLI\n\nYou can also use the following command to start an agent endpoint with the same credentials you used in your traffic policy. To learn more about when\nto use Agent vs Cloud endpoints, check out our [documentation on endpoints](/universal-gateway/endpoints/).\n\n```bash\nngrok http 3000 --oidc <salesforce_url> \\\n--oidc-client-id <salesforce_client_id> \\\n--oidc-client-secret <salesforce_client_secret> \\\n--url <domain>\n```\n",
			  "contentTitle": "Secure ngrok Endpoints using Salesforce OpenID Connect"
			}
		  ],
		  "metadata": {
			"name": "salesforce",
			"description": "",
			"excerpt": "",
			"title": "Salesforce"
		  }
		},
		{
		  "name": "sendgrid",
		  "path": "/integrations/sendgrid",
		  "docs": [
			{
			  "path": "/integrations/sendgrid/webhooks",
			  "frontMatter": {
				"description": "Develop and test SendGrid webhooks from localhost",
				"title": "SendGrid Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate SendGrid webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure SendGrid webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with SendGrid by using Webhooks.\nSendGrid webhooks can be used to notify an external application with information about events that occur as SendGrid processes your email.\n\nBy integrating ngrok with SendGrid, you can:\n\n- **Develop and test SendGrid webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from SendGrid** in real-time via the inspection UI and API.\n- **Modify and Replay SendGrid Webhook requests** with a single click and without spending time reproducing events manually in your SendGrid account.\n- **Secure your app with SendGrid validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with SendGrid).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate SendGrid \n\nTo register an event webhook to your SendGrid account follow the instructions below:\n\n1. Access the [SendGrid Dashboard](https://app.sendgrid.com/), and then sign in using your SendGrid credentials.\n\n1. On the left menu, click **Settings** and then click **Mail Settings**.\n\n1. In the **Mail Settings** page, click **Event Webhook**.\n\n1. In the **Event Webhook** popup, select `None` as the **Authorization Method** and in the **HTTP Post URL** field enter the URL provided by the ngrok agent to expose your application to the internet (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![Configure URL](img/ngrok_url_configuration_sendgrid.png)\n\n1. Click **Test Your Integration** and confirm your localhost app receives information about this test.\n\n1. Under **DELIVERABILITY DATA**, select the **Select All** option.\n\n1. Under **Event Webhook Status**, click **ENABLED** and then click **Save**.\n\n### Run Webhooks with SendGrid and ngrok\n\nTo activate the webhook you need to send an email through SendGrid. SendGrid processes your email and upon successful or failed delivery notifies your localhost application accordingly.\n\nTo send an email you can either use SendGrid Web API or SMTP.\n\n1. In the SendGrid UI, click **Email API** on the left menu, and then click **Integration Guide**.\n\n1. In the **Integrate using our Web API or SMTP Relay** page, click **Choose** in the **Web API** tile, and then click **Choose** in the **cURL** tile.\n\n1. In the **My First API Key Name** field, type `myappkey`, and then click **Create Key**.\n\n1. Open a terminal on your desktop, run the command to export the SendGrid API Key, and then run the curl command.\n   **Note**: Replace the `email from` field with the email you have registered in SendGrid as sender identity.\n   **Note**: Replace the `email to` field with a real email in which you can confirm the email receipt.\n\nConfirm your localhost app receives notifications about the email being both processed and delivered.\n\n**Tip:** SendGrid sends different request body contents depending on the event you select during the webhook registration.\n\n1. Optionally, in the SendGrid UI, click **Activity**, and then click **Search**.\n\nConfirm the delivery of the email you have sent using the SendGrid Web API.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your SendGrid webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Access the [SendGrid Dashboard](https://app.sendgrid.com/), and then sign in using your SendGrid credentials.\n\n1. On the left menu, click **Settings** and then click **Mail Settings**.\n\n1. In the **Mail Settings** page, click **Signed Event Webhook Requests**.\n\n1. In the **Signed Event Webhook Requests** popup window, click **Generate Verification Key**, copy the value of the key that appears in the page, and then click **Close**.\n   **Tip**: Make sure the **Signed Event Webhook Request Status** is **ENABLED**.\n\n1. Create a traffic policy file named `sendgrid_policy.yml`, replacing `{your verification key}` with the value you copied before:\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: sendgrid\n             secret: \"{your verification key}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file sendgrid_policy.yml\n   ```\n\n1. Reproduce the steps to send an email through your SendGrid account.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "SendGrid Webhooks"
			}
		  ],
		  "metadata": {
			"name": "sendgrid",
			"description": "",
			"excerpt": "",
			"title": "SendGrid"
		  }
		},
		{
		  "name": "sentry",
		  "path": "/integrations/sentry",
		  "docs": [
			{
			  "path": "/integrations/sentry/webhooks",
			  "frontMatter": {
				"description": "Develop and test Sentry webhooks from localhost",
				"title": "Sentry Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Sentry webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Sentry webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Sentry by using Webhooks.\nSentry webhooks can be used to notify an external application whenever specific events occur in your Sentry projects.\n\nBy integrating ngrok with Sentry, you can:\n\n- **Develop and test Sentry webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Sentry** in real-time via the inspection UI and API.\n- **Modify and Replay Sentry Webhook requests** with a single click and without spending time reproducing events manually in your Sentry account.\n- **Secure your app with Sentry validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Sentry).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Sentry \n\nTo register a webhook on your Sentry account follow the instructions below:\n\n1. Access [Sentry](https://sentry.io/) and sign in using your Sentry account.\n\n1. On your Sentry organization page, click **Settings** on the left menu, click **Developer Settings** on the Organization sub-menu, and then click **Create new integration**.\n\n1. On the **Choose Integration Type** popup, choose **Internal Integration** and then click **Next**.\n\n1. On the **Create Internal Integration** page, enter `My Local App Webhook` in the **Name** field and then enter the URL provided by the ngrok agent to expose your application to the internet in the **Webhook URL** field (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![URL to Publish](img/ngrok_url_configuration_sentry.png)\n\n1. Under the **PERMISSIONS** section, select **Read & Write** for the **Issue & Event** field, click the **issue** checkbox under the **WEBHOOKS** section, and then click **Save Changes**.\n\n### Run Webhooks with Sentry and ngrok \n\nSentry sends different request body contents depending on the event that is being triggered.\nYou can trigger new calls from Sentry to your application by following the instructions below.\n\n1. On your Sentry organization page, click **Issues** on the left menu.\n\n1. On the **Issues** page, open an issue by clicking its name.\n\n   **Note**: If you don't have any issues click **Create a sample event**.\n\n1. Click **Resolve**.\n\n   Confirm your localhost app receives a notification and logs both headers and body in the terminal.\n\nOptionally, you can verify the log of the webhook call in Sentry:\n\n1. On the left menu, click **Settings**, click **Developer Settings**, and then click **Dashboard** for **My Local App Webhook**.\n   ![Webhook Logs](img/ngrok_logs_sentry.png)\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Sentry webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Access [Sentry](https://sentry.io/) and sign in using your Sentry account.\n\n1. On your Sentry organization page, click **Settings** on the left menu, click **Developer Settings** on the Organization sub-menu, click **My Local App Webhook**, and then copy the value of the **Client Secret** field under the **CREDENTIALS** section.\n\n1. Create a traffic policy file named `sentry_policy.yml`, replacing `{your client secret}` with the value you have copied before (See [Integrate ngrok and Sentry.](#setup-webhook)):\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: sentry\n             secret: \"{your client secret}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file sentry_policy.yml\n   ```\n\n1. Repeat the steps in the [Run Webhooks with Sentry and ngrok](#run-webhook) section to create and resolve an issue.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "Sentry Webhooks"
			}
		  ],
		  "metadata": {
			"name": "sentry",
			"description": "",
			"excerpt": "",
			"title": "Sentry"
		  }
		},
		{
		  "name": "shopify",
		  "path": "/integrations/shopify",
		  "docs": [
			{
			  "path": "/integrations/shopify/webhooks",
			  "frontMatter": {
				"description": "Develop and test Shopify webhooks from localhost",
				"title": "Shopify Webhook"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Shopify webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Shopify webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Shopify by using Webhooks.\nShopify webhooks can be used to notify an external application whenever specific events occur in your Shopify store.\n\nBy integrating ngrok with Shopify, you can:\n\n- **Develop and test Shopify webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Shopify** in real-time via the inspection UI and API.\n- **Modify and Replay Shopify Webhook requests** with a single click and without spending time reproducing events manually in your Shopify store.\n- **Secure your app with Shopify validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n<Tip>\n**TL;DR**\n\n\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n2. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n3. [Configure Shopify webhooks with your ngrok URL.](#setup-webhook)\n\n4. **Bonus!** [Secure your webhook requests with verification.](#security)\n</Tip>\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Shopify).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Shopify \n\nTo register a webhook to your Shopify store follow the instructions below:\n\n1. Sign in to your Shopify account, select your store, and then click **Settings** at the bottom of the left menu on the admin page.\n\n1. In the **Settings** page, click **Notifications** in the left menu, scroll down to the **Webhooks** section and then click **Create webhook**.\n\n1. In the **Add webhook** popup, select **Product creation** for the **Event** field and make sure **JSON** is selected as the **Format**.\n\n1. In the **URL** field enter the URL provided by the ngrok agent to expose your application to the internet (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![Configure URL](img/ngrok_url_configuration_shopify.png)\n\n1. For the **Webhook API version** field, select any value containing the `(Latest)` text and then click **Save**.\n\n1. Optionally, in the **Webhooks** section, Shopify shows a key that will be used to sign all calls to your application. Make a copy of this value for later use.\n\n### Run Webhooks with Shopify and ngrok\n\nThe **Webhooks** section allows you to test your Webhook by clicking the **Send test notification** button. Use this feature to send a test notification to your application through ngrok.\n\nBecause you registered your webhook for the **Product creation** event, any product you create triggers a notification to your application. Create a product following the instructions below:\n\n1. Access your Shopify store admin page, click **Products** in the left menu, and then click **Add product** on the **Products** page.\n\n1. In the **Add product** page, provide a **Title** for the product, a **Price**, an **SKU** value, and then click **Save** at the bottom of the page.\n\nConfirm your localhost app receives notifications about the product you've just created.\n\n**Tip:** Shopify sends different request body contents depending on the event you select during the webhook registration.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Shopify webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. In the **Webhooks** section of the **Notifications** page, Shopify shows a value after the **All your webhooks will be signed with** message. Copy this value.\n\n1. Create a traffic policy file named `shopify_policy.yml`:\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: shopify\n             secret: \"{your signing secret}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file shopify_policy.yml\n   ```\n\n1. Access your Shopify store admin page, click **Products** in the left menu, and then create a new product.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "Shopify Webhook"
			}
		  ],
		  "metadata": {
			"name": "shopify",
			"description": "",
			"excerpt": "",
			"title": "Shopify"
		  }
		},
		{
		  "name": "signalsciences",
		  "path": "/integrations/signalsciences",
		  "docs": [
			{
			  "path": "/integrations/signalsciences/webhooks",
			  "frontMatter": {
				"description": "Develop and test Signal Sciences webhooks from localhost",
				"title": "Signal Sciences Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Signal Sciences webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Signal Sciences webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Signal Sciences by using Webhooks.\nSignal Sciences webhooks can be used to notify an external application whenever specific events occur in your Signal Sciences account.\n\nBy integrating ngrok with Signal Sciences, you can:\n\n- **Develop and test Signal Sciences webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Signal Sciences** in real-time via the inspection UI and API.\n- **Modify and Replay Signal Sciences Webhook requests** with a single click and without spending time reproducing events manually in your Signal Sciences account.\n- **Secure your app with Signal Sciences validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Signal Sciences).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Signal Sciences \n\nTo register a webhook on your Signal Sciences account follow the instructions below:\n\n1. Access the [Signal Sciences Dashboard](https://dashboard.signalsciences.net/) and sign in using your Signal Sciences account.\n\n1. On the **Dashboard** page, select your site from the **Sites** drop-down menu on the top of the screen, click **Site Manage** on the top menu, click **Site Integrations**, and then click **Add site integration**.\n\n1. On the **Add site integration** page, click **Generic Webhook**.\n\n1. On the **Generic Webhook** page, enter the URL provided by the ngrok agent to expose your application to the internet in the **Webhook URL** field (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![signalsciences URL to Publish](img/ngrok_url_configuration_signalsciences.png)\n\n1. Select **All activity** and then click **Create site integration**.\n\n### Run Webhooks with Signal Sciences and ngrok\n\nSignal Sciences sends different request body contents depending on the event that is being triggered.\nYou can trigger new calls from Signal Sciences to your application by following the instructions below.\n\n1. Access the [Signal Sciences Dashboard](https://dashboard.signalsciences.net/), sign in, and change your site display name.\n\n   Confirm your localhost app receives an event notification and logs both headers and body in the terminal.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Signal Sciences webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Access the [Signal Sciences Dashboard](https://dashboard.signalsciences.net/), sign in, click **Site Integrations** in the **Manage** menu, and then click on your webhook.\n\n1. On the **Webhook** page, click the eye icon to reveal the **secret key** value and then copy this value.\n\n1. Create a traffic policy file named `signalsciences_policy.yml`, replacing `{your webhook secret}` with the value you have copied before:\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: signalsciences\n             secret: \"{your webhook secret}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file signalsciences_policy.yml\n   ```\n\n1. Access the [Signal Sciences Dashboard](https://dashboard.signalsciences.net/), sign in, and change your site display name.\n\n   Confirm your localhost app receives an event notification and logs both headers and body in the terminal.\n",
			  "contentTitle": "Signal Sciences Webhooks"
			}
		  ],
		  "metadata": {
			"name": "signalsciences",
			"description": "",
			"excerpt": "",
			"title": "Signal Sciences"
		  }
		},
		{
		  "name": "slack",
		  "path": "/integrations/slack",
		  "docs": [
			{
			  "path": "/integrations/slack/webhooks",
			  "frontMatter": {
				"description": "Develop and test Slack webhooks from localhost",
				"title": "Slack Webhook"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Slack webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Slack webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Slack using Webhooks.\nSlack webhooks can be used to notify an external application whenever specific events occur in your Slack account.\nSlack requires your application to be available through an HTTPS endpoint.\n\nBy integrating ngrok with Slack, you can:\n\n- **Develop and test Slack webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Slack** in real-time via the inspection UI and API.\n- **Modify and Replay Slack Webhook requests** with a single click and without spending time reproducing events manually in your Slack account.\n- **Secure your app with Slack validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n`npm run startSlack`\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app runs successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken.\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Slack).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Slack \n\nTo register a webhook with your Slack account, follow the instructions below:\n\n1. Access the [Slack Web app](https://app.slack.com/) and sign in using your Slack account.\n   **Tip**: There is no need to open the slack app on your desktop for now. Continue with the **use Slack in your browser** option.\n\n1. In the same browser tab, access the [Slack API portal](https://api.slack.com/apps) and then click **Create an App**.\n   **Tip**: If you already have some apps created, click \\*\\*\\*\\*.\n\n1. In the **Create an app** window, click **From scratch**, provide the **App Name**, select a workspace under **Pick a workspace to develop your app in**, and then click **Create App**.\n\n1. In the **Basic Information** page, expand **Add features and functionality** and then click **Event Subscriptions**.\n\n1. In the **Event Subscriptions** page, click the **Enable Events** slider to turn it on. In the **Request URL** field, enter the URL provided by the ngrok agent to expose your application to the internet (i.e., `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![Slack Request URL](img/ngrok_url_configuration_slack.png)\n\n   **Note**: Slack makes a one-time call to your app. It sends a challenge parameter as part of the request body and expects the app to respond with this value. See the [Slack documentation](https://api.slack.com/apis/events-api#handshake) for more information.\n\n1. On the same page, expand **Subscribe to events on behalf of users**, click **Add Workspace Event**, select `message.im`, and then click **Save Changes**.\n   **Tip**: More about Slack event types [here](https://api.slack.com/events).\n\n1. In the left menu, click **Install App**, click **Install to Workspace**, and then click **Allow** to allow your application to access your workspace.\n\n### Run Webhooks with Slack and ngrok\n\nBecause you've subscribed to the `message.im` event and installed your app to your slack workspace, you now can direct message any person in the workspace to make Slack call your localhost application:\n\n1. Access the [Slack Web app](https://app.slack.com/) or open the slack app on your desktop, and verify that your application appears under **Apps** in the left menu.\n\n1. Select one person in your workspace and send the person a message. Alternatively, you can select the **Slackbot**, write `Hello Slack bot!` in the message field, and then send it.\n\nConfirm your localhost app receives notifications about the message.\n\n**Tip:** Slack sends different request body contents and headers depending on the trigger event.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Slack webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. In the **Basic Information** page for your Slack app, click **Show** for the **Signing Secret** and copy the value that appears.\n\n1. Create a traffic policy file named `slack_policy.yml` with the following content, replacing `{your signing secret}` with your **Signing Secret** from Slack:\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: slack\n             secret: \"{your signing secret}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file slack_policy.yml\n   ```\n\n1. In your Slack app, select the **Slackbot**, write `Hello Slack bot!` in the message field, and then send it.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "Slack Webhook"
			}
		  ],
		  "metadata": {
			"name": "slack",
			"description": "",
			"excerpt": "",
			"title": "Slack"
		  }
		},
		{
		  "name": "sonatype-nexus",
		  "path": "/integrations/sonatype-nexus",
		  "docs": [
			{
			  "path": "/integrations/sonatype-nexus/webhooks",
			  "frontMatter": {
				"description": "Develop and test Sonatype Nexus webhooks from localhost",
				"title": "Sonatype Nexus Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Sonatype Nexus webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Sonatype Nexus webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Sonatype Nexus by using Webhooks.\nSonatype Nexus webhooks can be used to notify an external application whenever specific events occur in your Sonatype Nexus account.\n\nBy integrating ngrok with Sonatype Nexus, you can:\n\n- **Develop and test Sonatype Nexus webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Sonatype Nexus** in real-time via the inspection UI and API.\n- **Modify and Replay Sonatype Nexus Webhook requests** with a single click and without spending time reproducing events manually in your Sonatype Nexus account.\n- **Secure your app with Sonatype Nexus validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Sonatype Nexus).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Sonatype Nexus \n\nTo register a webhook on your Sonatype Nexus repository follow the instructions below:\n\n1. Access your **Sonatype Nexus Repository Manager** user interface and sign in using your administration account.\n   **Tip**: The user interface URL depends on where you deployed your repository manager.\n\n1. On the left menu, click **System**, click **Capabilities**, and then click **Create capability** on the **Capabilities** page.\n\n1. On the **Select Capability Type** click either **Webhook: Global** or **Webhook: Repository** depending on which type of event you associate with your webhook. In this example, click **Webhook: Global**.\n\n1. On the **Create Webhook** page, enter the URL provided by the ngrok agent to expose your application to the internet in the **URL** field (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![Sonatype Nexus URL](img/ngrok_url_configuration_sonatype.png)\n\n1. In the **Available** list, click **repository** and then click the greater-than button to move the **repository** value to the **Selected** list.\n\n### Run Webhooks with Sonatype Nexus and ngrok\n\nSonatype Nexus sends different request body contents depending on the event that is being triggered.\nYou can trigger new calls from Sonatype Nexus to your application by following the instructions below.\n\n1. On the **Sonatype Nexus Repository Manager** user interface, click **Repository** on the left menu and then click **Repositories**. In this example, click **apt (hosted)**.\n\n1. On the **Repositories** page, click **Create Repository**, click one of the **Recipes** from the list, enter any value in the **Name**, **Distribution**, and **Signing Key**, and then click **Create repository**.\n\n   Confirm your localhost app receives an event notification and logs both headers and body in the terminal.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Sonatype Nexus webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Access your **Sonatype Nexus Repository Manager** user interface and sign in using your administration account.\n   **Tip**: Your **Sonatype Nexus Repository Manager** URL depends on where you deployed your repository manager.\n\n1. On the left menu, click **System**, click **Capabilities**, and then click **Webhook: Global** or **Webhook: Repository** depending on which type of capability you created before.\n\n1. On the **Webhook** page, click the **Settings** tab, and then enter `12345` in the **Secret Key** field.\n\n1. Create a traffic policy file named `sonatype_nexus_policy.yml`, replacing `{your webhook secret}` with the value of the **Secret Key** field:\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: sonatype_nexus\n             secret: \"{your webhook secret}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file sonatype_nexus_policy.yml\n   ```\n\n1. On the **Sonatype Nexus Repository Manager** user interface, click **Repository** on the left menu and then click **Repositories**. In this example, click **apt (hosted)**.\n\n1. On the **Repositories** page, click **Create Repository**, click one of the **Recipes** from the list, enter any value in the **Name**, **Distribution**, and **Signing Key**, and then click **Create repository**.\n\n   Confirm your localhost app receives an event notification and logs both headers and body in the terminal.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "Sonatype Nexus Webhooks"
			}
		  ],
		  "metadata": {
			"name": "sonatype-nexus",
			"description": "",
			"excerpt": "",
			"title": "Sonatype Nexus"
		  }
		},
		{
		  "name": "spectro-cloud",
		  "path": "/integrations/spectro-cloud",
		  "docs": [
			{
			  "path": "/integrations/spectro-cloud/k8s",
			  "frontMatter": {
				"description": "Add ingress to any app running in a Kubernetes cluster managed by Spectro Cloud's Palette platform using the ngrok Kubernetes Operator.",
				"title": "Ingress to Kubernetes apps deployed on Spectro Cloud Palette"
			  },
			  "content": "<Tip>\n**TL;DR**\n\n\n\nTo use the ngrok Kubernetes Operator with Spectro Cloud Palette:\n\n1. [Create an add-on cluster profile for the ngrok Kubernetes Operator](#create-a-cluster-profile-in-palette)\n2. [Create your cluster with Palette](#create-your-cluster-with-palette)\n3. [Create an add-on cluster profile for an example app and ngrok Kubernetes Operator](#create-add-on-cluster-profile-ngrok)\n4. [Create your cluster with Palette](#create-your-cluster-with-palette)\n</Tip>\n\nThe [ngrok Kubernetes Operator](https://ngrok.com/blog-post/ngrok-k8s) is the official controller for adding public and secure ingress traffic to your k8s services. This open source Operator works with any cloud, locally-hosted, or on-premises Kubernetes cluster to provide ingress to your applications, APIs, or other services while also offloading network ingress and middleware execution to ngrok's platform.\n\nPalette, from [Spectro Cloud](https://www.spectrocloud.com/), is a profile-based Kubernetes management platform. It gives IT teams the control and visibility to create Kubernetes stacks for their developers with all the granular governance and security they need.\n\nTogether, the ngrok Kubernetes Operator and Palette integrate to provide secure public ingress for apps running on Kubernetes clusters managed on their platform. You get all the [benefits](https://www.spectrocloud.com/why-palette) of declarative management and lifecycle controls in Palette while simplifying and securing how you move public traffic into your Kubernetes cluster.\n\nWith this guide, you'll define cluster and add-on profiles in Palette, create a cluster with your cloud provider, and integrate the ngrok Kubernetes Operator with either an example app or a custom app you're ready to make public via ngrok's cloud service.\n<Warning>\n**This tutorial requires:**\n\n\n\n1. An [ngrok account](https://ngrok.com/signup) at any tier.\n2. A [Palette](https://console.spectrocloud.com/) account with Spectro Cloud.\n3. An account with the necessary privileges to create a cluster on one of the following managed Kubernetes services:\n   - [Amazon Elastic Kubernetes Service](https://aws.amazon.com/eks/) (EKS)\n   - [Azure Kubernetes Service](https://azure.microsoft.com/en-us/products/kubernetes-service) (AKS)\n   - [Google Kubernetes Engine](https://cloud.google.com/kubernetes-engine) (GKE)\n   - [Tencent Kubernetes Engine](https://www.tencentcloud.com/products/tke) (TKE)\n   - Palette also supports [data centers](https://docs.spectrocloud.com/clusters/data-center/) and other deployment strategies, but those are beyond the scope of this guide.\n</Warning>\n\n## **Step 1**: Create a cluster profile in Palette \n\nPalette uses infrastructure-level [cluster profiles](https://docs.spectrocloud.com/profiles/cluster-profiles/) to help you create and deploy a Kubernetes cluster with your service of choice. Profiles are layers of Helm charts, manifests, and [packs](https://docs.spectrocloud.com/integrations/) provided by Palette to repeatedly deploy clusters to multiple providers and manage them in Palette.\n\nIf you already have a cluster profile, skip to [Step 4: Create your cluster with Palette](#create-your-cluster-with-palette). If you already have a functioning cluster in Palette, skip to [Step 3: Create an add-on cluster profile for an example app and ngrok Kubernetes Operator](#create-add-on-cluster-profile-ngrok).\n\n1. [Log in](ttps://console.spectrocloud.com/) to your Palette account.\n\n1. Click **Profiles** in the navigation, then **Add Cluster Profile**. In the **Basic Information** tab, give your profile a name, like `ngrokker`, and a version. For this guide, leave the **Type** as the default **Full**, then click **Next**.\n\n   ![Add a cluster profile name and version](img/add-profile.png)\n\n1. In the **Cloud Type** tab, choose your provider.\n\n   ![Choose a Kubernetes provider for your profile](img/choose-provider.png)\n\n1. In the **Profile Layers** tab, click on your base OS pack—in most cases, there will be a single option, like `Container-Optimized OS` or `Linux`. This is where you would add customizations or additional manifests, but you can leave the settings at their default and click **Next layer**.\n\n   ![Select packs and options](img/select-pack.png)\n\n   Repeat the process for the base Kubernetes, Network, and Storage packs. At the final step, click **Confirm**.\n\n1. Palette now shows you the layers of this new cluster profile. You can also add new Packs, manifests, or Helm charts, but to save your progress for now, click **Next**, then **Finish Configuration**.\n\n   ![Finalize your cluster profile](img/finalize-profile.png)\n\n## **Step 2**: Create an add-on cluster profile for the ngrok Kubernetes Operator \n\nYou've defined the core layers of your cluster and created it, but you don't currently have a method of handling traffic ingress.\n\nFor the former, Palette has a [ready-to-apply pack](https://docs.spectrocloud.com/integrations/ngrok/) for the ngrok Kubernetes Operator. For the latter, you can either add an example app as detailed in the following steps or connect to an existing app.\n\n1. Head back to the **Profiles** section in Palette. Click on **Add Cluster Profile**. Give this profile a name. Under **Type**, click the **Add-on** option, then **Next**.\n\n1. Click **Add New Pack**, then either search `ngrok`, or scroll down to the **Ingress** section, and click on the **ngrok Kubernetes Operator** icon.\n\n   ![Add the ngrok Kubernetes Operator pack](img/add-ngrok-controller.png)\n\n1. Scroll down in the default YAML supplied by the pack to the following configuration.\n\n   ```yaml\n   ## @param credentials.secret.name The name of the secret the credentials are in. If not provided, one will be generated using the helm release name.\n   ## @param credentials.apiKey Your ngrok API key. If provided, it will be will be written to the secret and the authtoken must be provided as well.\n   ## @param credentials.authtoken Your ngrok authtoken. If provided, it will be will be written to the secret and the apiKey must be provided as well.\n   credentials:\n     secret:\n       name: \"\"\n     apiKey: \"\"\n     authtoken: \"\"\n   ```\n\n   You must specify the `apiKey` and `authtoken` parameters with those of your ngrok account.\n\n   To create a new API key, navigate to the [**API** section](https://dashboard.ngrok.com/api) of the ngrok dashboard, click the **New API Key** button, change the description or owner, and click the **Add API Key** button. Copy your new API key into the `apiKey` parameter.\n\n   Find your `AUTHTOKEN` under [**Your Authtoken**](https://dashboard.ngrok.com/get-started/your-authtoken) in the ngrok dashboard, and copy that into the `authtoken` parameter.\n\n   Palette will automatically hide the values you enter.\n\n   ![Add ngrok secrets to the Palette profile](img/add-ngrok-secrets.png)\n<Tip>\n**If you have a free ngrok account, you can only have one ngrok agent active at a time. To ensure the ngrok Kubernetes Operator functions properly in production, set the `replicaCount` parameter to `1`.**\n</Tip>\n\n1. Click **Confirm & Create** to add the layer to your profile and then finish the configuration.\n\n## **Step 3**: Create an add-on cluster profile for an example app \n\n1. Create an ngrok static subdomain for ingress, if you don't have one already. Navigate to the [**Domains** section](https://dashboard.ngrok.com/domains) of the ngrok dashboard and click **Create Domain** or **New Domain**. This static subdomain will be your `NGROK_DOMAIN` for the remainder of this guide.\n\n1. Create a new cluster profile, name it `game-2048`, and click the **Add-on** profile type.\n\n1. Click **Add Manifest** to create a new layer using Kubernetes manifests in YAML.\n\n   Name the layer `2048`, then click **New manifest** and name it `deployment`. Copy the following YAML content to create a Kubernetes deployment named `game-2048`.\n\n   ```yaml showLineNumbers\n   apiVersion: apps/v1\n   kind: Deployment\n   metadata:\n     name: game-2048\n   spec:\n     replicas: 1\n     selector:\n       matchLabels:\n         app: game-2048\n     template:\n       metadata:\n         labels:\n           app: game-2048\n       spec:\n         containers:\n           - name: backend\n             image: alexwhen/docker-2048\n             ports:\n               - name: http\n                 containerPort: 80\n   ```\n\n   Create a second manifest named `service` copy in the following YAML:\n\n   ```yaml showLineNumbers\n   apiVersion: v1\n   kind: Service\n   metadata:\n     name: game-2048\n   spec:\n     ports:\n       - name: http\n         port: 80\n         targetPort: 80\n     selector:\n       app: game-2048\n   ```\n\n   Click **Confirm & Create** to save the deployment.\n\n1. Add another manifest to create a Kubernetes ingress service, which will inform the ngrok Kubernetes Operator to create a new Edge for your app. Name it `2048-ingress` and create an `ingress` manifest with the following YAML content, replacing the `<NGROK_DOMAIN>` variable with the subdomain you created, which should look like `one-two-three.ngrok.app`.\n\n   ```yaml showLineNumbers\n   apiVersion: networking.k8s.io/v1\n   kind: Ingress\n   metadata:\n     name: game-2048-ingress\n     namespace: ngrok-operator\n   spec:\n     ingressClassName: ngrok\n     rules:\n       - host: <NGROK_DOMAIN>\n         http:\n           paths:\n             - path: /\n               pathType: Prefix\n               backend:\n                 service:\n                   name: game-2048\n                   port:\n                     number: 80\n   ```\n\n   Click **Confirm & Create** once again to add this layer before finishing the configuration.\n\n   ![Finish creating 2048 profile](img/finish-2048-profile.png)\n\n## **Step 4**: Create your cluster with Palette \n\nYou can now create your core cluster using Palette and your cloud provider. Once the cluster deploys, you'll add additional layers for an example app and the ngrok Kubernetes Operator.\n\n1. Navigate to **Project Settings** in the Palette dashboard to add a cloud account.\n\n   Before connecting your cloud account to Palette, ensure you have user/service account privileges. Doing so is beyond the scope of this guide, but the Palette docs have detailed requirements for [GCP](https://docs.spectrocloud.com/clusters/public-cloud/gcp/add-gcp-accounts/), [AWS](https://docs.spectrocloud.com/clusters/public-cloud/aws/add-aws-accounts), [Azure](https://docs.spectrocloud.com/clusters/public-cloud/azure/azure-cloud), and [others](https://docs.spectrocloud.com/clusters/).\n\n   For example, GCP requires a service account with the following credentials:\n   - [Kubernetes Engine Admin](https://cloud.google.com/iam/docs/understanding-roles#kubernetes-engine-roles)\n   - [Compute Admin](https://cloud.google.com/iam/docs/understanding-roles#compute.admin)\n   - [Service Account User](https://cloud.google.com/iam/docs/understanding-roles#iam.serviceAccountUser)\n     - [Compute Admin](https://cloud.google.com/iam/docs/understanding-roles#compute.admin)\n     - [Storage Object Viewer](https://cloud.google.com/iam/docs/understanding-roles#storage.objectViewer)\n     - [Service Account Token Creator](https://cloud.google.com/iam/docs/understanding-roles#iam.serviceAccountTokenCreator)\n\n1. Click **Add ... Account** to open a modal containing the credentials required to connect your account. For GCP, you only need to upload the [JSON credentials](https://developers.google.com/workspace/guides/create-credentials) for your service account.\n\n1. Click **Validate**. If there are any errors, Palette will attempt to explain what privileges are missing, or settings not yet enabled in your cloud account, and provide links to relevant docs.\n\n1. Start the cluster setup process by clicking **Clusters** in the left-hand navigation, then **Add New Cluster**, and **Deploy New Cluster**.\n\n1. Choose your cloud provider and start the configuration. Give your cluster a name, then choose the cloud account you connected to Palette.\n\n1. Find the cluster profile you created in Step 1 and click **Next**.\n\n   ![Choose your cluster profile](img/choose-profile.png)\n\n1. Add your additional profiles by clicking on the **+** next to **Addon layers**. Choose the ngrok Kubernetes Operator profile, then repeat for the 2048 game profile.\n\n   You have one more opportunity to customize the configurations, but you can click **Next** to continue.\n\n1. Choose the **Project** you'd like to create your new cluster within and pick a region.\n<Tip>\n**A common error at this stage is you still need to activate certain APIs for your project. For example, a project in GCP requires the Compute Engine API, which in turn requires an enabled billing account. Once you fix these errors, give the settings a few minutes to propagate to Palette, before moving forward.**\n</Tip>\n\n1. Next, create your node pool. Here, you can change the number of nodes in the pool and specify the instance type you'd like to use.\n\n   ![Selecting the cluster's node pool](img/node-pool.png)\n\n1. Click **Finish Configuration** to create your cluster.\n\n   ![The final visualization of the cluster with all profiles](img/final-cluster-layers.png)\n\n   The deployment process may take up to 15 minutes, depending on your cluster profile, node pool configuration, and the general load on that region. You can track the provisioning process on the cluster's **Overview**.\n\n   If you see additional errors during deployment, view the **Events** tab to read logs and check whether you need to enable additional APIs or privileges on your project or service account.\n\n1. Once Palette reports your cluster as `Running`, you can open your browser and navigate to your `NGROK_DOMAIN` to see your example app as managed, deployed, and publicly networked via, respectively, Palette, Kubernetes, and ngrok!\n\n   ![Viewing the final 2048 game](img/final-2048-game.png)\n\n## What's next?\n\nYou have now used Spectro Cloud's Palette to create modular, declarative configurations for your cluster, then deployed an example Wordpress app integrated with the ngrok Kubernetes Operators. With ngrok operating as your middleware, handling ingress to your Palette-managed Kubernetes cluster, you can deploy any number of apps while maintaining control and customization.\n\nFrom here, you have a few options:\n\n### Clean up\n\nDelete your Palette-managed cluster by heading to the **Overview** for your cluster, then clicking **Settings** &rarr; **Delete Cluster**. Palette will send the necessary requests to your provider to delete your cluster resources.\n\nngrok will automatically delete your Edge upon the deletion of your cluster.\n\n### Extend your ngrok Kubernetes Operator and Palette integration\n\nRead our [Kubernetes Operator docs](/k8s/) for more details, including [how it works](/k8s/how-it-works/) and details on how to [apply an `NgrokTrafficPolicy` resource](/k8s/guides/using-ingresses/#using-ngroktrafficpolicy-with-ingress) to your `Ingress` to start using our [Traffic Policy system](/traffic-policy).\n",
			  "contentTitle": "Ingress to Kubernetes apps deployed on Spectro Cloud Palette"
			}
		  ],
		  "metadata": {
			"name": "spectro-cloud",
			"description": "",
			"excerpt": "",
			"title": "Spectro Cloud"
		  }
		},
		{
		  "name": "square",
		  "path": "/integrations/square",
		  "docs": [
			{
			  "path": "/integrations/square/webhooks",
			  "frontMatter": {
				"description": "Develop and test Square webhooks from localhost",
				"title": "Square Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Square webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Square webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Square by using Webhooks.\nSquare webhooks can be used to notify an external application whenever specific events occur in your Square account.\n\nBy integrating ngrok with Square, you can:\n\n- **Develop and test Square webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Square** in real-time via the inspection UI and API.\n- **Modify and Replay Square Webhook requests** with a single click and without spending time reproducing events manually in your Square account.\n- **Secure your app with Square validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Square).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Square \n\nTo register a webhook on your Square account follow the instructions below:\n\n1. Access the [Square Developer](https://developer.squareup.com/apps) page, and sign in using your Square account.\n\n1. Click the plus sign to add a new application, provide **Application name** as `myLocalhostApp`, click **I agree to the Square Developer Terms of Service**, and then click **Save**.\n\n1. On the **Applications** page, click **Open** in the application tile.\n\n1. On your app page, click **Subscriptions** under the **Webhooks** section of the left menu.\n\n1. In the **Webhook subscriptions** page, click **Production** and then click **Add subscription**.\n\n1. In the **Webhook subscription** popup, provide `Create Items Webhook` as the **Webhook name** and in the **URL** field enter the URL provided by the ngrok agent to expose your application to the internet (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![Your request endpoint URL](img/ngrok_url_configuration_square.png)\n\n1. In the **Events** section, select **catalog.version.updated** and then click **Save**.\n\n### Run Webhooks with Square and ngrok\n\nBecause you've selected the **catalog.version.updated** event, you can trigger new calls from Square to your application by following the instructions below:\nSquare sends different request body contents depending on the event you select during the webhook registration.\n\n1. In the same browser, access the [Square Dashboard](https://squareup.com/dashboard) page, click **Items & orders**, and then click the **Items** on the left menu.\n   **Tip**: Optionally, you can click **Items** under the **Quick access** menu.\n\n1. In the **Your item library** page, click **Create an item**, and then provide **Details** such as **Name**, **Category**, **SKU**, **Price**, and then click **Save**.\n   Confirm your localhost app receives the create user event notification and logs both headers and body in the terminal.\n\n1. Optionally, you can access the [Square Dashboard](https://squareup.com/dashboard) page for your application, click **Logs** under **Webhooks** on the left menu, click the last log that appears on the page, and confirm the post request sent by Square is the same as the request logged by the localhost application.\n   ![Square Webhook logs](img/square_webhook_logs.png)\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Square webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Access the [Square Developer](https://developer.squareup.com/apps) page, and sign in using your Square account.\n\n1. On the **Applications** page, click **Open** in the application tile.\n\n1. On your application page, scroll down until you find **Access token**, click **Show** for this field, and then copy the **Access token** value.\n   **Tip**: Depending on the environment you choose the name of the field is either **Sandbox Access token** or **Production Access token**.\n\n1. Create a traffic policy file named `square_policy.yml`:\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: square\n             secret: {your access token}\n   ```\n\n   **Note**: Replace `{your access token}` with the value you copied before.\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file square_policy.yml\n   ```\n\n1. Access the [Square Dashboard](https://squareup.com/dashboard/) page and create a new item.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "Square Webhooks"
			}
		  ],
		  "metadata": {
			"name": "square",
			"description": "",
			"excerpt": "",
			"title": "Square"
		  }
		},
		{
		  "name": "stripe",
		  "path": "/integrations/stripe",
		  "docs": [
			{
			  "path": "/integrations/stripe/webhooks",
			  "frontMatter": {
				"description": "Develop and test Stripe webhooks from localhost",
				"title": "Stripe Webhook"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Stripe webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Stripe webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Stripe webhooks.\nStripe webhooks can be used to notify an external application whenever specific events occur in your Stripe account. Stripe requires your application to be available through an HTTPS endpoint.\n\nBy integrating ngrok with Stripe, you can:\n\n- **Develop and test Stripe webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Stripe** in real-time via the inspection UI and API.\n- **Modify and Replay Stripe Webhook requests** with a single click and without spending time reproducing events manually in your Stripe account.\n- **Secure your app with Stripe validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app runs successfully on localhost, let's securely get it on the internet using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Stripe).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Stripe \n\nTo register a Stripe webhook:\n\n1. Access the [Stripe dashboard](https://dashboard.stripe.com/) and sign in using your Stripe account.\n\n1. Click **Developers** on the top-right corner of the dashboard page, and then click **Webhooks** in the left menu.\n\n1. In the **Webhooks** page, click **Add an endpoint**.\n\n1. On the **Listen to Stripe events** page, in the **Endpoint URL** field, enter the URL provided by the ngrok agent to expose your application to the internet (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![Configure Endpoint URL](img/ngrok_url_configuration_stripe.png)\n\n1. Click **+ Select events**.\n\n1. Select the events you want to receive notifications. For this tutorial, expand **Product** and then click **Select all Product events**.\n   **Tip**: During the webhook registration, Stripe provides you with a sample code that you can use to deploy and run an application. For this tutorial, ignore this and use the sample app as per [Start your app](#start-your-app) section.\n\n1. Click **Add events**, and then click **Add endpoint**.\n\nThe Webhook page shows your webhook details.\n\n### Run Webhooks with Stripe and ngrok\n\nCreate a product to make Stripe notify your localhost application about the product creation:\n\n1. In the Stripe Dashboard, click **Product** in the top menu, and then click **Add product**.\n\n1. Enter a product **Name** and **Price**, then click **Save product**.\n\n1. Access the **Developers** section, click **Webhooks**, and then select the webhook you have created.\n\n1. Review the last messages sent by Stripe for the product creation event.\n   ![Webhook messages](img/review_webhook_message_stripe.png)\n\nConfirm your localhost app receives notifications about the created product.\n\n**Tip:** Stripe sends different request body contents and headers depending on the trigger event.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Stripe webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. In the Webhook page for your webhook, click **Reveal** under **Signing secret**, and copy the value that appears.\n\n1. Create a traffic policy file named `stripe_policy.yml`:\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: stripe\n             secret: \"{your signing secret}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file stripe_policy.yml\n   ```\n\n1. In your Stripe dashboard, click **Products** in the top menu and then create a new product.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "Stripe Webhook"
			}
		  ],
		  "metadata": {
			"name": "stripe",
			"description": "",
			"excerpt": "",
			"title": "Stripe"
		  }
		},
		{
		  "name": "svix",
		  "path": "/integrations/svix",
		  "docs": [
			{
			  "path": "/integrations/svix/webhooks",
			  "frontMatter": {
				"description": "Develop and test Svix webhooks from localhost",
				"title": "Svix Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Svix webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Svix webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Svix by using Webhooks.\nSvix incoming webhooks can be used to notify an external application whenever specific events occur in your Svix account.\n\nBy integrating ngrok with Svix, you can:\n\n- **Develop and test Svix webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Svix** in real-time via the inspection UI and API.\n- **Modify and Replay Svix Webhook requests** with a single click and without spending time reproducing events manually in your Svix account.\n- **Secure your app with Svix validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Svix).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Svix \n\nTo register a webhook on your Svix account follow the instructions below:\n\n1. Access the [Svix Dashboard](https://dashboard.svix.com/) and sign in using your Svix account.\n\n1. On the left menu, click **Incoming Webhooks** and then click **Add Endpoint**.\n\n1. Enter the URL provided by the ngrok agent to expose your application to the internet in the **Endpoint URL** field (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![svix URL to Publish](img/ngrok_url_configuration_svix.png)\n\n1. In the **Message Filtering** section, select all events by clicking the **endpoint** and **message** checkboxes, and then click **Create**.\n\n1. In the webhook page, click the **Testing** tab and then click **Send Example**.\n\n   Confirm your localhost app receives a request and logs both headers and body in the terminal.\n\n### Run Webhooks with Svix and ngrok\n\nSvix sends different request body contents depending on the event that is being triggered.\nYou can trigger new calls from Svix to your application by following the instructions below.\n\n1. On the [Svix Dashboard](https://dashboard.svix.com/), click **Consumer Applications** on the left menu and then click your app.\n   **Note**: If you don't have an application, create a new one.\n\n1. On the app page, click **Preview App Portal** and then click **Add Endpoint**.\n\n1. On the **New Endpoint** page, click **use Svix Play** or enter a URL in the **Endpoint URL** field, and then click **Create**.\n\n   Confirm your localhost app receives the request and logs both headers and body in the terminal.\n\nOptionally, you can verify the webhook log in the Svix dashboard:\n\n1. Access the [Svix Dashboard](https://dashboard.svix.com/), click **Incoming Webhooks** on the left menu, click the **Logs** tab, and then click one of the logs.\n   ![Webhook Logs](img/ngrok_logs_svix.png)\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Svix webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Access the [Svix Dashboard](https://dashboard.svix.com/) and sign in using your Svix account.\n\n1. On the left menu, click **Incoming Webhooks**, click the URL of your webhook, click the eye icon under the **Signing Secret** section, and then copy the value of the signing secret.\n\n1. Create a traffic policy file named `svix_policy.yml`, replacing `{your webhook secret}` with the value you copied before:\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: svix\n             secret: \"{your webhook secret}\"\n   ```\n\n1. Restart your ngrok agent by running the following command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file svix_policy.yml\n   ```\n\n1. Access the [Svix Dashboard](https://dashboard.svix.com/) and create a new endpoint.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "Svix Webhooks"
			}
		  ],
		  "metadata": {
			"name": "svix",
			"description": "",
			"excerpt": "",
			"title": "Svix"
		  }
		},
		{
		  "name": "teams",
		  "path": "/integrations/teams",
		  "docs": [
			{
			  "path": "/integrations/teams/webhooks",
			  "frontMatter": {
				"description": "Develop and test Microsoft Teams webhooks from localhost",
				"title": "Microsoft Teams Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Microsoft Teams webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000 --url myexample.ngrok.app`\n1. [Configure Microsoft Teams webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Microsoft Teams by using Webhooks.\nMicrosoft Teams webhooks can be used to notify an external application whenever page or account events occur in your Microsoft Teams account.\n\nBy integrating ngrok with Microsoft Teams, you can:\n\n- **Develop and test Microsoft Teams webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Microsoft Teams** in real-time via the inspection UI and API.\n- **Modify and Replay Microsoft Teams Webhook requests** with a single click and without spending time reproducing events manually in your Microsoft Teams account.\n- **Secure your app with Microsoft Teams validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## 1. Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis installs the project locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs on port 3000 by default.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## 2. Launch ngrok \n\nNow that your app is running locally, you can put it on the internet securely with ngrok.\n<Info>\n**This integration requires an ngrok Pro or Enterprise license because Microsoft Teams validates your ngrok domain and certificate.**\n</Info>\n\n1. If you're not an ngrok user yet, [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com), click **Your Authtoken**, and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n\n1. On the left menu, expand **Universal Gateway** and then click **Domains**.\n   **Tip:** If you don't have an ngrok Pro or Enterprise license, sign up for one by clicking **Update Subscription** and following the subscribe procedure.\n\n1. On the **Domains** page, click **+ Create Domain** or **+ New Domain**.\n\n1. In the **Domain** pane, provide a value for the **Domain** field (i.e. `myexample.ngrok.app`), and then click **Continue**.\n   ![ngrok New Domain](/img/integrations/ngrok_new_domain.png)\n   **Tip**: Make sure your domain is available.\n\n1. Close the **Start a Tunnel** pane and then close the **Domain** pane.\n\n1. Start ngrok by running the following command in a terminal on your local desktop:\n\n   ```bash\n   ngrok http 3000 --url myexample.ngrok.app\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Microsoft Teams).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel_domain.png)\n\n## 3. Integrate Microsoft Teams \n\nTo register a webhook on your Microsoft Teams account follow the instructions below:\n\n**Requirements**: You'll need a Microsoft Teams page and a Microsoft Teams app associated with your Microsoft Teams page. Create one before following the rest of these steps.\n\n1. Access the [Microsoft Teams web interface](https://teams.microsoft.com/) and sign in using your Microsoft account.\n   **Tip**: You can use the Microsoft Teams app instead.\n\n1. On the **Microsoft Teams** page, click **Teams** on the left menu, select one of your channels and then click the plus sign (**+**) on the top of your team page.\n1. On the **Add a tab** popup, click **Manage apps** and then click **Create an outgoing webhook** at the bottom of the page.\n\n1. On the **Create an outgoing webhook** popup, enter `My local app` in the **Name** field, enter `My local app` in the **Description** field, and enter the URL provided by the ngrok agent to expose your application to the internet in the **Callback URL** field (i.e. `https://myexample.ngrok.app`).\n   ![Callback URL](img/ngrok_url_configuration_teams.png)\n\n1. Click **Create**.\n\n1. On the **Congratulations** popup, make note of the **Security token** value and then click **Close**.\n\n## Run Webhooks with Microsoft Teams and ngrok\n\nMicrosoft teams Outgoing Webhook acts as a bot sending any text you type using `@mention`. It sends notifications to your local application through ngrok.\n\nTo send notifications to your application follow the instructions below:\n\n1. Access your Microsoft Teams account, select a channel, and then enter `@My local app` and hit enter.\n\n1. The JSON message `{ message: \"Thank you for the message\" }` appears as a response to your message.\n\nConfirm your localhost app receives a notification call and logs both headers and body in the terminal.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Microsoft Teams webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Create a traffic policy file named `teams_policy.yml` with the Microsoft Teams webhook verification configuration, replacing `{your app secret}` with the **Security token** value you copied before (See [Integrate Microsoft Teams](#setup-webhook)):\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: microsoft_teams\n             secret: \"{your app secret}\"\n   ```\n\n1. Restart your ngrok agent by running the command with the traffic policy:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file teams_policy.yml\n   ```\n\n1. Access the Microsoft Teams page you have assigned to your webhook and send a message to another Microsoft Teams user.\n\n   Verify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "Microsoft Teams Webhooks"
			}
		  ],
		  "metadata": {
			"name": "teams",
			"description": "",
			"excerpt": "",
			"title": "Microsoft Teams"
		  }
		},
		{
		  "name": "terraform",
		  "path": "/integrations/terraform",
		  "docs": [
			{
			  "path": "/integrations/terraform/webhooks",
			  "frontMatter": {
				"description": "Develop and test Terraform webhooks from localhost",
				"title": "Terraform Cloud Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Terraform Cloud webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Terraform Cloud webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Terraform Cloud by using Webhooks.\nTerraform Cloud webhooks can be used to notify an external application whenever specific events occur in your Terraform Cloud account.\n\nBy integrating ngrok with Terraform Cloud, you can:\n\n- **Develop and test Terraform Cloud webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Terraform Cloud** in real-time via the inspection UI and API.\n- **Modify and Replay Terraform Cloud Webhook requests** with a single click and without spending time reproducing events manually in your Terraform Cloud account.\n- **Secure your app with Terraform Cloud validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Terraform Cloud).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Terraform Cloud \n\nTo register a webhook on your Terraform Cloud account follow the instructions below:\n\n1. Access [Terraform Cloud](https://app.terraform.io/), sign in using your Terraform account, and then click on your workspace.\n\n1. On the workspace page, click **Settings** and then click **Notifications** both on the left menu.\n\n1. On the **Notifications** page, click **Create Notification**.\n\n1. On the **Create a Notification** page, click the **Webhook** tile, enter `ngrok` in the **Name** field, and enter the URL provided by the ngrok agent to expose your application to the internet in the **Webhook URL** field (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![Terraform Cloud URL](img/ngrok_url_configuration_terraform.png)\n\n1. On the same page, click **All events** in the **Triggers** section.\n\n   Confirm your localhost app receives verification notification and logs both headers and body in the terminal.\n\nAlternatively, click **Send a test** on the **ngrok** notification details page and confirm your localhost app receives a new notification.\n\n### Run Webhooks with Terraform Cloud and ngrok\n\nTerraform Cloud sends different request body contents depending on the event that is being triggered.\nYou can trigger new calls from Terraform Cloud to your application by following the instructions below.\n\n1. On the top of the page, click **Actions** and then click **Start new run**.\n\n1. Enter `My New Run` in the **Reason for starting run**, select **Plan and apply** in the **Choose run type** field, and then click **Start run**.\n\n   Confirm your localhost app receives event notifications and logs both headers and body in the terminal.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Terraform Cloud webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Access [Terraform Cloud](https://app.terraform.io/), sign in using your Terraform account, and then click on your workspace.\n\n1. On the workspace page, click **Settings** on the left menu, click **Notifications**, click the **ngrok** notification you created previously, and then click **Edit Notification**.\n\n1. On the **ngrok** notification page, enter `'12345` in the **Token** field and then click **Update notification**.\n\n1. Create a traffic policy file named `terraform_policy.yml`, replacing `{your webhook token}` with the value you have copied before (See [Integrate ngrok and Terraform Cloud.](#setup-webhook)):\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: terraform\n             secret: \"{your webhook token}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file terraform_policy.yml\n   ```\n\n1. On the top of the page, click **Actions** and then click **Start new run**.\n\n1. Enter `My New Run` in the **Reason for starting run**, select **Plan and apply** in the **Choose run type** field, and then click **Start run**.\n\n   Confirm your localhost app receives event notifications and logs both headers and body in the terminal.\n",
			  "contentTitle": "Terraform Cloud Webhooks"
			}
		  ],
		  "metadata": {
			"name": "terraform",
			"description": "",
			"excerpt": "",
			"title": "Terraform"
		  }
		},
		{
		  "name": "tiktok",
		  "path": "/integrations/tiktok",
		  "docs": [
			{
			  "path": "/integrations/tiktok/webhooks",
			  "frontMatter": {
				"description": "Develop and test TikTok webhooks from localhost",
				"title": "TikTok Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate TikTok webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure TikTok webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with TikTok by using Webhooks.\nTikTok webhooks can be used to notify an external application whenever specific events occur in your TikTok app.\n\nBy integrating ngrok with TikTok, you can:\n\n- **Develop and test TikTok webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from TikTok** in real-time via the inspection UI and API.\n- **Modify and Replay TikTok Webhook requests** with a single click and without spending time reproducing events manually in your TikTok account.\n- **Secure your app with TikTok validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with TikTok).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate TikTok \n\nTo register a webhook on your TikTok app follow the instructions below:\n\n1. Access the [TikTok Developer Portal](https://developers.tiktok.com/) and sign in using your TikTok account.\n\n1. On the **Welcome** page, click **Manage apps** on the top menu.\n\n1. On the **Manage apps** page, click **Connect an app**, upload an **App icon**, select **Others** in the **Category** field, enter a description in the **Description** field, click the slider icon for **Configure for Web**, enter a URL in the **Website URL** field, and click **Save changes**.\n\n1. On the app page, click **Add products** on the left menu and click **Add** in the **Webhooks** tile.<br />\n   **Note**: You may need to add the **Login Kit** before adding **Webhooks**.\n\n1. On the left menu, click **Webhooks** and then enter the URL provided by the ngrok agent to expose your application to the internet in the **Callback URL** field (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![URL](img/ngrok_url_configuration_tiktok.png)\n\n1. Click **Test URL** and then click **Send**.\n\n   Confirm your localhost app receives a notification and logs both headers and body in the terminal.\n\n1. On the **Test event sent** popup, confirm the message **200 OK** appears and then click **Done**.\n\n1. Click **Save changes**.\n   **Note**: You may need to enter values for the **Terms of Service URL**, **Privacy Policy URL**, and **Redirect domain** fields in the **Login Kit** section.\n\n1. If your application isn't published yet, click **Submit for review**.\n\n### Run Webhooks with TikTok and ngrok \n\nBy default, you are subscribed to all events that happen in your TikTok app.\nTikTok sends different request body contents depending on the event that is being triggered.\n\nAfter your app is approved, associate a user with your app.\n\nThe TikTok app will send a notification to your localhost application when a user's account is deauthorized from your application, a user video fails to upload in TikTok, or a user video has been published in TikTok.\n\n```sh\nConfirm your localhost app receives one of these event notifications and logs both headers and body in the terminal.\n```\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your TikTok webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Access the [TikTok Developer Portal](https://developers.tiktok.com/) and sign in using your TikTok account.\n\n1. On the **Manage apps** page, click your app tile, click the eye icon to reveal the **Client secret** value, and then copy this value.\n\n1. Create a traffic policy file named `tiktok_policy.yml`, replacing `{your webhook secret}` with the value you copied before:\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: tiktok\n             secret: \"{your webhook secret}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file tiktok_policy.yml\n   ```\n\n1. Access your [TikTok](https://www.tiktok.com/) account and use the app. See [Run Webhooks with TikTok and ngrok](#run-webhook).\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "TikTok Webhooks"
			}
		  ],
		  "metadata": {
			"name": "tiktok",
			"description": "",
			"excerpt": "",
			"title": "TikTok"
		  }
		},
		{
		  "name": "trendmicro",
		  "path": "/integrations/trendmicro",
		  "docs": [
			{
			  "path": "/integrations/trendmicro/webhooks",
			  "frontMatter": {
				"description": "Develop and test Trend Micro webhooks from localhost",
				"title": "Trend Micro Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Trend Micro webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Trend Micro webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Trend Micro by using Webhooks.\nTrend Micro webhooks can be used to notify an external application whenever specific events occur in your Trend Micro account.\n\nBy integrating ngrok with Trend Micro, you can:\n\n- **Develop and test Trend Micro webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Trend Micro** in real-time via the inspection UI and API.\n- **Modify and Replay Trend Micro Webhook requests** with a single click and without spending time reproducing events manually in your Trend Micro account.\n- **Secure your app with Trend Micro validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Trend Micro).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Trend Micro \n\nTo register a webhook on your Trend Micro account follow the instructions below:\n\n1. Access [Trend Micro Cloud One](https://cloudone.trendmicro.com/) and sign in using your Trend Micro account.\n\n1. On the home page, click the **Conformity** tile.\n\n1. On the **Accounts** page, click **Settings**, click **Update communication settings** in the **Communication settings** section, and then click **Configure** in the **Webhooks** section.\n   **Note**: If you don't have a cloud provider associated with your Trend Micro Conformity service, click your preferred cloud provider and associate a service account.\n\n1. On the **Webhooks** page, click **Create a Webhook channel**, click **Configure webhook**, and enter the URL provided by the ngrok agent to expose your application to the internet in the **Webhook URL** field (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![Webhook URL](img/ngrok_url_configuration_trendmicro.png)\n\n1. Click **Save**.\n\n1. Click the On/Off switch to turn **Automatic notifications** on.\n\n### Run Webhooks with Trend Micro and ngrok\n\nTrend Micro Cloud One Conformity notifies your webhook after the bot revises your cloud provider account for compliance issues.\nYou can trigger new calls from Trend Micro Cloud One to your application by creating a non-compliant configuration on your cloud provider account and then running the bot as per the following:\n\n1. On the [Trend Micro Cloud One home](https://cloudone.trendmicro.com/home) page, click the **Conformity** tile.\n\n1. On the **Accounts** page, click **Run Conformity Bot**.\n\n   After the bot finishes running, confirm your localhost app receives a notification and logs both headers and body in the terminal.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Trend Micro webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Access [Trend Micro Cloud One](https://cloudone.trendmicro.com/) and sign in using your Trend Micro account.\n\n1. On the home page, click the **Conformity** tile.\n\n1. On the **Accounts** page, click **Settings**, click **Update communication settings** in the **Communication settings** section, click **Configure** in the **Webhooks** section, and then click **Configure now** in the webhook section.\n\n1. On the **Send notification to** popup, enter `12345` in the **Webhook Security Token** field and then click **Save**.\n\n1. Create a traffic policy file named `trendmicro_policy.yml`, replacing `{your webhook token}` with the value of the **Webhook Security Token** field:\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: trendmicro_conformity\n             secret: \"{your webhook token}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file trendmicro_policy.yml\n   ```\n\n1. Access the [Trend Micro Cloud One home](https://cloudone.trendmicro.com/home) page, click the **Conformity** tile, and then run the Conformity bot again.\n\n   After the bot finishes running, confirm your localhost app receives a notification and logs both headers and body in the terminal.\n",
			  "contentTitle": "Trend Micro Webhooks"
			}
		  ],
		  "metadata": {
			"name": "trendmicro",
			"description": "",
			"excerpt": "",
			"title": "Trend Micro"
		  }
		},
		{
		  "name": "trustelem",
		  "path": "/integrations/trustelem",
		  "docs": [
			{
			  "path": "/integrations/trustelem/sso-oidc",
			  "frontMatter": {
				"title": "Wallix Trustelem Endpoint SSO (OpenID Connect)",
				"description": "Use Wallix Trustelem OIDC to secure access to ngrok endpoints"
			  },
			  "content": "\nimport Disclaimer from \"/snippets/integrations/_endpoint-sso-disclaimer.mdx\";\n\n<Disclaimer />\n\n# Wallix Trustelem SSO (OpenID Connect)\n<Tip>\n**TL;DR**\n\n\n\nTo secure access to ngrok with Wallix Trustelem Single Sign-On using OpenID Connect:\n\n1. [Configure Wallix Trustelem SSO](#configure-wallix)\n1. [Configure ngrok](#configure-ngrok)\n1. [Test access to ngrok with Wallix Trustelem SSO](#test-sso)\n</Tip>\n\nThis article details how to configure Wallix Trustelem as the primary Identity Provider for ngrok tunnels.\nBy integrating Wallix Trustelem SSO with ngrok, you can:\n\n- **Restrict access to ngrok tunnels** only to users authenticated via Wallix Trustelem.\n- **Use Wallix Trustelem security policies and MFA authenticators**.\n- **Use Wallix Trustelem's Dashboard to facilitate access to ngrok apps**.\n\n## Supported Features\n\nThe ngrok integration with Wallix Trustelem supports:\n\n- **SP-Initiated SSO**: In this mode, users access ngrok edges and tunnels and are redirected to Wallix Trustelem for authentication.\n\n## Requirements\n\nTo configure ngrok tunnels with Wallix Trustelem, you must have:\n\n- a Wallix Trustelem account with administrative rights to create apps.\n- an [ngrok Enterprise Account](https://ngrok.com/pricing) with an authtoken or admin access to configure edges with OpenID Connect.\n\n## Configuration Steps\n\nTo integrate ngrok with Wallix Trustelem SSO, you will need to:\n\n1. Configure Wallix Trustelem with the ngrok app.\n1. Configure ngrok with the SSO settings provided by Wallix Trustelem.\n\n### **Step 1**: Configure Wallix Trustelem \n\n1. Access the [WALLIX Trustelem administration console](https://admin.trustelem.com/login), and sign in using your Trustelem account.\n\n1. On the **Dashboard** page, click **Apps** on the left menu, click **Add an application**, click the **OpenID Connect application** tile in the **Generic models** section.\n\n1. On the **Settings** popup, enter `ngrok oidc` in the **Name** field, enter `https://idp.ngrok.com/oauth2/callback` in the **RedirectURI** field, and enter `https://trustelem-sso-test.ngrok.app` in the **Login URL** field.\n   ![Wallix Trustelem configuration](img/ngrok_url_configuration_trustelem.png)\n\n1. On the **Settings** popup, make note of the value of both the **ClientID** and the **ClientSecret** fields, and then click **Save**.\n\n1. Make note of the value of the URL of the **Issuer** fields and then click **Close**.\n\n### **Step 2**: Configure ngrok \n\nngrok can leverage Wallix Trustelem SSO in two ways:\n\n- From the ngrok CLI (using the `--oidc` parameter)\n- From the ngrok dashboard\n\n### **Option 1**: ngrok CLI\n\n> **Note:** For this tutorial, we assume you have an app running locally (i.e., on localhost:3000) with the ngrok client installed.\n\n1. Launch a terminal\n\n1. Enter the following command to launch an ngrok tunnel with Wallix Trustelem SSO:\n\n   ```bash\n   ngrok http 3000 --oidc=Wallix Trustelem_OAUTH_URL \\\n   --oidc-client-id=Wallix Trustelem_CLIENT_ID \\\n   --oidc-client-secret=Wallix Trustelem_CLIENT_SECRET \\\n   ```\n\n   **Note**: Replace the following with values:\n   - Trustelem_OAUTH_URL: The issuer URL you copied from the Trustelem console.\n   - Trustelem_CLIENT_ID: The client id you copied from the Trustelem console.\n   - Trustelem_CLIENT_SECRET: The client secret you copied from the Trustelem console.\n\n   Alternatively, add the `--url YOUR_DOMAIN` argument to get your a custom URL, replacing `YOUR_DOMAIN` with your URL of preference.\n\n1. Copy the URL available next to **Forwarding** (for example, `https://trustelem-sso-test.ngrok.app`).\n\n1. Skip to **Step 3**\n\n### **Option 2**: ngrok Edge\n\nTo configure an edge with Wallix Trustelem:\n\n1. Access the [ngrok Dashboard](https://dashboard.ngrok.com/) and sign in using your ngrok account.\n\n1. On the left menu, click **Universal Gateway** and then click **Edges**.\n\n1. If you don't have an edge already set to add Wallix Trustelem SSO, create a test edge:\n   - Click **+ New Edge**.\n   - Click **Create HTTPS Edge**.\n   - Click the **pencil icon** next to \"no description\", enter `Edge with Trustelem SSO OIDC` as the edge name, and click **Save**.\n\n1. On the edge settings menu, click **OIDC**.\n\n1. Click **Begin setup** and enter the following values into the fields:\n   ![Wallix Trustelem config in ngrok](img/trustelem-1.png)\n   - **Issuer URL**: The issuer URL you copied from the Trustelem console.\n   - **Client ID**: The client id you copied from the Trustelem console.\n   - **Client Secret**: The client secret you copied from the Trustelem console.\n\n1. Click **Save** at the top.\n\n1. Launch a tunnel connected to your Wallix Trustelem edge:\n<Tip>\n**Note**\n\n\nFor this step, we assume you have an app running locally (i.e. on localhost:3000) with the ngrok client installed.\n</Tip>\n\n1.  Click **Start a tunnel**.\n\n1.  Click the **copy icon** next to the tunnel command.\n    ![tunnel config](img/trustelem-2.png)\n\n1.  Launch a tunnel:\n    - Launch a terminal.\n    - Paste the command but replace `http://localhost:80` with your localhost app address (i.e., `http://localhost:3000`).\n    - Click **Enter** and an ngrok tunnel associated with your edge configuration will launch.\n\n1.  To confirm that the tunnel is connected to your edge:\n    - Return to the ngrok dashboard\n    - Close the **Start a tunnel** and the **Tunnel group** tabs\n    - Refresh the test edge page. Under traffic, You will see the message _You have 1 tunnel online. Start additional tunnels to begin load balancing._\n      ![tunnel confirmed](img/trustelem-3.png)\n\n1.  In the test edge, copy the **endpoint URL**. (You use this URL to test the Wallix Trustelem Authentication)\n    ![tunnel url](img/trustelem-4.png)\n\n## Grant access to Wallix Trustelem users\n\nWallix Trustelem allows its users to access OIDC-integrated apps.\nTo create a user follow the instructions below:\n\n1. On the left menu of the [WALLIX Trustelem administration console](https://admin.trustelem.com/login), click **Users** and then click **Create User**.\n\n1. Enter values for **First Name**, **Last Name**, and **Primary Email** fields, and then click **Save**.\n\n## Test the integration \n\n1. In your browser, launch an incognito window.\n\n1. Access your ngrok tunnel (i.e., `https://trustelem-sso-test.ngrok.app` or using the copied endpoint URL).\n\n1. You should be prompted to log in with your Wallix Trustelem credentials.\n\n1. After logging in, you should be able to see your web app.\n",
			  "contentTitle": "Wallix Trustelem Endpoint SSO (OpenID Connect)"
			},
			{
			  "path": "/integrations/trustelem/sso-saml",
			  "frontMatter": {
				"description": "Use Wallix Trustelem SAML to secure access to ngrok endpoints",
				"title": "Wallix Trustelem SSO (SAML)"
			  },
			  "content": "import Disclaimer from \"/snippets/integrations/_endpoint-sso-disclaimer.mdx\";\n\n<Disclaimer />\n<Tip>\n**TL;DR**\n\n\n\nTo secure access to ngrok with Wallix Trustelem Single Sign-On using SAML:\n\n1. [Configure Wallix Trustelem SSO](#configure-wallix)\n1. [Configure ngrok](#configure-ngrok)\n1. [Test access to ngrok with Wallix Trustelem SSO](#test-sso)\n</Tip>\n\nThis article details how to configure Wallix Trustelem as the primary Identity Provider for ngrok tunnels.\nBy integrating Wallix Trustelem SSO with ngrok, you can:\n\n- **Restrict access to ngrok tunnels** only to users authenticated via Wallix Trustelem.\n- **Use Wallix Trustelem security policies and MFA authenticators**.\n- **Use Wallix Trustelem's Dashboard to facilitate access to ngrok apps**.\n\n## Requirements\n\nTo configure ngrok tunnels with Wallix Trustelem, you must have:\n\n- a Wallix Trustelem account with administrative rights to create apps.\n- an [ngrok Enterprise Account](https://ngrok.com/pricing) with an authtoken or admin access to configure edges with SAML.\n\n## Configuration Steps\n\nTo integrate ngrok with Wallix Trustelem SSO, you will need to:\n\n1. Configure Wallix Trustelem with the ngrok app.\n1. Configure ngrok with the SSO settings provided by Wallix Trustelem.\n\n### **Step 1**: Configure Wallix Trustelem \n\n1. Access the [WALLIX Trustelem administration console](https://admin.trustelem.com/login), and sign in using your Trustelem account.\n\n1. On the **Dashboard** page, click **Apps** on the left menu, click **Add an application** and click the **SAML 2 application** tile in the **Generic models** section.\n\n1. On the **Settings** popup, enter `ngrok saml` in the **Name** field, click **Save**, click **Download metadata files**, save the XML file on your desktop, and then click **Close**.\n\n### **Step 2**: Configure ngrok \n\nTo configure an edge with Wallix Trustelem:\n\n1. Access the [ngrok Dashboard](https://dashboard.ngrok.com/) and sign in using your ngrok account.\n\n1. On the left menu, click **Universal Gateway** and then click **Edges**.\n\n1. If you don't have an edge already set to add Wallix Trustelem SSO, create a test edge:\n   - Click **+ New Edge**.\n   - Click **Create HTTPS Edge**.\n   - Click the **pencil icon** next to \"no description\", enter `Edge with Trustelem SSO SAML` as the edge name, and click **Save**.\n\n1. On the edge settings menu, click **SAML**.\n\n1. On the **SAML** page, click **Begin setup**, click **Upload XML**, and then open the XML metadata file you downloaded from Wallix Trustelem (See [Download the IdP metadata](#configure-wallix)).\n   ![Wallix Trustelem configuration](img/trustelem-5.png)\n\n1. Click **Save** at the top.\n\n1. On the **SAML** page of your [ngrok edge](https://dashboard.ngrok.com/edges), make note of the URL of both the **Entity ID** and **ACS URL** fields.\n\n### **Step 3**: Link Wallix Trustelem with ngrok \n\n1. On the [WALLIX Trustelem administration console](https://admin.trustelem.com/login), click **Apps** on the left menu, and then click your application.\n\n1. On the **Settings** popup, click **Edit**, paste the **Entity ID** URL in the **EntityID** field and the **ACS URL** URL in the **Assertion Consumer Service** field.\n   **Tip**: You copied both URLs from the previous step.\n   ![Wallix Trustelem config in ngrok](img/trustelem-6.png)\n\n1. Click **Save**.\n\n### **Step 4**: Start a Tunnel \n\n1. Access the [ngrok edges page](https://dashboard.ngrok.com/edges), click your edge, and then click **Start a tunnel**.\n<Tip>\n**Note**\n\n\nFor this step, we assume you have an app running locally (i.e. on localhost:3000) with the ngrok client installed.\n</Tip>\n\n1. Click the **copy icon** next to the tunnel command.\n   ![tunnel config](img/trustelem-2.png)\n\n1. Launch a tunnel:\n   - Launch a terminal.\n   - Paste the command but replace `http://localhost:80` with your localhost app address (i.e., `http://localhost:3000`).\n   - Click **Enter** and an ngrok tunnel associated with your edge configuration will launch.\n\n1. To confirm that the tunnel is connected to your edge:\n   - Return to the ngrok dashboard\n   - Close the **Start a tunnel** and the **Tunnel group** tabs\n   - Refresh the test edge page. Under traffic, You will see the message _You have 1 tunnel online. Start additional tunnels to begin load balancing._\n     ![tunnel confirmed](img/trustelem-3.png)\n\n1. In the test edge, copy the **endpoint URL**. (You use this URL to test the Wallix Trustelem Authentication)\n   ![tunnel url](img/trustelem-4.png)\n\n## Grant access to Wallix Trustelem users \n\nWallix Trustelem allows their users to access SAML-integrated apps.\nTo create a user follow the instructions below:\n\n1. On the left menu the [WALLIX Trustelem administration console](https://admin.trustelem.com/login), click **Users** and then click **Create User**.\n\n1. Enter values for **First Name**, **Last Name**, and **Primary Email** fields, and then click **Save**.\n\n## Test the integration \n\n1. In your browser, launch an incognito window.\n\n1. Access your ngrok tunnel (i.e., `https://trustelem-sso-test.ngrok.app` or using the copied endpoint URL).\n\n1. You should be prompted to log in with your Wallix Trustelem credentials.\n\n1. After logging in, you should be able to see your web app.\n",
			  "contentTitle": "Wallix Trustelem SSO (SAML)"
			}
		  ],
		  "metadata": {
			"name": "trustelem",
			"description": "",
			"excerpt": "",
			"title": "Trustelem (Wallix)"
		  }
		},
		{
		  "name": "twilio",
		  "path": "/integrations/twilio",
		  "docs": [
			{
			  "path": "/integrations/twilio/webhooks",
			  "frontMatter": {
				"description": "Develop and test Twilio webhooks from localhost",
				"title": "Twilio SMS Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Twilio webhooks with ngrok:\n\n1. [Start your local twillio webhook app.](#start-your-app) `npm start`\n1. [Start ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Twilio with your ngrok url and start testing.](#setup-twilio)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with [Twilio SMS Webhooks](https://www.twilio.com/docs/usage/webhooks/sms-webhooks). By integrating ngrok with Twilio, you can:\n\n- **Develop and test Twilio webhooks locally**, eliminating the time in deploying your development code to a public environment\n- **Secure your app by validating Twilio webhook using ngrok**, letting ngrok handle security leaving more time for developing what really matters\n- **Inspect and troubleshoot requests from Twilio** in real-time via the inspection UI and API\n- **Modify and Replay Twilio Webhook requests** with a single click and without spending time reproducing events manually in Twilio\n\n## **Step 1**: Start your app \n\nAn example express app can be found on GitHub here: [https://github.com/thomas-ngrok/ngrok-example-twilio-sms-webhook](https://github.com/thomas-ngrok/ngrok-example-twilio-sms-webhook).\n\n```js\n{/* var MessagingResponse = require(\"twilio\").twiml.MessagingResponse;\n\n/*** POST /sms listing. ***/\nrouter.post(\"/\", function (req, res, next) {\n\tconst twiml = new MessagingResponse();\n\ttwiml.message(\"The Robots are coming! Head for the hills!\");\n\tres.writeHead(200, { \"Content-Type\": \"text/xml\" });\n\tres.end(twiml.toString());\n});\n```\n\nStart your app on port 3000. You can validate it is up and running by visiting [http://localhost:3000](http://localhost:3000).\n\nThe part we are going to focus on is http://localhost:3000/sms found under /routes/sms.js in the Express example code.\n\nMore information on using Twilio webhooks can be found here: [https://www.twilio.com/blog/parsing-an-incoming-twilio-sms-webhook-with-node-js](https://www.twilio.com/blog/parsing-an-incoming-twilio-sms-webhook-with-node-js)\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up to ngrok for free](https://ngrok.com/signup).\n\n2. [Download the ngrok agent](https://download.ngrok.com).\n\n3. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the authtoken to log into your account when you start a tunnel.\n4. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n5. ngrok will display a url where your example applicaiton is exposed to the internet (copy this URL for use with Twilio).\n   ![ngrok agent running](img/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Twilio SMS Webhook \n\nNow that you have your local environment on the internet, let's configure Twilio to call your code.\n\n1. Sign in to your Twilio account.\n2. From the Twilio Console, go to **Develop** > **# Phone Numbers** > **Manage** > **Active Numbers** and select a number to add a webhook to.\n3. At the bottom of the page, under Messaging, (1) add your ngrok url (don't forget to append /sms) under Webhook and (2) change the type to HTTP Post.\n   ![Twilio SMS Webhook Config Screen](img/add_ngrok_url_to_Twilio.png)\n4. Save the phone number configuration.\n\nCongrats, everything is configured! Now it's time to test.\n\n### Run Webhooks with Twilio and ngrok\n\n1. Send an SMS message to your Twilio Phone number that was configured in the steps above.\n2. Get excited (and maybe a little scared) when you get a text back saying, **\"The Robots are coming! Head for the hills!\"**\n\nCongrats! You got an end-to-end example working but there's even more you can do with ngrok that will make development even easier. Check out how to inspect and replay your requests without having to send an SMS. Trust me, you won't regret it.\n\n## Optional next steps \n\n### Add additional security using ngrok's signature webhook verification\n\nThe webhook verification module allows ngrok to assert requests to your endpoint originate from Twillio. This is a quick step to add extra protection to your setup.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\n1. Login to [Twilio Console](https://console.twilio.com/) and copy your Auth Token value.<br />\n   **Note:** ngrok Webhook Verification ensures traffic from your Twilio account is the **only traffic allowed** to make calls to your app. Because Twilio signs all Webhooks using the Primary Auth Token, ngrok can verifies the signature of every request and only authorizing requests originating from your Twilio account.\n2. Create a traffic policy file named `twilio_policy.yml`:\n\n```yaml\non_http_request:\n  - actions:\n      - type: verify-webhook\n        config:\n          provider: twilio\n          secret: \"{your auth token}\"\n```\n\n3. Restart ngrok by running the command:\n\n```bash\n   ngrok http 3000 --traffic-policy-file twilio_policy.yml\n```\n\n<InspectingRequests />\n\n<ReplayingRequests />\n */}",
			  "contentTitle": "Twilio SMS Webhooks"
			}
		  ],
		  "metadata": {
			"name": "twilio",
			"description": "",
			"excerpt": "",
			"title": "Twilio"
		  }
		},
		{
		  "name": "twitch",
		  "path": "/integrations/twitch",
		  "docs": [
			{
			  "path": "/integrations/twitch/oauth",
			  "frontMatter": {
				"description": "Authenticate users with Twitch OAuth",
				"title": "Twitch"
			  },
			  "content": "import Twitch from \"/snippets/traffic-policy/actions/oauth/examples/custom-twitch-example.mdx\";\nimport UpdatePolicyInstructions from \"/snippets/traffic-policy/actions/oauth/update-policy/update-policy-instructions.mdx\";\n\n\n\n## Creating a custom Twitch OAuth application\n\nThe step-by-step instructions below follow Twitch's documentation on [Using OAuth 2.0](https://dev.twitch.tv/docs/authentication/) for authentication.\n\n### Create credentials for ngrok\n\n1.  Navigate to the [Twitch developer console](https://dev.twitch.tv/console), sign in, click **Applications** on the left menu, and then click **Register Your Application**.\n\n2.  On the **Register Your Application** page, provide a **Name** for your application, enter `https://idp.ngrok.com/oauth2/callback` in the **OAuth Redirect URLs** field, select **Website Integration** in the **Category** selector, and then click **Create**.\n\n    **Note**: Make sure you have two-factor authentication enabled for your Twitch account.\n\n3.  On the **Developer Applications** page, click **Manage** for your application.\n\n4.  On the application page, click **New Secret**, and make a note of the **Client ID** and **Client Secret** values.\n\n    ![](/img/howto/oauth/1-twitch-register.png)\n\n### Update your ngrok endpoint traffic policy\n\n<UpdatePolicyInstructions policySnippet={<Twitch />} />\n\n### Additional application setup information\n\n- [Authentication](https://dev.twitch.tv/docs/authentication/)\n- [Registering Your App](https://dev.twitch.tv/docs/authentication/register-app/)\n",
			  "contentTitle": "Twitch"
			}
		  ],
		  "metadata": {
			"name": "twitch",
			"description": "",
			"title": "Twitch"
		  }
		},
		{
		  "name": "twitter",
		  "path": "/integrations/twitter",
		  "docs": [
			{
			  "path": "/integrations/twitter/webhooks",
			  "frontMatter": {
				"description": "Develop and test X (formerly Twitter) webhooks from localhost",
				"title": "X (formerly Twitter) Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate X (formerly Twitter) webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure X webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with X by using Webhooks.\nX webhooks can be used to notify an external application whenever specific events occur in your X account.\n\nBy integrating ngrok with X, you can:\n\n- **Develop and test X webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from X** in real-time via the inspection UI and API.\n- **Modify and Replay X Webhook requests** with a single click and without spending time reproducing events manually in your X account.\n- **Secure your app with X validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with X).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate X \n\nTo register a webhook on your X account follow the instructions below:\n\n1. Access the [X Developer Portal](https://developer.twitter.com/), sign in using your X account, and then click **Developer Portal**.<br/>\n   **Tip**: In order to continue, you need to have an approved developer account in the X developer portal.\n\n1. On the **Dashboard** page, click **Create Project**, enter `ngrok` in the **Project name** field, and then click **Next**.\n\n1. In the **Use case** tab, select your role as **Student** and then click **Next**.\n\n1. Enter `ngrok webhook docs` in the **Project description** field and click **Next**.\n\n1. On the **Choose an App environment** page, select **Development** as the **App environment**, enter a name for your app in the **App name** field and then click **Next**.\n\n1. On the **Here are your keys & tokens** page, make note of the value of the **API Key**, **API Key Secret**, and **Bearer Token** fields.\n\n1. On the left menu, click **Projects & Apps**, click **ngrok**, and then click your app.\n\n1. On the app page, click the **Keys and tokens** tab, click **Generate** in the **Access Token and Secret** section, and then copy the value of the **Access Token** and **Access Token Secret** fields.\n\n1. On the left menu, click **Products**, click **Premium**, and then click **Dev environments**.\n\n1. On the **Dev environments** page, click **Set up dev environment** in the **Account Activity API** section, enter a name for environment and then select you app in the **App** combobox.\n\n1. In a terminal window, run the following command to register the webhook:\n\n   ```bash\n   curl --request POST --url https://api.twitter.com/1.1/account_activity/webhooks.json?url=ENCODED_URL \\\n   --header 'authorization: OAuth oauth_consumer_key=\"CONSUMER_KEY\", oauth_nonce=\"GENERATED\", oauth_signature=\"GENERATED\", oauth_signature_method=\"HMAC-SHA1\", oauth_timestamp=\"GENERATED\", oauth_token=\"ACCESS_TOKEN\", oauth_version=\"1.0\"'\n   ```\n\n   **Note**: Replace the following with values copied on previous steps:\n   - APP_NAME: Your app name.\n   - ENCODED_URL: the URL provided by the ngrok agent to expose your application to the internet encoded (i.e. `https%3A%2F%2F1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   - CONSUMER_KEY: the app API Key.\n   - ACCESS_TOKEN: The bearer token you copied before.\n\n   ![twitter URL to Publish](img/ngrok_url_configuration_twitter.png)\n\n1. Copy the ID of the webhook you created.\n\n1. In a terminal window, run the following command to subscribe a user to this webhook:\n   ```bash\n    curl --request POST --url https://api.twitter.com/1.1/account_activity/all/APP_NAME/subscriptions.json \\\n    --header 'authorization: OAuth oauth_consumer_key=\"CONSUMER_KEY\", oauth_nonce=\"GENERATED\", oauth_signature=\"GENERATED\", oauth_signature_method=\"HMAC-SHA1\", oauth_timestamp=\"GENERATED\", oauth_token=\"SUBSCRIBING_USER_ACCESS_TOKEN\", oauth_version=\"1.0\"'\n   ```\n   **Note**: Replace the following with values copied on previous steps:\n   - APP_NAME: Your app name.\n   - CONSUMER_KEY: the app API Key.\n   - SUBSCRIBING_USER_ACCESS_TOKEN: The access token from a X user.\n\n### Run Webhooks with X and ngrok\n\nX sends different request body contents depending on the event that is being triggered.\nYou can trigger new calls from X to your application by following the instructions below.\n\n1. Acces [X](https://www.twitter.com/), sign in and post a tweet.\n\n   Confirm your localhost app receives a notification and logs both headers and body in the terminal.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your X webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. During the webhook registration you provide a\n1. On the top menu of the developer site, click **DEVELOPER TOOLS** and then click **Webhooks**.\n\n1. On the **Webhooks** page, click **Copy** to copy the **Secret** value.\n\n1. Create a traffic policy file named `twitter_policy.yml`, replacing `{your webhook secret}` with the value you copied before:\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: twitter\n             secret: \"{your webhook secret}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file twitter_policy.yml\n   ```\n\n1. Access [X](https://www.twitter.com/) and post a new tweet.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "X (formerly Twitter) Webhooks"
			}
		  ],
		  "metadata": {
			"name": "twitter",
			"description": "",
			"excerpt": "",
			"title": "Twitter"
		  }
		},
		{
		  "name": "typeform",
		  "path": "/integrations/typeform",
		  "docs": [
			{
			  "path": "/integrations/typeform/webhooks",
			  "frontMatter": {
				"description": "Develop and test Typeform webhooks from localhost",
				"title": "Typeform Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Typeform webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Typeform webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Typeform by using Webhooks.\nTypeform webhooks can be used to notify an external application whenever specific events occur in your Typeform account.\n\nBy integrating ngrok with Typeform, you can:\n\n- **Develop and test Typeform webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Typeform** in real-time via the inspection UI and API.\n- **Modify and Replay Typeform Webhook requests** with a single click and without spending time reproducing events manually in your Typeform account.\n- **Secure your app with Typeform validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Typeform).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Typeform \n\nTo register a webhook on your Typeform account follow the instructions below:\n\n1. Access [Typeform](https://www.typeform.com/) and sign in using your Typeform account.\n\n1. On your workspace click one of the forms you have listed.\n   **Note**: If you don't have a form created, click **Create typeform**, click **Create it for me**, and then click **Publish**.\n\n1. On your form page, click **Connect** on the top menu, click the **WEBHOOKS** tab, and then click **Add a webhook**.\n\n1. On the **Add a webhook** popup, enter the URL provided by the ngrok agent to expose your application to the internet in the **Endpoint** field (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![URL to Publish](img/ngrok_url_configuration_typeform.png)\n\n1. Click **Save Webhook**.\n\n1. On the **Webhook** page, click the **Webhook** switch to turn it on, click **Edit**, enter `12345` in the **Secret** field, and then click **Save changes**.\n   ![URL to Publish](img/ngrok_url_configuration_typeform_2.png)\n\n### Run Webhooks with Typeform and ngrok\n\nTypeform sends a post request to your application whenever someone submits a new typeform.\nYou can trigger new calls from Typeform to your application by following the instructions below.\n\n1. In the same browser, access [Typeform admin console](https://www.typeform.com/), click the name of your typeform, click **Share** on the top menu, click **Copy link** and then open this link in a new web browser tab or window.\n\n1. Answer the questions in your typeform, and then click **Submit** at the end of the form flow.\n\n   Confirm your localhost app receives the create-project event notification and logs both headers and body in the terminal.\n\nAlternatively, you can verify the log of the webhook call in Typeform:\n\n1. Access the [Typeform admin console](https://www.typeform.com/), click the name of your typeform, click **Connect** on the top menu, click the **WEBHOOKS** tab, and then click **View deliveries**.\n   ![Webhook Logs](img/ngrok_logs_typeform.png)\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Typeform webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Create a traffic policy file named `typeform_policy.yml`, replacing `{your webhook secret}` with the value of the **secret** attribute you provided in the webhook registration (See [Integrate ngrok and Typeform.](#setup-webhook)):\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: typeform\n             secret: \"{your webhook secret}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file typeform_policy.yml\n   ```\n\n1. Access your form URL, answer the questions of your typeform, and then click **Submit** at the end of the form flow.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "Typeform Webhooks"
			}
		  ],
		  "metadata": {
			"name": "typeform",
			"description": "",
			"excerpt": "",
			"title": "Typeform"
		  }
		},
		{
		  "name": "vcluster",
		  "path": "/integrations/vcluster",
		  "docs": [
			{
			  "path": "/integrations/vcluster/k8s",
			  "frontMatter": {
				"title": "Ingress to Kubernetes apps and srevices with vcluster",
				"description": "Setup a local virtual cluster to demonstrate how to use the ngrok Kubernetes Operator with vcluster."
			  },
			  "content": "\nThe ngrok [Operator for Kubernetes](https://ngrok.com/blog-post/ngrok-k8s) is the official controller for\nadding public and secure ingress traffic to your k8s services. This open source Operator works with any cloud,\nlocally-hosted, or on-premises Kubernetes cluster to provide ingress to your applications, APIs, or other services while\nalso offloading network ingress and middleware execution to ngrok's platform.\n\n[vcluster](https://www.vcluster.com/) is an open source project for creating virtual clusters that run inside regular\nnamespaces, which provides strong isolation and easy access for multiple tenants with low cost and overhead. The pods\nyou deploy on a vcluster are scheduled inside of the underlying cluster, while other resources, like deployments and\nCRDs, exist only inside the virtual cluster.\n\nTogether, the ngrok Kubernetes Operator and vcluster work to provide secure and load-balanced ingress for services\nrunning on a virtual cluster, which lets you isolate development environments, create an internal developer platform\n(IDP) in cloud native environments, and run experiments or simulations virtually while properly routing external\ntraffic.\n\nWith this guide, you'll use an existing Kubernetes cluster, or set up a local development cluster with minikube, to\nlaunch a virtual cluster, and deploy a demo application. You'll then deploy the ngrok Kubernetes Operator to connect your\ndemo application to the ngrok platform to route traffic to your vcluster.\n\n## What you'll need\n\n- The [vcluster CLI](https://www.vcluster.com/docs/get-started/#deploy-vcluster) installed locally.\n- An existing remote or local Kubernetes cluster _OR_ [minikube](https://minikube.sigs.k8s.io/docs/start/) to create a\n  new demo cluster locally.\n- An [ngrok account](https://ngrok.com/signup).\n- [kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl/) and [Helm\n  3.0.0+](https://helm.sh/docs/intro/install/) installed on your local\n  workstation.\n- The [ngrok Kubernetes Operator](/k8s/) installed on\n  your cluster.\n- A reserved domain, which you can get in the ngrok\n  [dashboard](https://dashboard.ngrok.com/domains) or with the [ngrok\n  API](/api/resources/reserved-domains/).\n  - You can choose from an ngrok subdomain or bring your own custom branded\n    domain, like `https://api.example.com`.\n  - We'll refer to this domain as `<NGROK_DOMAIN>`.\n\n## Set up a local virtual cluster with vcluster \n\nTo follow along with this guide, you need a remote or local Kubernetes cluster with vcluster installed. If you have an\nexisting cluster with vcluster set up, you can skip this step and proceed to\n[Step 2: Install a sample application](#install-a-sample-application).\n\nIf you don't have a cluster already, create one locally with minikube and install vcluster.\n\n1. Create a local Kubernetes cluster with minikube.\n\n   ```bash\n   minikube start --profile dc1 --memory 4096\n   ```\n\n1. Use the `minikube` CLI to ensure your new local cluster is running properly.\n\n   ```bash\n   kubectl get namespaces\n\n   NAME              STATUS   AGE\n   default           Active   5m55s\n   kube-node-lease   Active   5m55s\n   kube-public       Active   5m55s\n   kube-system       Active   5m55s\n   ```\n\n1. Create a new vcluster with the name `my-vcluster`, which creates a new namespace called `vcluster-my-cluster` and automatically switches the active kube context to use your new vcluster.\n\n   ```bash\n   vcluster create my-vcluster --expose-local\n   ```\n\n1. To ensure your new local cluster is running properly get the namespaces for your instance. Your list of namespaces in the `my-vcluster` context should look something like this.\n\n   ```bash\n   kubectl get namespaces\n\n   NAME              STATUS   AGE\n   default           Active   19s\n   kube-system       Active   19s\n   kube-public       Active   19s\n   kube-node-lease   Active   19s\n   ```\n\n   If you are not connected to your new vcluster and its kube context, you can run `vcluster connect my-vcluster` to try\n   again.\n\n   You know have a vcluster installed on your local minikube cluster.\n<Note>\n**These steps are partially based the guide [Using the ngrok Kubernetes Operator to create Preview Environments with vcluster](https://loft.sh/blog/using-the-ngrok-ingress-controller-to-create-preview-environments-with-vcluster/) from [Loft](https://loft.sh/), the maintainers of vcluster.**\n</Note>\n\n## Install a sample application \n\nAt this point, you have a functional vcluster with the ngrok Kubernetes Operator running and authenticated with your\nngrok credentials. To demonstrate how the Operator simplifies routing external traffic to your primary\ncluster, virtual cluster, and ultimately an exposed service or endpoint, you can install a sample application.\n\n1. Reserve a domain for ingress if you don't have one already. Navigate to the [**Domains**\n   section](https://dashboard.ngrok.com/domains) of the ngrok dashboard and click **Create Domain** or **New\n   Domain**. We'll refer to this as `<NGROK_DOMAIN>` for the remainder of this guide.\n\n   By creating a subdomain on the ngrok network, you provide a public route to accept HTTP, HTTPS, and TLS traffic.\n\n1. Create a new Kubernetes manifest (`2048.yaml`) with the below contents. This manifest defines the 2048 application\n   service and deployment, then configures the ngrok Kubernetes Operator to connect the `game-2048` service to the ngrok\n   network. Be sure to replace `<NGROK_DOMAIN>` with the domain you reserved a\n   moment ago.\n\n   ```yaml\n   apiVersion: v1\n   kind: Service\n   metadata:\n     name: game-2048\n     namespace: default\n   spec:\n     ports:\n       - name: http\n         port: 80\n         targetPort: 80\n     selector:\n       app: game-2048\n   ---\n   apiVersion: apps/v1\n   kind: Deployment\n   metadata:\n     name: game-2048\n     namespace: default\n   spec:\n     replicas: 1\n     selector:\n       matchLabels:\n         app: game-2048\n     template:\n       metadata:\n         labels:\n           app: game-2048\n       spec:\n         containers:\n           - name: backend\n             image: alexwhen/docker-2048\n             ports:\n               - name: http\n                 containerPort: 80\n   ---\n   # ngrok Kubernetes Operator Configuration\n   apiVersion: networking.k8s.io/v1\n   kind: Ingress\n   metadata:\n     name: game-2048-ingress\n     namespace: default\n   spec:\n     ingressClassName: ngrok\n     rules:\n       - host: <NGROK_DOMAIN>\n         http:\n           paths:\n             - path: /\n               pathType: Prefix\n               backend:\n                 service:\n                   name: game-2048\n                   port:\n                     number: 80\n   ```\n\n1. Apply the `2048.yaml` manifest to your vcluster.\n\n   ```bash\n   kubectl apply -f 2048.yaml\n   ```\n<Tip>\n****Note:** If you get an error when applying the manifest, double check that you've updated the `NGROK_DOMAIN` value**\n\n\n   and try again.\n\n</Tip>\n\n1. Access your 2048 demo app by navigating to the your domain, e.g. `https://one-two-three.ngrok.app`. ngrok's edge\n   and your Operator will route traffic to your app from any device or external network as long as your\n   vcluster remains operational.\n\n   ![\"Navigating directly to the https://one-two-three.ngrok.app domain to see the 2048 application\"](img/ngrok-k8s-vcluster_2048.png)\n\n## Add OAuth protection to your demo app \n\nLet's take your ingress needs a little further by assuming you want to add edge security, in the form of Google OAuth,\nto the endpoint where your 2048 application is humming along.\n\nWith our [Traffic Policy system](/traffic-policy/) and the [`oauth`\naction](/traffic-policy/actions/oauth), ngrok manages OAuth protection\nentirely at the ngrok cloud service, which means you don't need to add any\nadditional services to your cluster, or alter routes, to ensure ngrok's edge\nauthenticates and authorizes all requests before allowing ingress and access to\nyour endpoint.\n\nTo enable the `oauth` action, you'll create a new `NgrokTrafficPolicy` custom\nresource and apply it to your entire `Ingress` with an annotation. You can also\napply the policy to just a specific backend or as the default backend for an\n`Ingress`—see our doc on using the [Operator with\nIngresses](/k8s/guides/using-ingresses/#using-ngroktrafficpolicy-with-ingress).\n\n1. Edit your existing `2048.yaml` manifest with the following, leaving the\n   `Service` and `Deployment` as they were. Note the new `annotations` field and\n   the `NgrokTrafficPolicy` CR.\n\n   ```yaml\n    ...\n   ---\n   # Configuration for ngrok's Kubernetes Operator\n   apiVersion: networking.k8s.io/v1\n   kind: Ingress\n   metadata:\n     name: game-2048-ingress\n     namespace: default\n     annotations:\n       k8s.ngrok.com/traffic-policy: oauth\n   spec:\n     ingressClassName: ngrok\n     rules:\n       - host: <NGROK_DOMAIN>\n         http:\n           paths:\n             - path: /\n               pathType: Prefix\n               backend:\n                 service:\n                   name: game-2048\n                   port:\n                     number: 80\n   ---\n   # Traffic Policy configuration for OAuth\n   apiVersion: ngrok.k8s.ngrok.com/v1alpha1\n   kind: NgrokTrafficPolicy\n   metadata:\n     name: oauth\n     namespace: default\n   spec:\n     policy:\n   \t   on_http_request:\n   \t\t   - type: oauth\n   \t\t\t   config:\n   \t\t\t     provider: google\n   ```\n\n1. Re-apply your `2048.yaml` configuration.\n\n   ```bash\n   kubectl apply -f 2048.yaml\n   ```\n\n1. When you open your demo app again, you'll be asked to log in via Google.\n   That's a start, but what if you want to authenticate only yourself or colleagues?\n\n1. You can use [expressions](/traffic-policy/concepts/expressions) and [CEL\n   interpolation](/traffic-policy/concepts/cel-interpolation) to filter out\n   and reject OAuth logins that don't contain `example.com`. Update the\n   `NgrokTrafficPolicy` portion of your manifest after changing `example.com` to\n   your domain.\n\n   ```yaml\n   # Traffic Policy configuration for OAuth\n   apiVersion: ngrok.k8s.ngrok.com/v1alpha1\n   kind: NgrokTrafficPolicy\n   metadata:\n     name: oauth\n     namespace: default\n   spec:\n     policy:\n       on_http_request:\n         - type: oauth\n           config:\n             provider: google\n         - expressions:\n             - \"!actions.ngrok.oauth.identity.email.endsWith('@example.com')\"\n           actions:\n             - type: custom-response\n               config:\n                 body: \"Hey, no auth for you ${actions.ngrok.oauth.identity.name}!\"\n                 status_code: 400\n   ```\n\n1. Check out your deployed 2048 app once again. If you log in with an email that\n   doesn't match your domain, ngrok rejects your request. Authentication... done!\n\n## What's next?\n\nYou've now used the open source ngrok Kubernetes Operator to add secure access to your endpoint without\nworrying about IPs, network interfaces, or VPC routing. Because ngrok offloads ingress and middleware execution to its\nglobal edge, you can follow the same procedure listed above for any Kubernetes environment, like EKS, GKE, and\nOpenShift, with similar results.\n\nIf you want to clean up the work you did for this demo application, the easiest way (and the advantage of virtual\nclusters in the first place) is to disconnect from your vcluster and then delete it with the `vcluster` CLI. That will remove the namespace and all its resources, returning your primary cluster to its initial state.\n\n```bash\nvcluster disconnect\nvcluster delete my-vcluster\n```\n\nFor next steps, explore our [Kubernetes docs](/k8s/) for more details on\nhow the Operator works, different ways you can integrate ngrok with an existing\nproduction cluster, or use more advanced features like\n[bindings](/k8s/guides/bindings/) or [endpoint\npooling](/k8s/guides/pooling/).\n",
			  "contentTitle": "Ingress to Kubernetes apps and srevices with vcluster"
			}
		  ],
		  "metadata": {
			"name": "vcluster",
			"description": "",
			"excerpt": "",
			"title": "vcluster"
		  }
		},
		{
		  "name": "vmware",
		  "path": "/integrations/vmware",
		  "docs": [
			{
			  "path": "/integrations/vmware/webhooks",
			  "frontMatter": {
				"description": "Develop and test VMware webhooks from localhost",
				"title": "VMware Workspace ONE Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate VMware Workspace ONE webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure VMware Workspace ONE webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with VMware Workspace ONE by using Webhooks.\nVMware Workspace ONE webhooks can be used to notify an external application whenever specific events occur in your VMware Workspace ONE account.\n\nBy integrating ngrok with VMware Workspace ONE, you can:\n\n- **Develop and test VMware Workspace ONE webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from VMware Workspace ONE** in real-time via the inspection UI and API.\n- **Modify and Replay VMware Workspace ONE Webhook requests** with a single click and without spending time reproducing events manually in your VMware Workspace ONE account.\n- **Secure your app with VMware Workspace ONE validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with VMware Workspace ONE).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate VMware Workspace ONE \n\nTo register a webhook on your VMware Workspace ONE account follow the instructions below:\n\n1. Access [VMware Workspace ONE](https://console.cloud.vmware.com/) and sign in using your VMware account.\n\n1. On the **Services** page, click **LAUNCH SERVICE** in the **Workspace ONE** tile.\n\n1. On the Workspace ONE **Home** page, click **MANAGE** in the **Unified Endpoint Management** tile.\n\n1. On the **Workspace ONE UEM** page, click **GROUPS & SETTINGS** on the left menu, click **All Settings**, click **Advanced** in the **System** section, click **API**, and then click **Event Notifications**.\n\n1. On the **Event Notifications** page, click the **Override** radio button and then click **ADD RULE**.\n\n1. On the **Add Event Notification** popup, enter `My Webhook` in the **Target Name** field and enter the URL provided by the ngrok agent to expose your application to the internet in the **Target URL** field (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![Target URL](img/ngrok_url_configuration_vmware.png)\n\n1. Click **JSON** as the **Format** and then click **TEST CONNECTION**.\n\n   Confirm your localhost app receives a request and logs both headers and body in the terminal, and the message **Test is successful** appears on the screen.\n\n1. In the **Events** section, click **ENABLED** for all events and then click **SAVE**.\n\n### Run Webhooks with VMware Workspace ONE and ngrok\n\nYou can trigger new calls from VMware Workspace ONE to your application by following the instructions below.\n\n1. Access [VMware Workspace ONE](https://console.cloud.vmware.com/), click **LAUNCH SERVICE** in the **Workspace ONE** tile, and then click **MANAGE** in the **Unified Endpoint Management** tile.\n\n1. On the **Workspace ONE UEM** page, click **DEVICES** on the left menu, click **List View** and then click **ADD DEVICE**.\n\n1. On the **Add Device** popup, select a user, enter a valid email address in the **Email address** field in the **Messaging** section, and then click **SAVE**.\n   **Note**: If you don't have any users click the **Create New User** link and enter values for all the required fields.\n\n1. The email address you entered in the **Email address** field receives an email with the subject **Workspace ONE UEM Device Activation**. Use a mobile device to open the email and click the link to enroll the device using the **Username** and **Password** of the selected user.\n\n   Confirm your localhost app receives a notification and logs both headers and body in the terminal.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your VMware Workspace ONE webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Access [VMware Workspace ONE](https://console.cloud.vmware.com/) and sign in using your VMware account.\n\n1. On the **Services** page, click **LAUNCH SERVICE** in the **Workspace ONE** tile.\n\n1. On the Workspace ONE **Home** page, click **MANAGE** in the **Unified Endpoint Management** tile.\n\n1. On the **Workspace ONE UEM** page, click **GROUPS & SETTINGS** on the left menu, click **All Settings**, click **Advanced** in the **System** section, click **API**, and then click **Event Notifications**.\n\n1. On the **Event Notifications** page, click the radio button of your webhook and then click **EDIT**.\n\n1. On the **Edit Event Notification** page, enter a username in the **Username** field, enter a password in the **Password**, enter the same password in the **Confirm Password** field, and then click **SAVE**.\n\n1. Create a traffic policy file named `vmware_policy.yml`, replacing `{username}` and `{password}` with the corresponding values you provided before:\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: vmware_workspace\n             secret: \"{username}::{password}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file vmware_policy.yml\n   ```\n\n1. Access [VMware Workspace ONE](https://console.cloud.vmware.com/), register a new user to your device, and ask the user to enroll the device.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "VMware Workspace ONE Webhooks"
			}
		  ],
		  "metadata": {
			"name": "vmware",
			"description": "",
			"excerpt": "",
			"title": "VMware"
		  }
		},
		{
		  "name": "webex",
		  "path": "/integrations/webex",
		  "docs": [
			{
			  "path": "/integrations/webex/webhooks",
			  "frontMatter": {
				"description": "Develop and test Webex webhooks from localhost",
				"title": "Cisco Webex Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Cisco Webex webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Cisco Webex webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Cisco Webex by using Webhooks.\nCisco Webex webhooks can be used to notify an external application whenever specific events occur in your Cisco Webex account.\n\nBy integrating ngrok with Cisco Webex, you can:\n\n- **Develop and test Cisco Webex webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Cisco Webex** in real-time via the inspection UI and API.\n- **Modify and Replay Cisco Webex Webhook requests** with a single click and without spending time reproducing events manually in your Cisco Webex account.\n- **Secure your app with Cisco Webex validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Cisco Webex).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Cisco Webex \n\nTo register a webhook on your Cisco Webex account follow the instructions below:\n\n1. Access [Cisco Webex Developer Portal](https://developer.webex.com/), sign in using your Cisco Webex account, and then open the (Personal Access Token documentation)[https://developer.webex.com/docs/getting-started#accounts-and-authentication] in the same browser tab.\n\n1. Click the copy icon in the **Your Personal Access Token** field.\n\n1. Open a terminal window and run the following command to register your webhook:\n\n   ```bash\n   curl --location 'https://webexapis.com/v1/webhooks' \\\n   --header 'Authorization: Bearer TOKEN' \\\n   --header 'Content-Type: application/json' --data '{\n   \"name\": \"localhost app via ngrok webhook\", \\\n   \"targetUrl\": \"URL\", \\\n   \"resource\": \"meetings\", \\\n   \"event\": \"started\",\n   \"secret\":\"SECRET_KEY\"\n   }'\n   ```\n\n   **Note**: Replace the following with values copied on previous steps:\n   - TOKEN: **Your Personal Access Token**.\n   - URL: the URL provided by the ngrok agent to expose your application to the internet (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   - SECRET_KEY: A value to sign each request sent to your application.\n\n   ![URL to Publish](img/ngrok_url_configuration_webex.png)\n\n### Run Webhooks with Cisco Webex and ngrok\n\nIn the previous section, you registered a webhook to trigger calls to your application whenever you create a meeting.\nYou can trigger new calls from Cisco Webex to your application by following the instructions below.\n\n1. Access [Cisco Webex](https://www.webex.com), sign in, and then click **Start a meeting**.\n\n   Confirm your localhost app receives the create-project event notification and logs both headers and body in the terminal.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Cisco Webex webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Create a traffic policy file named `webex_policy.yml`, replacing `{your webhook secret}` with the **SECRET_KEY** value you provided during the webhook registration (See [Integrate ngrok and Cisco Webex.](#setup-webhook)):\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: webex\n             secret: \"{your webhook secret}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file webex_policy.yml\n   ```\n\n1. Access [Cisco Webex](https://www.webex.com), sign in, and then click **Start a meeting**.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "Cisco Webex Webhooks"
			}
		  ],
		  "metadata": {
			"name": "webex",
			"description": "",
			"excerpt": "",
			"title": "Webex"
		  }
		},
		{
		  "name": "whatsapp",
		  "path": "/integrations/whatsapp",
		  "docs": [
			{
			  "path": "/integrations/whatsapp/webhooks",
			  "frontMatter": {
				"description": "Develop and test WhatsApp webhooks from localhost",
				"title": "WhatsApp Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate WhatsApp webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm run startFacebook`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000 --url myexample.ngrok.app`\n1. [Configure WhatsApp webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with WhatsApp by using Webhooks.\nWhatsApp webhooks can be used to notify an external application whenever specific events occur in your WhatsApp account.\n\nBy integrating ngrok with WhatsApp, you can:\n\n- **Develop and test WhatsApp webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from WhatsApp** in real-time via the inspection UI and API.\n- **Modify and Replay WhatsApp Webhook requests** with a single click and without spending time reproducing events manually in your WhatsApp account.\n- **Secure your app with WhatsApp validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm run startFacebook\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n**Note:** This integration requires an ngrok Pro or Enterprise license because Facebook validates your ngrok domain and certificate.\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com), click **Your Authtoken**, and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n\n1. On the left menu, expand **Universal Gateway** and then click **Domains**.\n   **Tip:** If you don't have an ngrok Pro or Enterprise license, sign up for one by clicking **Update Subscription** and follow the subscribe procedure.\n\n1. On the **Domains** page, click **+ Create Domain** or **+ New Domain**.\n\n1. In the **Domain** pane, provide a value for the **Domain** field (i.e. `myexample.ngrok.app`), and then click **Continue**.\n   ![ngrok New Domain](/img/integrations/ngrok_new_domain.png)\n   **Tip**: Make sure your domain is available.\n\n1. Close the **Start a Tunnel** pane and then close the **Domain** pane.\n\n1. Start ngrok by running the following command in a terminal on your local desktop:\n\n   ```bash\n   ngrok http 3000 --url myexample.ngrok.app\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Facebook).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel_domain.png)\n\n## **Step 3**: Integrate WhatsApp \n\nTo register a webhook on your WhatsApp account follow the instructions below:\n\n**Requirements**: You'll need a Facebook app and a business phone number associated with your Facebook app. Create one before following the rest of these steps.\n\nConnect your Facebook page with your WhatsApp account by following the instructions below:\n\n1. Access the [Meta for Developers](https://developers.facebook.com/) page, and Log in using your Facebook account.\n\n1. On the Developers page, click **My Apps** and then click your app.\n1. On the app dashboard, click **Add Product** on the left menu, and then click **Set up** inside the **WhatsApp** tile.\n\n1. On the left menu, click **Configuration** under **WhatsApp** and then click **Edit**.\n\n1. In the **Edit webhook's callback URL** popup, enter the URL provided by the ngrok agent to expose your application to the internet in the **Callback URL** field, with `/webhooks` at the end (i.e. `https://myexample.ngrok.app/webhooks`).\n   ![Callback URL](img/ngrok_url_configuration_whatsapp.png)\n\n1. Enter `12345` in the **Verify token** field and then click **Verify and save**.\n\n1. After you add a webhook to WhatsApp, WhatsApp will submit a validation post request to your application through ngrok. Confirm your localhost app receives the validation get request and logs `WEBHOOK_VERIFIED` in the terminal.\n\n1. Back to the **Configuration** page, click **Manage**.\n\n1. On the **Webhook fields** popup, click **Subscribe** to the **messages** field.\n   **Tip**: You can subscribe to multiple fields.\n\n1. Click **Test** for the **messages** field and confirm your localhost app receives a post request.\n\n1. On the **Webhook fields** popup, click **Done**.\n\n1. Back to the **Configuration** page, make sure you have a production number associated with your app. If not, click **Manage phone numbers** and make note of the **Test Number** WhatsApp provides to you.\n\n1. Back to the **Configuration** page, on the top of your app's page, make sure **App Mode** is **Live**.\n\n### Run Webhooks with WhatsApp and ngrok\n\nUse the phone number associated to your WhatsApp product or use the test number you copied before.\n\n1. Add this number to your WhatsApp app contacts and then send a message to this number.\n\nConfirm your localhost app receives a message and logs both headers and body in the terminal.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your WhatsApp webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Access the [Meta for Developers](https://developers.facebook.com/) page, log in using your WhatsApp account, and then click **My Apps** in the top right corner.\n\n1. On the Developers page, expand **Settings** on the left menu and then click **Basic**.\n\n1. In the **Basic Settings** page, click **Show** to reveal the **App secret** value and copy this value.\n\n1. Create a traffic policy file named `whatsapp_policy.yml`, replacing `{your app secret}` with the value you have copied before:\n\n   ```yaml\n   on_http_request:\n     - name: \"WhatsApp Webhooks\"\n       actions:\n         - type: \"webhook-validation\"\n           config:\n             provider: facebook_graph_api\n             secret: \"{your app secret}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file whatsapp_policy.yml\n   ```\n\n1. Access the WhatsApp page you have assigned to your webhook and send a message to another WhatsApp user.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "WhatsApp Webhooks"
			}
		  ],
		  "metadata": {
			"name": "whatsapp",
			"description": "",
			"excerpt": "",
			"title": "WhatsApp"
		  }
		},
		{
		  "name": "worldline",
		  "path": "/integrations/worldline",
		  "docs": [
			{
			  "path": "/integrations/worldline/webhooks",
			  "frontMatter": {
				"description": "Develop and test Worldline webhooks from localhost",
				"title": "Worldline Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Worldline webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Worldline webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Worldline by using Webhooks.\nWorldline webhooks can be used to notify an external application whenever specific events occur in your Worldline account.\n\nBy integrating ngrok with Worldline, you can:\n\n- **Develop and test Worldline webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Worldline** in real-time via the inspection UI and API.\n- **Modify and Replay Worldline Webhook requests** with a single click and without spending time reproducing events manually in your Worldline account.\n- **Secure your app with Worldline validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Worldline).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Worldline \n\nTo register a webhook on your Worldline account follow the instructions below:\n\n1. Access [Worldline](https://www.worldline.com/) and sign in using your Worldline account.\n\n1. On the left menu, click **Developer** and then click **Webhooks**.\n\n1. On the **Webhooks** page, click **Create a Webhook**.\n\n1. On the **Webhooks** page, click **Generate webhook keys** and make note of the **Secret Webhook Key** field value.\n\n1. Click **Add webhook endpoint**, enter the URL provided by the ngrok agent to expose your application to the internet in the **Endpoint URL** field (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`), and then click **Confirm**.\n   ![Worldline webhook URL](img/ngrok_url_configuration_worldline.png)\n\n### Run Webhooks with Worldline and ngrok\n\nWorldline sends different request body contents depending on the event that is being triggered.\nYou can trigger a test call from Worldline to your application by following the instructions below.\n\n1. In the same browser, click **Payment links** on the left menu and then click **Generate link**.\n\n1. On the **Generate link** page, enter a value in the **Amount** and **Order reference** fields, and then click **Generate link**.\n\n1. On the **Share link** page, click the copy icon close to the payment link, paste this link to a new browser tab, select **Bancontact** as the payment method, and then click **Cancel**.\n\n   Confirm your localhost app receives post request notifications and logs both headers and body in the terminal.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Worldline webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Create a traffic policy file named `worldline_policy.yml`, replacing `{your webhook secret}` with the value of the **Secret Webhook Key** (See [Integrate ngrok and Worldline.](#setup-webhook)):\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: worldline\n             secret: \"{your webhook secret}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file worldline_policy.yml\n   ```\n\n1. Access [Worldline](https://www.worldline.com/), sign in, create a new payment link, open the link in a new browser tab, and select **Bancontact** as the payment method.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "Worldline Webhooks"
			}
		  ],
		  "metadata": {
			"name": "worldline",
			"description": "",
			"excerpt": "",
			"title": "Worldline"
		  }
		},
		{
		  "name": "xero",
		  "path": "/integrations/xero",
		  "docs": [
			{
			  "path": "/integrations/xero/webhooks",
			  "frontMatter": {
				"description": "Develop and test Xero webhooks from localhost",
				"title": "Xero Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Xero webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Xero webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Xero by using Webhooks.\nXero webhooks can be used to notify an external application whenever specific events occur in your Xero account.\n\nBy integrating ngrok with Xero, you can:\n\n- **Develop and test Xero webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Xero** in real-time via the inspection UI and API.\n- **Modify and Replay Xero Webhook requests** with a single click and without spending time reproducing events manually in your Xero account.\n- **Secure your app with Xero validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Xero).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Xero \n\nTo register a webhook on your Xero account follow the instructions below:\n\n1. Access the [Xero Developer](https://developer.xero.com/app/manage/) site and sign in using your Xero account.\n\n1. Click one of the apps listed on the **Apps** page. If you don't have an app, create one by clicking **New app**.\n\n1. On the app page, click **Webhooks** on the left menu.\n\n1. On the **Webhooks** page, click the checkbox for **Billing subscriptions**, **Contacts** and **Invoices**, and then enter the URL provided by the ngrok agent to expose your application to the internet in the **Delivery URL** field (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![xero URL to Publish](img/ngrok_url_configuration_xero.png)\n\n1. Click **Send 'Intent to Receive'**.\n\n   Confirm your localhost app receives notification and logs both headers and body in the terminal.\n\n1. Click **Save**.\n\n1. Access the [Xero dashboard](https://go.xero.com/) site, sign in using your Xero account, and then select your organization in the drop-down menu.\n\n1. Click your organization **Dashboard** page, click **Settings**, click **Connected Apps**, and then confirm your app appears in the list of **Connected apps**.\n\nIf your app isn't connected to your organization execute the following steps:\n\n1. In a new browser tab, open the following URL:\n\n   ```\n   https://login.xero.com/identity/connect/authorize?response_type=code&client_id=APP_CLIENT_ID&redirect_uri=APP_REDIRECT_URI&scope=offline_access accounting.transactions openid profile email accounting.contacts accounting.settings&state=123\n   ```\n\n   **Note**: Replace the following with values copied from the **Configuration** page of your app on the [Xero Developer](https://developer.xero.com/app/manage/) site:\n   - APP_CLIENT_ID: Your app **Client id**.\n   - APP_REDIRECT_URI: Your app **Redirect URIs**.\n\n1. On the **User Consent** page, select your organization and then click **Allow access**.\n\n### Run Webhooks with Xero and ngrok\n\nXero sends different request body contents depending on the event that is being triggered.\nYou can trigger new calls from Xero to your application by following the instructions below.\n\n1. Access the [Xero dashboard](https://go.xero.com/) site, sign in using your Xero account, and then select your organization in the drop down menu.\n\n1. On the organization **Dashboard** page, click **Contacts** at the top menu and then click **New Contact**.\n\n1. On the **Add Contact** page, fill up the **Contact name**, **Account number**, **First Name**, and **Last Name** fields, and then click **Save & Close**.\n\n   Confirm your localhost app receives an event notification and logs both headers and body in the terminal.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Xero webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Access [Xero Developer](https://developer.xero.com/myapps/webhooks/) page and sign in using your Xero account.\n\n1. Click your app tile and then click **Webhooks** on the left menu.\n\n1. Copy the value of the **Webhooks key**.\n\n1. Create a traffic policy file named `xero_policy.yml`:\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: xero\n             secret: {your webhook key}\n   ```\n\n   **Note**: Replace `{your webhook key}` with the value you copied before.\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file xero_policy.yml\n   ```\n\n1. Access the [Xero dashboard](https://go.xero.com/) and create a new contact.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "Xero Webhooks"
			}
		  ],
		  "metadata": {
			"name": "xero",
			"description": "",
			"excerpt": "",
			"title": "Xero"
		  }
		},
		{
		  "name": "zendesk",
		  "path": "/integrations/zendesk",
		  "docs": [
			{
			  "path": "/integrations/zendesk/webhooks",
			  "frontMatter": {
				"description": "Develop and test Zendesk webhooks from localhost",
				"title": "Zendesk Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Zendesk webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Zendesk webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Zendesk by using Webhooks.\nZendesk webhooks can be used to notify an external application whenever specific events occur in your Zendesk account.\n\nBy integrating ngrok with Zendesk, you can:\n\n- **Develop and test Zendesk webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Zendesk** in real-time via the inspection UI and API.\n- **Modify and Replay Zendesk Webhook requests** with a single click and without spending time reproducing events manually in your Zendesk account.\n- **Secure your app with Zendesk validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nThis will get the project installed locally.\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and responds with a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running successfully on localhost, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Zendesk).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Zendesk \n\nTo register a webhook on your Zendesk account follow the instructions below:\n\n1. Access [Zendesk](https://www.zendesk.com), and sign in using your Zendesk account.\n\n1. On the left menu, click the gear icon named **Admin** and then click **Go to Admin Center**.\n\n1. On the **Admin Center** page, click **Apps and integrations** on the left menu, and then click **Webhooks**.\n\n1. On the **Get started with webhooks** page, click **Create Webhooks**.\n\n1. In the **Create webhook** page, provide your webhook with a **Name** and in the **Endpoint URL** field enter the URL provided by the ngrok agent to expose your application to the internet (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![Your endpoint URL](img/ngrok_url_configuration_zendesk.png)\n\n1. On the same page, select **POST** for the **Request method** field and select **JSON** for the **Request format** field.\n   **Tip**: For your production webhooks, it's recommended to implement your application with either **Basic Authentication** or **Bearer token** authentication method. For this tutorial, leave the **Authentication** field selected as **None** as the sample application doesn't require any sort of authentication.\n\n1. Click **Test webhook** and then click **Send test**.\n\n1. Confirm your localhost app receives the test event notification and logs both headers and body to the terminal, then click **Create** on the **Create webhook** page.\n\n1. On the left menu, click **Objects and rules** and then click **Automations** under the **Business rules** section.\n\n1. On the **Automations** page, click **Add automation** and configure the title, conditions, and actions as per the following image.\n   ![Automation Rule](img/automation_rule_configuration_zendesk.png)\n\n1. In the **Perform these actions**, enter a message like the following for the **JSON body**:\n   `{\"message\":\"{{ticket.requester.name}} we are setting your ticket {{ticket.title}} to urgent priority.\"}`\n\n   In this automation example, a high-priority incident ticket will be set to urgent priority and Zendesk will call your sample application to communicate about this action.\n\n1. Click **Create automation**.\n\n### Run Webhooks with Zendesk and ngrok <a id=\"run-webhook\"></a>\n\nAs per the previous configuration, you've selected to trigger your webhook anytime a high-priority incident ticket is created.\nZendesk sends different request body contents depending on the automation rules you create.\nFollow the instructions below to test your webhook with a new ticket.\n\n1. On the same browser, access [Zendesk](https://www.zendesk.com) and sign in using your Zendesk account.\n\n1. On the top left corner of the home page, mouse over **+ Add**, and then click **Ticket** under the **New** section.\n\n1. In the **New ticket** page, select a user for the **Requester** field, select **Incident** for the **Type** field, select **High** for the **Priority** field, enter a subject, and then click **Submit as New**.\n\n   Zendesk evaluates automation rules every hour. You may need to wait about an hour until Zendesk makes the call to the webhook and your application receives the message about your ticket.\n\n1. Optionally, on the **Admin Center** page, access the **Webhooks** link on the left menu, click your webhook, click the **Activity** tab, and then click the last log that appears on the page.\n   ![Zendesk Webhook logs](img/zendesk_webhook_logs.png)\n\n   Confirm the post request sent by Zendesk is the same as the request received by the localhost application.\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe ngrok signature webhook verification feature allows ngrok to assert that requests from your Zendesk webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Access [Zendesk](https://www.zendesk.com), and sign in using your Zendesk account.\n\n1. On the left menu, click the gear icon named **Admin** and then click **Go to Admin Center**.\n\n1. On the **Admin Center** page, click **Apps and integrations** on the left menu, and then click **Webhooks**.\n\n1. On the **Webhooks** page, click your webhook.\n\n1. In your webhook page, click **Reveal secret** and click **Copy** to copy the **Secret key** value.\n\n1. Create a traffic policy file named `zendesk_policy.yml`, replacing `{your secret key}` with the value you copied before:\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: zendesk\n             secret: \"{your secret key}\"\n   ```\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file zendesk_policy.yml\n   ```\n\n1. Execute the procedures in the [Run Webhooks with Zendesk and ngrok](#run-webhooks-with-zendesk-and-ngrok-) section to create a new ticket.\n\n   Verify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "Zendesk Webhooks"
			}
		  ],
		  "metadata": {
			"name": "zendesk",
			"description": "",
			"excerpt": "",
			"title": "Zendesk"
		  }
		},
		{
		  "name": "zoom",
		  "path": "/integrations/zoom",
		  "docs": [
			{
			  "path": "/integrations/zoom/webhooks",
			  "frontMatter": {
				"description": "Develop and test Zoom webhooks from localhost",
				"title": "Zoom Webhooks"
			  },
			  "content": "import InspectingRequests from \"/snippets/integrations/_inspecting-requests.mdx\";\nimport ReplayingRequests from \"/snippets/integrations/_replaying-requests.mdx\";\n\n<Tip>\n**TL;DR**\n\n\n\nTo integrate Zoom webhooks with ngrok:\n\n1. [Launch your local webhook.](#start-your-app) `npm start`\n1. [Launch ngrok.](#start-ngrok) `ngrok http 3000`\n1. [Configure Zoom webhooks with your ngrok URL.](#setup-webhook)\n1. [Secure your webhook requests with verification.](#security)\n</Tip>\n\nThis guide covers how to use ngrok to integrate your localhost app with Zoom using webhooks.\nZoom webhooks can send notifications to external apps whenever specific events occur in your Zoom account.\n\nBy integrating ngrok with Zoom, you can:\n\n- **Develop and test Zoom webhooks locally**, eliminating the time in deploying your development code to a public environment and setting it up in HTTPS.\n- **Inspect and troubleshoot requests from Zoom** in real-time via the inspection UI and API.\n- **Modify and Replay Zoom Webhook requests** with a single click and without spending time reproducing events manually in your Zoom account.\n- **Secure your app with Zoom validation provided by ngrok**. Invalid requests are blocked by ngrok before reaching your app.\n\n## **Step 1**: Start your app \n\nFor this tutorial, we'll use the [sample NodeJS app available on GitHub](https://github.com/ngrok/ngrok-webhook-nodejs-sample).\n\nTo install this sample, run the following commands in a terminal:\n\n```bash\ngit clone https://github.com/ngrok/ngrok-webhook-nodejs-sample.git\ncd ngrok-webhook-nodejs-sample\nnpm install\n```\n\nNow you can launch the app by running the following command:\n\n```bash\nnpm start\n```\n\nThe app runs by default on port 3000.\n\nYou can validate that the app is up and running by visiting http://localhost:3000. The application logs request headers and body in the terminal and a message in the browser.\n\n## **Step 2**: Launch ngrok \n\nOnce your app is running locally, let's get it on the internet securely using ngrok!\n\n1. If you're not an ngrok user yet, just [sign up for ngrok for free](https://ngrok.com/signup).\n\n1. [Download the ngrok agent](https://download.ngrok.com).\n\n1. Go to the [ngrok dashboard](https://dashboard.ngrok.com) and copy your Authtoken. <br />\n   **Tip:** The ngrok agent uses the auth token to log into your account when you start a tunnel.\n1. Start ngrok by running the following command:\n\n   ```bash\n   ngrok http 3000\n   ```\n\n1. ngrok will display a URL where your localhost application is exposed to the internet (copy this URL for use with Zoom).\n   ![ngrok agent running](/img/integrations/launch_ngrok_tunnel.png)\n\n## **Step 3**: Integrate Zoom \n\nThere are multiple ways you can integrate your application with Zoom. This guide covers the Webhook-only feature, which can be set up using a free Zoom account.\n\nTo register for webhook events:\n\n1. Access [Zoom Marketplace](https://marketplace.Zoom.us/) and sign in using your Zoom account.\n\n1. Click **Develop** > **Build App**.\n\n1. Select the **Webhook Only** app.\n\n1. Enter a **Name** for the app and click **Create**.\n\n1. Complete the registration with your **Company Name**, developer **Name**, and **Email address** and click **Continue**.\n\n1. On the **Feature** page, click the **Event subscriptions** slider, click **Add Event Subscriptions**, and for the **Event notification endpoint URL** field use the URL provided by the ngrok agent to expose your application to the internet (i.e. `https://1a2b-3c4d-5e6f-7g8h-9i0j.ngrok.app`).\n   ![Configure Event notification endpoint URL](img/ngrok_url_configuration_zoom.png)\n\n   **Tip**: For security purposes, copy the **Secret Token** for later use.\n\n1. Click **Add Events**. and select the events for notification. For this tutorial, select **Start Meeting** and **End Meeting**, and then click **Done**.\n\n1. Finally, back to the **Feature** page, click **Save**, and then click **Continue**.\n   The message **Your app is activated on the account** indicates Zoom is ready to send events to your app.\n\nYou can review your Webhook by clicking **Manage** in the top-right corner of the Marketplace page.\n\n### Run Webhooks with Zoom and ngrok\n\nAfter you add a webhook to your Zoom account, access your Zoom account, start a meeting, and after a few seconds, end the meeting.\nThe localhost app receives notifications about both events.\n\nTo review the content of these requests in Zoom:\n\n1. Click **Manage** on the top-right corner of the Marketplace page.\n\n1. In the action column click **Call Logs** in the left menu, and then click the **Webhook Logs** tab.\n\n1. Click your Webhook app.\n   ![Zoom Call logs](img/review_zoom_call_logs.png)\n\n1. Expand the last two log entries, compare the **requestBody** attribute with the body of the request received by your application for each event, and then confirm they contain the same data.\n   **Note:** Zoom sends different request body contents and headers depending on the trigger event.\n\n## Optional next steps \n\nEach post request sent by Zoom to your local application contains an **authorization** header with the value of the **Secret Token** provided during the registration of the Webhook.\nThis information is used to secure your application to make sure it will only process information from the Webhook registered to your Zoom account.\n\nYou can either modify the sample app to validate this header information or use the ngrok signature webhook verification feature. See [Add additional security using ngrok signature webhook verification](#security).\n\n<InspectingRequests />\n\n<ReplayingRequests />\n## Secure webhook requests \n\nThe verification feature allows ngrok to assert that requests from your Zoom webhook are the only traffic allowed to make calls to your localhost app.\n\n**Note:** This ngrok feature is limited to 500 validations per month on free ngrok accounts. For unlimited, upgrade to Pro or Enterprise.\n\nThis is a quick step to add extra protection to your application.\n\n1. Make sure you have copied the **Secret Token** value when you were configuring your Webhook app in Zoom.\n\n1. Create a traffic policy file named `zoom_policy.yml`:\n\n   ```yaml\n   on_http_request:\n     - actions:\n         - type: verify-webhook\n           config:\n             provider: zoom\n             secret: \"{your secret token}\"\n   ```\n\n   **Note**: Replace `{your secret token}` with your **Secret Token** from Zoom.\n\n1. Restart your ngrok agent by running the command:\n\n   ```bash\n   ngrok http 3000 --traffic-policy-file zoom_policy.yml\n   ```\n\n1. In your Zoom dashboard, start a new meeting, and after a few seconds end the meeting.\n\nVerify that your local application receives the request and logs information to the terminal.\n",
			  "contentTitle": "Zoom Webhooks"
			}
		  ],
		  "metadata": {
			"name": "zoom",
			"description": "",
			"excerpt": "",
			"title": "Zoom"
		  }
		}
	  ];

	const integration = integrations.find((i) => i.name === name);

	if (!integration) {
		return null;
	}

	return (
		<Columns cols={2}>
			{integration.docs.map((doc) => (
				<Card
					key={doc.path}
					href={doc.path}
					img={doc.img}
					icon={integration.icon}
					className="flex-col flex"
				>
					<h2 className="text-lg mb-3 font-bold text-strong">{doc.frontMatter.title || doc.name}</h2>
					<span>{doc.frontMatter.excerpt || doc.frontMatter.description}</span>
				</Card>
			))}
		</Columns>
		// <ul className="m-0 mb-5 grid list-none grid-cols-2 gap-5 p-0">
		// 	{integration.docs.map((doc) => (
		// 		<li className="last-of-type:col-span-full" key={doc.path}>
		// 			<NgrokCard
		// 				to={doc.path}
		// 				size="sm"
		// 				title={doc.frontMatter?.title || doc.contentTitle || "Integration"}
		// 				description={doc.frontMatter?.description || doc.excerpt}
		// 			/>
		// 		</li>
		// 	))}
		// </ul>
	);
}
